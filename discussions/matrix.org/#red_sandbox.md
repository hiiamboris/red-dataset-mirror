# Archived messages from: https://app.gitter.im/#/room/#red_sandbox:gitter.im (https://app.gitter.im/#/room/!vizjfgYzCOUHBNcXdY:gitter.im)

## 23-Dec-2020

[19:17:17](#BeRhpGgHawJPk4SuEjbgc03M5bqoVayKGCKhTJhX6-U) <toomasv>:
Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```
... and you'd like to make black (or red or white) transparent? 
How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:17:21](#eY5LSkvtxRuaNJHWgOrghlCqxor9rAaUlnxQttk3zdg) <toomasv>:
Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```
... and you'd like to make black (or red or white) transparent? 
How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:18:58](#brYW9PvzeKG5_yuBBOALxIVFDVUDVy0Gu9BL63htguA) <toomasv>:
* Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```
[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/image.png)

... and you'd like to make black (or red or white) transparent? 
How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:19:07](#v9CsslUJmrJlFbE_bX8OHqpCrrrH-54j6xGl8JQG9Ww) <toomasv>:
* Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```
[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/image.png)

... and you'd like to make black (or red or white) transparent? 
How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:19:43](#V2-20oShWoZi8cA9nU9FU7uQ7QO4PakRAsTwExtxU1g) <toomasv>:
* Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/image.png)

... and you'd like to make black (or red or white) transparent? 

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/image.png)

How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:20:34](#5wVnXDHVxNYdMBztUMxxqZmdGDsSAxK6vf6QQVbIcao) <toomasv>:
* Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/image.png)

... and you'd like to make black (or red or white) transparent? 

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/image.png)

How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:20:59](#8Qm22NxPztk3_t0yPbTCSaiPWhqIHuurS0a-uCJ8Abo) <toomasv>:
* Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/image.png)

... and you'd like to make black (or red or white) transparent? 

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/image.png) [![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/iJqb/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/iJqb/image.png)

How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:21:47](#OD215MLEmB4SN38BpI-49JD3sQfKiuI1XiybgzYoyQM) <toomasv>:
* Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/image.png)

... and you'd like to make black (or red or white) transparent? 

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/image.png) [![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/iJqb/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/iJqb/image.png)

How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:22:04](#b9MQ9AiBacjPYyyO3yLSoYRBePvy4UHdsVz_m3N8Ddw) <toomasv>:
* Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...
```
img1: draw 120x120 [
	anti-alias off 
	pen off 
	box 0x0 119x119 
	pen black 
	line-width 10 
	fill-pen red 
	circle 59x59 40
]
```
... that is on blue background...
```
view [backdrop blue image img1]
```

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/x76p/image.png)

... and you'd like to make black (or red or white) transparent? 

[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/ujQR/image.png) [![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/iJqb/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/iJqb/image.png) [![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/Bf6H/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/Bf6H/image.png)

How would you do this? (I mean taking the existing image, not by new image with new Draw)

My [attempt](https://gist.github.com/toomasv/eee95ae869b71d221076aebf2da7bb8a).


[19:25:41](#gEO0fy_o1Pj-jJPclYSBIuZx9L-6M3X2wIEnDCEqI9I) <hiiamboris (NOT THIS ONE)>:
Using `img/argb` should be faster

[19:28:04](#RjK-VjbgYKHToR-amNqOTirwmPuTys4c7Qayckk_oKE) <hiiamboris (NOT THIS ONE)>:
what's your use case? Ì†ΩÌ∏â

[19:35:52](#5r1vNfzREHpz7Dk3sfYYKw0LpSX1oSszWKUrcstOZR0) <toomasv>:
Just playing around now.
I'll look at the `argb` too. But you have still to "smudge" the color as they are sometimes set off a bit.

[19:36:30](#kliJBHZh6zAD2OjfiqFP_nv9MnjZqGnJTM53panUVOo) <hiiamboris (NOT THIS ONE)>:
It won't happen on D2D. It's a workaround for a GTK+ issue.

[19:36:43](#kVnvLwAxnRsEkYwUPN6aNDQaHQ3_Bilii7lotfTYHxw) <hiiamboris (NOT THIS ONE)>:
* It (color being off) won't happen on D2D. It's a workaround for a GTK+ issue.

[19:37:43](#ePFUDHkwjW_DnhnGLWe0ykPtVDG9ZCDoP9PtqsSYj_Q) <hiiamboris (NOT THIS ONE)>:
I do have a need to subtract and multiply images though Ì†ΩÌ∏â

[19:38:07](#I7xyC8rD9XQqQdTfHL0-GfDo0fQqVgF44XrKq9nrqv4) <hiiamboris (NOT THIS ONE)>:
We really need that and some masking in Draw.

[19:41:36](#I6UHrir0O9NQSKfQZHsgEpvJ74nRtAiPd9vrFrXtkUA) <hiiamboris (NOT THIS ONE)>:
Using 3 charsets is a clever way out :+1:

## 24-Dec-2020

[6:01:08](#v-tUgNXqM8Knd61w0Pb2RlAtjuzUPT4oUchzfQtKMVQ) <toomasv>:
@hiiamboris BTW I arrived at this solution only after having tried and failed to manipulate color of individual pixels directly. E.g. by `img/alpha/<idx>: <1 - 255>`This seems to have no effect. Neither does it work on `rgb` nor on `argb`. Only changing the whole lot at once works, i.e. `img/alpha: 255`. Same for `rgb` and `argb`. But for these it is rarely needed I guess. Is it intended or bug?

[9:36:05](#u25Vq_9HPSIGuFu7DSQ6JZQDKI8YH-Jpoq61jZR0B7s) <hiiamboris (NOT THIS ONE)>:
I mean you can parse (change) whole `argb` then set it back `img/argb: ..` and it'll be faster than mold/load

[9:36:49](#tYs6lDYdoYqkVCStg-qNG81YQMDBQBq2U6j9mkCnMNE) <hiiamboris (NOT THIS ONE)>:
I think it's intended but better ask @qtxie Ì†ΩÌ∏â

[9:52:23](#6jpnegPCIoCXvUM58GsTqxPp0UuaJIGj1xTINma0jbg) <toomasv>:
Ok, thanks!

[10:18:45](#KChj7z3gba21nq7fh7aL4QiNNTtOIpmDLBmlNC0bP3o) <qtxie>:
> Did anybody have a need to make parts of an image transparent based on color? E.g. you have image ...

`key-color` ?  http://www.rebol.com/docs/draw.html#section-14

[10:31:22](#crs6PDzj1bKsBsMSiyFBv5o5oai4-ljVpIr_1n7ZQHg) <toomasv>:
@qtxie Yes, that would be cool too, but is there a simple way to do this just manipulating `image!`, not from inside Draw dialect? Or it will remain a task for user func?

[11:40:46](#lbAhBlwzBzfcnmdeO97LD5Jzqj7HeqaThOawkgMRbR4) <toomasv>:
@hiiamboris I compared two versions of `transparent`, and interestingly, while manipulating `argb` as you suggested is more memory-efficient, it will slow down in proportion to length of changed color, but time of my original method will remain ~constant.
```
	set 'transparent function [img [image!] color [tuple!]][
		spec: load mold img 
		color: smudge color 
		alpha: rejoin parse spec/3/2 [
			collect some [
				color keep (#{FF})
			| 	3 skip keep (#{00})
			]
		] 
		append spec/3 alpha 
		do spec
	]
	set 'transparent2 function [img [image!] color [tuple!]][new?: yes
		img: copy img
		color: reverse smudge color 
		argb: copy img/argb
		parse argb [
			some [
				color change skip (#{00}) 
			| 	4 skip
			]
		] 
		img/argb: argb
		img
	]
```
Profiling:
```
>> profile/count/show [[transparent img1 black][transparent2 img1 black]] 100
Count: 100
Time         | Time (Per)   |      Memory | Code
0:00:01.85   | 0:00:00.019  |    17341884 | [transparent2 img1 black]
0:00:01.886  | 0:00:00.019  |   176054040 | [transparent img1 black]
>> profile/count/show [[transparent img1 red][transparent2 img1 red]] 100
Count: 100
Time         | Time (Per)   |      Memory | Code
0:00:01.827  | 0:00:00.018  |   176055640 | [transparent img1 red]
0:00:02.242  | 0:00:00.022  |    17343484 | [transparent2 img1 red]
>> profile/count/show [[transparent img1 white][transparent2 img1 white]] 100
Count: 100
Time         | Time (Per)   |      Memory | Code
0:00:01.76   | 0:00:00.018  |   176058840 | [transparent img1 white]
0:00:03.535  | 0:00:00.035  |    17346684 | [transparent2 img1 white]
```

[11:41:31](#4q8jXC2Z5WaM5nTukZ4HUEhmBv9Tyf_0HWy6zsZBkJQ) <toomasv>:
* @hiiamboris I compared two versions of `transparent`, and interestingly, while manipulating `argb` as you suggested is more memory-efficient, it will slow down in proportion to length of changed color, but time of my original method will remain ~constant.
```
	set 'transparent function [img [image!] color [tuple!]][
		spec: load mold img 
		color: smudge color 
		alpha: rejoin parse spec/3/2 [
			collect some [
				color keep (#{FF})
			| 	3 skip keep (#{00})
			]
		] 
		append spec/3 alpha 
		do spec
	]
	set 'transparent2 function [img [image!] color [tuple!]][
		img: copy img
		color: reverse smudge color 
		argb: copy img/argb
		parse argb [
			some [
				color change skip (#{00}) 
			| 	4 skip
			]
		] 
		img/argb: argb
		img
	]
```
Profiling:
```
>> profile/count/show [[transparent img1 black][transparent2 img1 black]] 100
Count: 100
Time         | Time (Per)   |      Memory | Code
0:00:01.85   | 0:00:00.019  |    17341884 | [transparent2 img1 black]
0:00:01.886  | 0:00:00.019  |   176054040 | [transparent img1 black]
>> profile/count/show [[transparent img1 red][transparent2 img1 red]] 100
Count: 100
Time         | Time (Per)   |      Memory | Code
0:00:01.827  | 0:00:00.018  |   176055640 | [transparent img1 red]
0:00:02.242  | 0:00:00.022  |    17343484 | [transparent2 img1 red]
>> profile/count/show [[transparent img1 white][transparent2 img1 white]] 100
Count: 100
Time         | Time (Per)   |      Memory | Code
0:00:01.76   | 0:00:00.018  |   176058840 | [transparent img1 white]
0:00:03.535  | 0:00:00.035  |    17346684 | [transparent2 img1 white]
```

[15:20:11](#XyRrL2gr-37ytBk9nS-uhcTzReHXmvEuLROCSkAInRM) <hiiamboris (NOT THIS ONE)>:
that's odd

[16:36:03](#lVVY_PFeS4rnVx_OttaJHfU7xwtV_ZyhGhd_bPlOhO4) <hiiamboris (NOT THIS ONE)>:
```
    set 'transparent3 function [img [image!] color [tuple!]][
        img: copy img
        color: smudge reverse color 
        argb: img/argb
        img/alpha: to #{} parse/case argb [
            collect [
                some [
                    color  keep #{00}
                |   3 skip keep skip
                ]
            ]
        ] 
        img
    ]
```
this one seems best

[16:36:21](#JE0e4IIoJ6fN4X7wZsQtP4T3JCaTKa8BQ0WymCUquws) <hiiamboris (NOT THIS ONE)>:
ideally we want `collect into` but it's broken on binary Ì†ΩÌ∏ü

[16:37:27](#YjwSUpe0hMgBWYF13onnTSOO5si0pdRhkWOpBRAkP60) <hiiamboris (NOT THIS ONE)>:
I find it suspicious though that parse's `change` is that slow

[18:52:23](#SchQUsqjMs1E0-uTcARj1OArS1y0T21wtjmKLCtXlNI) <toomasv>:
Thanks! But.. er.. this doesn't work  Ì†ΩÌ∏ß

[19:03:59](#6s7M5mAcWUCZkHu3x-lc7Evr5BOCZ_MoQDWeFWxnfrQ) <toomasv>:
It works (and is best so far) this way:
```
	set 'transparent3 function [img [image!] color [tuple!]][
        img: copy img
        color: smudge reverse color 
        argb: img/argb
        img/alpha: to #{} parse/case argb [
            collect [
                some [
                    color  skip keep (#{FF})
                |   3 skip skip keep (#{00})
                ]
            ]
        ] 
        img
    ]
```

[19:04:25](#dDfJgqXfZvHONixEvHSCPYaNgDPfTu9Ym2sJGsXoVF0) <toomasv>:
* It works (and is best so far) this way:
```
	set 'transparent3 function [img [image!] color [tuple!]][
        img: copy img
        color: smudge reverse color 
        argb: img/argb
        img/alpha: to #{} parse/case argb [
            collect [
                some [
                    color  skip keep (#{FF})
                |   4 skip keep (#{00})
                ]
            ]
        ] 
        img
    ]
```

[19:23:08](#2Ir36sQFtO_hwX55Z2wKhZD4HZ4a8YcYDde1q1LzRmo) <hiiamboris (NOT THIS ONE)>:
Ah right! I forgot that `alpha` is complementary to alpha in `argb` Ì†ΩÌ∏â

[19:48:56](#gOzdMHaPt0FG3gfNKWtxxWzedP1hbfKUM7WTV61dA9w) <toomasv>:
There is another possibility of direct change, that is best memory-wise but worst time-wise:
```
	set 'transparent4 function [img [image!] color [tuple!]][
		img: copy img
		repeat i length? img [
			all [
				1 >= absolute (a: img/:i/1) - color/1
				1 >= absolute (b: img/:i/2) - color/2
				1 >= absolute (c: img/:i/3) - color/3
				img/:i: as-rgba a b c 255
			]
		]
		img
	]
```

## 25-Dec-2020

[1:13:35](#CnV7nJzS8UPkK7teuvDxuilGO5W6oPa3NxBxkJfq5lA) <qtxie>:
> @qtxie Yes, that would be cool too, but is there a simple way to do this just manipulating `image!`, not from inside Draw dialect? Or it will remain a task for user func?

A task for user func.

## 26-Dec-2020

[14:29:46](#fNiRXPxlHOb5d_P_kybBS3S5ccEKOcjp7VcGvJv8wlA) <toomasv>:
[![Merry Christmas!](https://toomasv.red/images/Misc/merry-christmas.gif)](https://toomasv.red/images/Misc/merry-christmas.gif)

[19:55:21](#HNywN-LVht8LLbdgQlp_5jztwrNy8GM52Le4Mg7HGBM) <greggirwin (Gregg Irwin)>:
Code! I want the code for Christmas! ;^)

Very nice Toomas. Thanks for posting that.

[19:55:50](#4EYMdiJwdNvaHts4hN2dr3tL1UOD_dg3tfk1NaTF3tY) <greggirwin (Gregg Irwin)>:
I always love the creative things you come up with.

[21:18:21](#77DOfHetl454aRC8o7uwlp0u4xIib00Ro1UlNgBv8VU) <toomasv>:
Ì†ΩÌ∏Ñ  Thanks! Code is below. `transparent` is any func from above. For some reason switching off anti-aliasing seems sometimes not to work and there are still half-tones. I added a step to eliminate these but this makes font fatter. The version above was made without this step.
```
xmas: make font! [size: 32 style: 'bold]
ximg: draw 360x70 [
   anti-alias off 
   fill-pen white pen off 
   box 0x0 359x69 
   pen black font xmas 
   text 4x0 "Merry Christmas!"
]
ximg/rgb: to #{} parse ximg/rgb [
   collect some [keep #{FFFFFF} | 3 skip keep (#{010101})]
]
do %transparent.red
xi: transparent ximg black
img: load %rainbow.png
view/tight/flags [
   title "" 
   box 360x70 
   draw [
      i1: image img 0x0 359x69 
      i2: image img -360x0 -1x69
   ] on-time [
      x1: i1/3/x + 5 % 360 
      i1/3/x: i2/4/x: x1 
      i1/4/x: x1 + 360 
      i2/3/x: x1 - 360
   ] 
   rate 30 
   at 0x0 image xi
][no-min no-max]
```

[21:18:42](#7kmcIfo4qsJSRGr-zHHmG6Urcshw1v7IPyWk8AuxFhY) <toomasv>:
[![rainbow.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/X9b2/thumb/rainbow.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/X9b2/rainbow.png)

[21:19:01](#CBv72wj-OxLxJYBGb6nRLW4XnXgu7yhwQONbxVolm7Q) <toomasv>:
* Here is `rainbow.png`:
[![rainbow.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/X9b2/thumb/rainbow.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/X9b2/rainbow.png)

[21:47:27](#wki2aIoGdNDR_0eOpI2ccrWlb8j-RLNw6qMLlSdR57w) <hiiamboris (NOT THIS ONE)>:
Should be possible to replace rainbow with a gradient 

[23:11:20](#ESSSZPLTqgsxnwkh8fcNJ0EV1W0rKsecVhLljXSr77w) <greggirwin (Gregg Irwin)>:
Thanks!

## 27-Dec-2020

[5:46:27](#EtqbxLK_QK0XK7LdJSCMDMQwKCPAU8YNjFzRBmWdU68) <gltewalt (Greg T)>:
peeking in, looking around

[6:10:16](#rhAtjNY8x7zug5C3V4oh3ICFjrZdNQtq5DamDRP_TnI) <toomasv>:
@gltewalt Hi, Greg! Nice to see you around!
@hiiamboris  Yes, but rainbow was just befor my nose..

[6:10:23](#_jwSapFIIEc7fawHBu0abTx6anQ_9AgR1dVn35G7uPA) <toomasv>:
* @gltewalt Hi, Greg! Nice to see you around!
@hiiamboris  Yes, but rainbow was just before my nose..

[6:46:10](#hcy6X8u7o70wnJDyNwHvPHiOCz2MaNPSiskTKG-m78c) <gltewalt (Greg T)>:
Hi @toomasv  :-)

[6:49:06](#yyAaKYJddQJNAoeEzSGCqiFVv06hvwu3sssgsUWkBEw) <gltewalt (Greg T)>:
Easy using Red despite my extreme rust, but the possibility of solving it without a string involved got me thinking...

https://leetcode.com/problems/palindrome-number/

[6:50:48](#2vboQIt4Nel_MjL7FR1pXwgXpAxS120gJoXTGPag_CQ) <toomasv>:
Ok, so, what's your solution?

[6:53:19](#xJWXs0ZX0vsfDYi7_7OehxlMaYiSBNVGX9yBvGDLCVI) <gltewalt (Greg T)>:
I don't have one that doesn't involve a string.

[6:54:27](#63cYJU2I0AjZCWrST0HmnGqMQ9i4U21_tGfaDxhSZCc) <gltewalt (Greg T)>:
the quick solution that involves `mold`

```
num-palindrome?: func [num [integer!]][either negative? num [false][num == load reverse mold num]]
```

[6:56:04](#lJvyko6-jzBrAD4kMTf_61S_Bs81MIRh4YseoifNgiI) <toomasv>:
Yes, string manipulation for that seems easiest. I got this:
```
palindrome: func [input][(a: form input) = reverse copy a]
```

[6:56:27](#2QzSrflQjivK-MzP8ss1A_7cflmaLOdWQ-lZxbi1DpA) <gltewalt (Greg T)>:
And by their example #2, should a positive sign also be false? `+909`

[6:57:13](#2ODzdXfcUahlH0yKMJxtg2X1yCJcCCIMmXWdLyvytgA) <toomasv>:
I think so, because he treats number as string, otherwise `-121` could not become `121-`.

[6:57:14](#y7GxxpnmR8r5rWQgy1I0z5F7OmFtoVodOqhdCfkYPFE) <gltewalt (Greg T)>:
The thing that interested me was whether it would be possible in Red to do it without a string

[6:57:51](#d2HETy2YcBIYHemyK-UosvlJoLOg0v2NRA9KVinTy1A) <gltewalt (Greg T)>:
As for +909, Red treats them the same, discarding the +

[6:59:21](#myvv0yyyt13iJWbHksJZmNJNtEuZg8nCOeMNaQFzIxE) <toomasv>:
Hmm, I think only treating it on lexer level (or transcode) can detect this.

[6:59:35](#tqid7X5IzViSFafoRVp5aBrBQF3sSImjgZbmQw1vEX4) <gltewalt (Greg T)>:
I think your'e right

[6:59:50](#mP5eokpfxZulVjC7Jfev5wGyCt6Ez9sDf8e1IGs2CYA) <gltewalt (Greg T)>:
* I think you are  right

[7:00:05](#dxONmMF2JQy_iJdyswDt5aHA3VVueeE5hKI5lpRhZg4) <toomasv>:
Ok, have to go. Hope to see you around!

[7:00:33](#PZWOVp1qJe9iKhWZ4r8A0_Zgjtxsy6_3k4LnTVEWzW0) <gltewalt (Greg T)>:
Ok, see you later :)

[8:32:16](#rwZPpo6_ue0YwPBB35_ll9NA0_q03NJ_ef_BuufDYPM) <gltewalt (Greg T)>:
```
?: func [n [integer!]][
   if find n: append copy http:// n '- [false]
   (last split n "//") == (first split reverse n "//")
]
```

[8:33:17](#jOxAO14JdsQuhq6Aq2QGSdeGYbnPXtcNQxASbSu-CcE) <gltewalt (Greg T)>:
bed time..

[10:35:40](#7bNSjMr697JPPJVt5kudc5N4tEmy_7rSxcF4J9WiGPA) <toomasv>:
@gltewalt Here's my try to solve it numerically:
```
pal-int-rome: function [i [integer!]][case [i = 0 [return true] i < 0 [return false] 'else [n: 1 pieces: clear [] while [i > 0][append pieces i - (i: round/floor/to i m: 10 ** n) / (m / 10) n: n + 1] pieces = reverse copy pieces]]]
pal-int-rome 11 ;== true
pal-int-rome 12 ;== false
pal-int-rome 22 ;== true
pal-int-rome 222 ;== true
pal-int-rome 322 ;== false
pal-int-rome 22322 ;== true
pal-int-rome 22332 ;== false
pal-int-rome 23332 ;== true
pal-int-rome -23332 ;== false

;But also...
pal-int-rome +23332 ;== true
pal-int-rome -0 ;== true
```

[10:37:05](#EpyC5KTU5k-p7QIcnWSNbU_oWXgPWVM0334DePuoOMg) <toomasv>:
* @gltewalt Here's my try to solve it numerically:
```
pal-int-rome: function [i [integer!]][
   case [
      i = 0 [return true] 
      i < 0 [return false] 
      'else [
         n: 1 
         pieces: clear [] 
         while [i > 0][
            append pieces i - (i: round/floor/to i m: 10 ** n) / (m / 10) 
            n: n + 1
         ] 
         pieces = reverse copy pieces
      ]
   ]
]
pal-int-rome 11 ;== true
pal-int-rome 12 ;== false
pal-int-rome 22 ;== true
pal-int-rome 222 ;== true
pal-int-rome 322 ;== false
pal-int-rome 22322 ;== true
pal-int-rome 22332 ;== false
pal-int-rome 23332 ;== true
pal-int-rome -23332 ;== false

;But also...
pal-int-rome +23332 ;== true
pal-int-rome -0 ;== true
```

[13:41:28](#5n2p0c3HJJp7K7fTESsn1NJxeaQpheuGoIbbqCL9XEQ) <toomasv>:
Here is adjusted code for rainbow messages. Doesn't need extras anymore:
```
xfont: make font! [size: 32 style: 'bold]
sz: 360x70
ximg: draw sz [font xfont text 4x0 "Merry Christmas!"]
area: make-face 'area [size: 1200x20]
make-merry: func [/color clr [tuple!] /font fspec [block!] /text txt /pad pd][
	if font [xfont: make font! fspec]
	pd: any [pd 4x0]
	if text [
		area/font: xfont 
		sz: size-text/with area txt 
		ximg: draw sz compose [font xfont text (pd) (txt)]
	]
	clr: either color [reverse to-binary clr][#{FFFFFF}]
	xi: copy ximg
	xi/argb: to #{} parse xi/argb [
		collect some [set a 3 skip keep (clr) skip keep (a)]
	]
	system/view/auto-sync?: off
	
	view/tight/flags compose/deep [
		title "" 
		box (sz) draw [
			pen off 
			fill-pen linear blue green yellow red blue 
			i1: box 0x0 (sz - 1) 
			i2: box (as-pair 0 - sz/x 0) (as-pair 0 sz/y - 1)
		] on-time [
			x1: i1/2/x + 5 % (sz/x) 
			i1/2/x: i2/3/x: x1 
			i1/3/x: x1 + (sz/x) 
			i2/2/x: x1 - (sz/x) 
			show face
		] rate 30 
		at 0x0 image xi
	][no-min no-max]
]
```
Try with examples:
```
make-merry
make-merry/text "Happy New Year!"
make-merry/color/font sky [size: 48 style: 'bold name: "Courier New"]
```

[13:47:32](#G6ZvHZLiqXVOUuyQwuGb_-YlnFYHrb_XNHLbCp1A1Uk) <hiiamboris (NOT THIS ONE)>:
Ì†ΩÌ±è

[14:04:48](#m6uw_45gBIwuTT1nsLyTTRCp2nrAOgAry2RA1LVI_IY) <toomasv>:
@hiiamboris Thanks for your help!

[14:05:06](#mxYdrJNO1KPYNwK66-snmW4avTAw1O-ykOckrMTb32I) <toomasv>:
* @hiiamboris Thanks for your help and suggestions!

[17:52:12](#UvFZFeTOYO1flhU4sXnZUA5BuwCmVS0ROl9GcHtQkIw) <gltewalt (Greg T)>:
yep, I was thinking in wrangling datatypes. math works

[17:52:38](#l7q0M9agREBNlZvu0yWYvqnEY2kztyEJd5wj_z1U5k8) <gltewalt (Greg T)>:
* yep, I was thinking in wrangling datatypes but math works

[21:54:48](#NMIVMtsmQiuOJJUSiX7ko0bI2bEHZK7uafWlNb9ShCk) <greggirwin (Gregg Irwin)>:
@gltewalt nice to see you!

@toomasv that's a great and terrible pun name. And a nice numeric solution!

## 28-Dec-2020

[2:40:43](#4SJPQoLGqCrXC5KQzbvrD7pgUi-iiRMdcyg-CEgrmbI) <gtzip (gtzip)>:
Can do it with a formula, I'm sure, but im math disabled

[2:41:29](#LZrkOvMJOR6QghyQCd_mzlWAz6nypJrbND2sOWZ0FS8) <gtzip (gtzip)>:
I always sign in to an ancient github thats the wrong one

[2:46:40](#IiaGpvCLKX-LrBrCzMYnp7m_8y4MMJsnr7TTO9cMZ3Q) <gltewalt (Greg T)>:
There

[2:47:17](#RcE6B-0p5IF3OZPbKToHwpawWb6zcouSJz0Ipfr1j1w) <gltewalt (Greg T)>:
 Hi Gregg

[19:47:03](#hindP84bhCipj4-c6lzpa1ajFMsG1_cskFIAQfwlYVc) <greggirwin (Gregg Irwin)>:
@toomasv don't lose that code! Really nice, and efficient if my CPU meter is to be trusted.

## 29-Dec-2020

[0:18:13](#Tf_9a5444uCFM1zQsdTJF6Kqkh4WLa9tPDvNMagUdhI) <gltewalt (Greg T)>:
Been slowly working through Haskell, and it's a mind jostler.

[0:41:31](#6seSZ5mj7bNkwlkvn2FN_4p5DCEoknRdxjaUIdDkWWM) <gltewalt (Greg T)>:
Might hit a wall 

[0:54:57](#oiGE4xzrbFGIsEvKzECddT53_UK_VtLfnrCX3ryCv-k) <gltewalt (Greg T)>:
Forgot about red/chitchat. So... are sandbox and chitchat essentially the same ?

[0:56:24](#oR553W_rdqhY7qRJABw3Ou1dCc27KmvFViiZvQoplko) <greggirwin (Gregg Irwin)>:
Chit chat is more social, sandbox is for fun things people work on.

[13:59:47](#CcEPVioFUpVlIFrEsjFxgw9hI2TDyRoUsK6OMoWaPWg) <toomasv>:
@greggirwin 

> don't lose that code!

Tuned it a bit more:
https://gist.github.com/toomasv/2089756677219fca1cd67a0067e7e07d


[18:16:28](#8dhqHx8hjeccd53XTn2pOVRDEmD_Ul-DC9SUTjSbUpk) <toomasv>:
It's snowing here
[![white-christmas](https://toomasv.red/images/Misc/flakes.gif)](https://toomasv.red/images/Misc/flakes.gif)

[18:43:20](#WPwLs-ZfVJaZbwTXdj2ypaT4UvdKc1KX75EkQ7I6WUo) <greggirwin (Gregg Irwin)>:
Ì†ΩÌ±è  :^)

[18:45:15](#R6P4dqukfpqagdDtyO3TtHmSx2FephP7jz0vUxq6R6Y) <greggirwin (Gregg Irwin)>:
Maybe we should add a holiday folder to red/code or red/community for seasonal demos.

## 31-Dec-2020

[17:19:20](#aJTlnClvEB6Au1RGPSgay6cADb2OyA1Iy8K_kHtU2ew) <toomasv>:
Maybe we should add a holiday folder to red/code or red/community for seasonal demos.

## 3-Jan-2021

[11:15:49](#ggOzoxv90HJQS3JR3vQ8lGHoqx4Q-RdSSvD4T0oAVdI) <planetsizecpu (Jose Luis)>:
Cool @toomasv  Ì†ΩÌ±å

## 8-Jan-2021

[23:39:16](#QoKCWCT4GceEZJRdQjk7l9mxRDWS6vJQ2B3Md9go5_A) <gltewalt (The other Greg)>:
Docs converted to html via asciidoctor look ok on the rendered side. Source is ugly.

[23:39:36](#59roYiMtwjsMC9d2kkRNKtdS49EWlpDymPbFAtQ_DIY) <gltewalt (The other Greg)>:
Docs converted to html via asciidoctor look ok on the rendered side. Source is ugly.

[23:42:59](#_2oCJoiAgeZXHoj7_-WcRYJYADm1vy7cDoqwHtTeS-M) <gltewalt (Greg T)>:
Docs converted to html via asciidoctor look ok on the rendered side. Source is ugly.

[23:51:09](#gG_U49d-s3M-bYWnnnHgrVikJ4UFuMpoWPLljTEzc5I) <gltewalt (Greg T)>:
Docs converted to html via asciidoctor look ok on the rendered side. Source is ugly.

## 29-Jan-2021

[3:51:44](#O_Z5AMog99uejnpNgKh9YP0xobP3lKGW7pBdGGmbbK8) <gltewalt (Greg T)>:
Docs converted to html via asciidoctor look ok on the rendered side. Source is ugly.

## 23-Feb-2021

[0:11:51](#zS9fQhX1cjJoMA6ZslMUEe-vKVVmaSOul2dlRN6wMcM) <gltewalt (Greg T)>:
Vscode to gist pasting is giving me issues? Anyone else have this problem?


[0:13:11](#mB56jZZFgKXDd0UVjNOWXg0iu__l_3rNJzI_lErRF9I) <gltewalt (Greg T)>:
Been slowly building this small experiment:

https://gist.github.com/gltewalt/d3c2afc8ab011a09fc4ce62f409f5730

[2:53:43](#m8M4wMpv3-gB-Ih6VhlryYjjVYwh4w66Uru8IhX4fDk) <greggirwin (Gregg Irwin)>:
Nice work @gltewalt !

[2:55:49](#U1BHS74l6t9XHaLpCXIbNOQtzrY7eIvoOW6SKzz_KPs) <greggirwin (Gregg Irwin)>:
Nice experiment too. The output fields get cut off vertically for me, but I eventually got a green light. 

[2:56:11](#N5VUQctvHndXwKZB3A600ytBYf-5zy_dva7exOyvO9E) <greggirwin (Gregg Irwin)>:
[![image.png](https://files.gitter.im/57f22e43d73408ce4f2b38c1/aUiL/thumb/image.png)](https://files.gitter.im/57f22e43d73408ce4f2b38c1/aUiL/image.png)

[2:56:29](#czjNEVm-M20J7ZgyGjF-Nc7Kock7omjA3fYgaGth-AM) <gltewalt (Greg T)>:
I edited it a bit.  It's still shaky, but little by little, I suppose

[2:57:17](#6_gbIZBxnYMWxGbUIywTMcSeBJNtu8r2uOOVfbjQy-U) <greggirwin (Gregg Irwin)>:
That's how work gets done. Coincidentally, I'm working on something (very) vaguely similar. At least it has `input` and `rule` aspects. 

[2:57:19](#8JVzHu0U6Mn6nCsoJWMhaZ_z-atrVaqA5XigCoJKzjI) <gltewalt (Greg T)>:
The output, or results, can be fixed up to something much better than `text`. 

[2:57:47](#ktQZ5B323UVpPMWinrhnX5U0y93B0lfy-gFyShOkLt0) <greggirwin (Gregg Irwin)>:
It's a good example of live coding.

[2:58:54](#Eg8gZ-txW9Zq2UCD_9c7qRxRIaUJA26o1k_wrE0mEiY) <gltewalt (Greg T)>:
And I should? probably use react eventually.  I have to start crude and basic and chip away - more like sculpting than designing I guess

[3:00:15](#wD1h9fyu6NPopp4aGCOkxpyUyKDfKJSAfNzfWhJCg6o) <gltewalt (Greg T)>:
The index is interesting to me - showing the index of the next section to match. And `to`, `thru` are returning the same index

[3:00:51](#TLnejajRyn4lNFUhft_AF0I8hhOJaH8kktrNgAZuztM) <gltewalt (Greg T)>:
Yeah, if you'd release your expirement, everyone would be happy and good to go. (I still like to tinker though)

[3:07:06](#kPgyaOjAaNkKATmsf7K80RQibZSXVNF7ob_1QpFfeOk) <greggirwin (Gregg Irwin)>:
Mine isn't for `parse`, so doesn't overlap there. Still some things to work out for it. I chip away as well. Took me a while just to decide what to try, and now I'm on try number 3. 

[3:07:22](#PW4ug4yfrpFtvbrLZ1RRk3VzXqWa__Jx4P5q51hwwYE) <greggirwin (Gregg Irwin)>:
That is, how to present what I want to present.

[3:08:11](#AKET2fE9zUdTg0byhDE2AeU9j7kc89yskqvehn07UJ8) <gltewalt (The other Greg)>:
3rd try is the charm?

[3:08:57](#NpiLLIH0d4YibZPG6FTl8L2ZhjRf52p_pGDg7KSutI4) <greggirwin (Gregg Irwin)>:
We'll see. I'm sure others will judge and provide feedback.

[3:11:27](#8I7sif9qxZIoevhsRbQdFBJOONHk2ZmI9BJu5ZAUNG8) <gltewalt (The other Greg)>:
Do we get a hint?

[3:13:23](#jIL-lszoR_Ov5tyru9xzOyopfWzqPk7njqA6U5Xx_b0) <greggirwin (Gregg Irwin)>:
Have I *whetted* your appetite? You know what a *cut up* I am.

[3:14:20](#lwgc3Y34I5X0clqLkaZz9Yp6tT3gEvQLa7BlXa-V_QM) <gltewalt (The other Greg)>:
Hmmm

[3:18:43](#moyA4WQbM4Y83-dxeH8MRtGdXA6a4mGoAYXZsmuIWQY) <gltewalt (The other Greg)>:
linter?  

[3:19:31](#008-CgT7Jcle5qSelc53-kpxlW3EPP-WCU3kyBRW-3E) <gltewalt (The other Greg)>:
wet is the opposite of DRY

[3:21:40](#elOD8gJqOCRTsJXT-wDGHAGTJmk4qWete9p93RcPKRE) <greggirwin (Gregg Irwin)>:
But *whet* isn't the same as *wet*.

[3:22:21](#KpVzp5TlbVFKNJhrURYJKgUGqwEvVd31PD-3zKkN6X0) <greggirwin (Gregg Irwin)>:
And I do have a habit of repeating myself. There is a repeating aspect to this.

[3:26:01](#8wkZnUskjq29B06x0MWrVcg-ny3bAOz0X9I0QNwPOP8) <greggirwin (Gregg Irwin)>:
* And I do have a habit of *repeating* myself.

[3:36:28](#WJsSo_m5N_qoIu9-9gFge90Sgrcjjnj0Hm1l7WH8x1w) <gltewalt (The other Greg)>:
Sharpening something 

[3:37:19](#NVfRtObvVi7KqEvbRdMhwbLE3tMKQu8ho-L5L7rDVp4) <gltewalt (The other Greg)>:
Cut/Paste..

[3:37:27](#NX_hvGhIkHu5Gngp70nbYnnkKFRt31Yg8CXZXYHRhSE) <gltewalt (The other Greg)>:
Editor?

[3:37:53](#hRcsaRYELjeFH_9VepQ6e3mYgvo_1fhFtji6w6Pcm0M) <greggirwin (Gregg Irwin)>:
Warmer, then colder. But I've said too much already. ;^)

[4:54:53](#Coc7vpb3xG5xTEXjWxnWU3OlZZs91ptZ0FCgWySINBo) <zentrog>:
I‚Äôm thinking ‚Äòsplit‚Äô?

[6:38:14](#Rj3X17WmitHfMJ06unHvv6kedE5CpuIZAbcYKn0urio) <greggirwin (Gregg Irwin)>:
Well, now the pressure is on. ;^)

[6:39:31](#ciWdjekxJNzgcM2oKnvgVSKMCugNwKDnRaB68BMIf7g) <rebolek (Boleslav B≈ôezovsk√Ω)>:
@gltewalt:matrix.org 
> Vscode to gist pasting is giving me issues? Anyone else have this problem?

You can upload to Gist directly from Red console with GitHub API.

[7:03:27](#v32Y8LkMLLtGrtRLcLptEtU6reFeF1M9g8NA7XI7vEs) <GiuseppeChillemi (GiuseppeChillemi)>:
@rebolek how?

[7:15:10](#3l4uMJknEfFIR31h02T1mh53ZR2V5jANXNEsMl9l3wI) <zentrog>:
Ì†ΩÌ∏ÑÌ†ΩÌ¥™

[7:50:55](#IMCmMyCp-0VPrc9eN0eG6NruV883gsB2tdQenVWSBiY) <rebolek (Boleslav B≈ôezovsk√Ω)>:
@GiuseppeChillemi It seems that Github finally killed basic authentication so I need to update Github API to use tokens. So sorry, it‚Äôs currently not possible Ì†ΩÌ∏É

[10:05:40](#_fFp4I3k-TdL7FjMFSXcHt6ZfEqxe6LDJoLMUaEs9S4) <GiuseppeChillemi (GiuseppeChillemi)>:
Remember I cannot use networking because of https://github.com/red/red/issues/4791

[10:05:52](#71vb-2_8IdTpmI_2LUglPlDVhOcVn2HN56merf6tdOA) <GiuseppeChillemi (GiuseppeChillemi)>:
* Please, remember I cannot use networking because of https://github.com/red/red/issues/4791

[11:50:24](#q2R-eHcCWLXYrgxETAr-B-QQd3GzS7QCA528hrZ0TYs) <hiiamboris (NOT THIS ONE)>:
@rebolek Gitlab gives me this error lately and asks for a password every time:
```
Unhandled Exception: System.TypeLoadException: Method 'ConfigureAsync' in type 'Microsoft.AzureRepos.AzureReposHostProvider' from assembly 'Microsoft.AzureRepos, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null' does not have an implementation.
   at Microsoft.Git.CredentialManager.Program.Main(String[] args)
```
Tried google-fu, but to no avail. Maybe you have any idea?

[15:11:23](#sQAWWMkRsBdVpFzTPxGgZY-iLwGozVz7t5S702QZFWY) <rebolek (Boleslav B≈ôezovsk√Ω)>:
@hiiamboris Gitlab or Github?

[15:12:42](#UEzCWWr1QGbscD_bTBVS2lzLj2v3xFR7Eg7J2um7sEQ) <hiiamboris (NOT THIS ONE)>:
Gitlab!

[15:13:36](#_Y_Q5GPhhaYO-ePqw6NIJpP7Txtc37ef-ctXF1354PI) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I was confused by the Microsoft mentions :)

[15:13:53](#0i3oa483S2e9wALhW_LEQ-MUoM6Z0otyZiZaXWNesik) <hiiamboris (NOT THIS ONE)>:
Yeah looks like they host on Azure Ì†ΩÌ∏â

[15:14:13](#YL1y1T-C9p25UyWz2YfgosaVModJX9c71XePnP4wkUw) <rebolek (Boleslav B≈ôezovsk√Ω)>:
However I still have Gitlab only in queue and haven‚Äôt tried doing their API yet, so sorry, I‚Äôm not sure.

[17:21:16](#LZcKG5YhcdL1jlmm9x1iLTDVlEON2SoNRjIBij1I0lI) <gltewalt (Greg T)>:
Why do people use gitlab?

[17:22:33](#8EYEkhDbFjwDE0Jsmgo0wVG_YuXqH7ZQC-RGcEvDTKM) <rebolek (Boleslav B≈ôezovsk√Ω)>:
Gitlab has (had? maybe Github offers then also now) some better free plans, you can install it locally and it isn‚Äôt owned by Microsoft :-)

[17:25:01](#7xL2M2ZqZDmSLqWpe35bXLI-l3Dpobl_-mRUQNYa31o) <hiiamboris (NOT THIS ONE)>:
Gitlab does not try to force their audience to switch to Chredge browser, for one.

[17:25:28](#GzYqhlv0cTuis2zeq9GEEydX79uGLqPn12oGN1VMeTc) <gltewalt (The other Greg)>:
Never noticed

## 26-Feb-2021

[18:35:17](#JeHgNXa3L_6j__sztaXX85PzFNrk3QNJ575ThDVTjqg) <gltewalt (Greg T)>:
https://github.com/gltewalt/tppt

[18:36:25](#C2hwfpYKEKI-RENcS5FXc0avE3M0P_NvQfK-D9ZHE_U) <gltewalt (Greg T)>:
I know... pink is probably not the coolest, but it was easy on my eyeballs.
If you feel like hammering on the script, I'd be happy to hear suggestions.
Binaries in the bin folder if you're trusting.

[18:39:33](#6JqIngDrvUG7TQtom2OjXj7UPs2nMy0u4pwWW7Ev3SY) <hiiamboris (NOT THIS ONE)>:
Uh.. Pink Parse Panther

[18:42:24](#PYubMU8DNWAwfuctCLuXt1DnlrdXfjSKtmKJ4w1iGC0) <gltewalt (Greg T)>:
If I use Panther... legal troubles?

[18:42:53](#y2Mw4vvhKAfLvzpKdaTmfCXHssXn-1m87KpyXYiJ6Sw) <gltewalt (Greg T)>:
Chances are low, but I have good luck

[18:42:53](#T_IXlblLkhA1cGLvafDlZ4uwhthbvhmIlmPwElkdzw8) <hiiamboris (NOT THIS ONE)>:
Probablly Ì†ΩÌ∏â

[18:42:56](#kFFgYHkO3brYLyn5Bw8CLoYrfqqHZarQ5Yu00YpoIc8) <hiiamboris (NOT THIS ONE)>:
* Probably ;)

[18:44:59](#_U91YxSTWAzX9N5ou_P8zlpD5VLw7OZDBo3qOjYXDKw) <gltewalt (Greg T)>:
Couple things I need to look up. How to keep console from running when I use the compiled version.  Keep all the error messages from filling up console if in interpreted mode. (It reports a bunch because it's constantly checking the parse rul as you type)

[18:45:21](#Gd3iSXuOYZRfdRd_5B6YHI7_X4b-CbBANgzOlUJ6-EM) <hiiamboris (NOT THIS ONE)>:
![](https://i.gyazo.com/47258633822fb6e1360d93f4a9b461c6.png)
I had to use parens for init code

[18:45:49](#pm7EPlvxch9w26Zo9yBkuDDa5A4rRRUJ3LOTpU1sVoY) <gltewalt (Greg T)>:
![](https://i.gyazo.com/47258633822fb6e1360d93f4a9b461c6.png)
I had to use parens for init code

[18:48:43](#dYSmeftXb1c620kVr4MRktSaT5Bbf9s3agAfBUo4zh0) <gltewalt (Greg T)>:
Yep, looks like it

[18:53:39](#kir86Te7_45ChXmTtBaUrx-ylZtKQAsYjp6yclanouc) <gltewalt (Greg T)>:
`c: (charset " abcd") some c`

[18:53:46](#mgSTuAq6hkLX6q3O9SOF4j558HBXA4FsOGQjxP51vuY) <gltewalt (Greg T)>:
should work

[18:53:53](#NFtXUYeW-Z1n7WbZX1CYqMf0ySuKMQ2hRjyZWlBcv9s) <gltewalt (Greg T)>:
same as my console

[18:56:22](#x_xb9Xp4YWQTM5IyR92nYoKIyGhI4ECN43zByLekLes) <gltewalt (Greg T)>:
You're using GUI console for win?  Button looks wonky in your pic

[19:08:35](#QXfX84UmPaBmsz8ZmYGxZTiWw4YBlh0iN2Ty45pIgqI) <hiiamboris (NOT THIS ONE)>:
W10 yes

## 28-Feb-2021

[20:15:09](#OBQXgPXtP-LPbLCTIrUJ076IVYiU7LRMKkf7cdWfTG0) <gltewalt (Greg T)>:
Revamp

[20:15:11](#zvfVfGVP6I2naC5DV3qc-uDspND6HbIeFKL-08U5gnY) <gltewalt (Greg T)>:
https://imgur.com/a/zaQ4uJt

[21:40:23](#NAGSzR-OyfAhVRbiocb99GsjeAzisx_jGGbCgM58zAI) <gltewalt (Greg T)>:
https://github.com/gltewalt/parse-caddy

[23:33:37](#00_AM4Zh9tIxjLiBS-qXB3mNiqTLRa8dov1qM6-aqZU) <gltewalt (Greg T)>:
Updated to make Windows happy, and a boris line

## 6-Mar-2021

[3:50:23](#nGmcVIeJuQUVa7CD9fcKAczV5x6qlSVGzjYKZolV3To) <gltewalt (Greg T)>:
@greggirwin When is your similar thing coming out?

[4:05:49](#LO7Waa0QSn2VSZZp0_YgOHTh1qLFOhXQTjVWBd_j8uA) <greggirwin (Gregg Irwin)>:
I wish I could say. A good foundation is in place, but progress is slow because I can't shut the rest of the world off. 

[4:55:38](#Va_65Ni1O8yq_XrOnwKs_xndDUC8DeE9Cf2E2o7QlT4) <gltewalt (Greg T)>:
24 hours?

[16:05:48](#8cwW8OpzqINLqzY_6CRb_HvMzffqoEBemwaspHInY-4) <greggirwin (Gregg Irwin)>:
Maybe next week.

[21:42:31](#gaEYmXGfXjq9S-jvomg93FXzRNyp5p-ofATTp2lzOYg) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
I was playing with icon file on Windows 10 and found interesting thing... even when I have icon which has sizes 16, 24, 32, 48 and 128 pixels (each image with number, so I can see, which one is used), Windows is everywhere using just scaled version with size 48.

[21:43:42](#TqHaniJ9eD3O7PFf4ApHwlHerQXK1xj9hij2t65Nhvc) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
And it does not matter if I have system with scaling 100, 150 or 200%

[21:47:50](#jlZzMpPkzpz_qoHM-H9mhqpEArKHK3uL6-j3Yx-ywTw) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
Ah.. I found used version 24 in file explorer in list view

[21:51:16](#NpZ-bhsIcXi7BFQETAC3HqVdF1-z7FRUVgzd2SRxHIQ) <greggirwin (Gregg Irwin)>:
Interesting. That may be related to why UPXd exes have trouble with the desktop icon for shortcuts.

[21:51:44](#FyB_DvBa9jwmKCsgHUqe7KYUqSsuRir8BlY5AqnDMBU) <greggirwin (Gregg Irwin)>:
I wonder where the higher res versions are used.

[21:53:02](#Wz_hZPabnsiakywJdvmgmINi8eB4e7u2zd3MhAZ04Is) <greggirwin (Gregg Irwin)>:
I found that 128x128 caused the ICO size to balloon but 256x256 and 512x512 didn't. At least with the icon editor I use (Axialis IconWorkshop).

[22:19:39](#XVD8O1EXntvqS9re8fy-rqCTakGDoLukVxfWmdUXvXA) <hiiamboris (NOT THIS ONE)>:
According to Reshacker you're using PNG only for 256 and 512. Any reason?

[22:19:53](#vzZ6K_VDSyA6uLP-A9SpXDc6ZXVc_V8ir48U4BGD5uE) <hiiamboris (NOT THIS ONE)>:
It's not that we wanna stay win98-compatible here.

[22:20:46](#-vduv-OKPQZ3L2OK3-zoLP_1-Kc8yz98dJdv5ahEWgM) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
Size 512 is only for Microsoft store

[22:21:52](#yL8yU7kZEYC6w2z_rtqY1yh6MZ-PAEhXO6EOdubGDTs) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
never mind... now I have icon with sizes 16, 20, 24, 30, 32, 36, 40, 48, 60, 64, 72, 80, 96, 128 and 256, but still see used only 24 and 48... maybe it's in some cacheÌ†ΩÌ∏ï

[22:22:21](#vicClGi5OtD4PbKolgxdAH1IXQ04Svr0a2wmtz4HwFs) <greggirwin (Gregg Irwin)>:
@hiiamboris I'd have to see what the icon app controls are for those options. 

[22:22:40](#1sHbMvsFfK4eXL9TJY2DFVCLECWkmEys5UxwC2eu6qU) <hiiamboris (NOT THIS ONE)>:
maybe explorer limits the size to limit the size of the icon cache, @Oldes ? 

[22:23:09](#qB6ug3jjIkGYd-SYqJVcoO5_tZKxEYU-4hryxCk6rOI) <greggirwin (Gregg Irwin)>:
Thanks @Oldes. They didn't add much size, so I thought they *must* be used for something to make it look better. :^\

[22:25:28](#xRmmloPbXpaZPt8yqN3ujO-dW_BobM6BuJJlFPHg2vI) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
I should also use icon version made from BMP images, and not PNGs as I have now.. will check later, if the cache will be updated with reboot

[22:30:37](#WEhmQ8L7aPZ1o709mWEB2tY7SggdIJ5uz0To7sn0B5s) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
Hm... now I see version 256 as a extra large icons view... even without reboot

[22:31:06](#iCpCIBcEOW_edYJAlcnsqgBDG6G3uGt4GWH54n7qBkE) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
* Hm... now I see version 256 as a extra large icons view... even without reboot, and 72 in Tiles view

[22:32:38](#_NJVtkN53pBJCLSRrkaTzRFoTV9jCyEKDMybPLK2dJQ) <hiiamboris (NOT THIS ONE)>:
I think you have to nuke the cache to update it

[22:32:39](#1b3dAQhhYfEtkJPbMrRLJK6jmGWGn4YGHPRDWaEFBFI) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
so... so far I've seen used only sizes 24, 48, 72 and 256

[22:37:35](#2OQq35Jtj8_7bBAaW4GEi6h7254No4_HCrI6PnuYhtY) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
and now I see also 32 when I have 100% resolution (very tiny everything on my display)

[22:49:09](#T3TiNG_gH6lYOQg2tvu63-UZZivI5yQ-1sYTZo2vLXk) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
ok.. and version 16 seems to be used in Window title now... :) interesting experiment.. will keep the testing icon for a while to see where is used what:)

[22:49:47](#pEtvzlsRhKXIe4XCmIu0gr52Zl4H-RWnzVJof71kMu0) <greggirwin (Gregg Irwin)>:
Thanks @Oldes. Good info. Sounds like many of them will be used, maybe given enough different environments.

[22:50:39](#dXGQQyPX7k9IwLP_5fUSsAk06EXt0h1TwFskfdcpWyY) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
It's new for me, how important is the size 72.. I can see it quite a lot in many resolutions.

[22:51:31](#sssFJ4BOnxFOoWTHLbvKzS_PONIj-aSRwZ7SAGhe57c) <Oldes (@oldes-556aec4015522ed4b3e131da:gitter.im)>:
And it looks that Windows must have many different icon caches... because it is changing quite unexpectedly :)

[22:56:19](#sS-KXoDzNvzQjM1zgLkmZA-7QkUT5JYo4sGvSojlGG8) <greggirwin (Gregg Irwin)>:
Somehow I'm not surprised.

## 10-Mar-2021

[2:36:16](#tq0i6Bop0xneJivcHlnLq6H-rCpPY0kH2f8GTjIpSMs) <gltewalt (Greg T)>:
Bug...

[2:37:09](#JtRP54T1HXiW2jRNynB04cRVK92QRnAMH-tQKof1gAY) <gltewalt (Greg T)>:
It grabs the word `i` which points to a field.  It will grab other words.
hmmm

[2:37:10](#zEY7kKoImy9kCWj3BWK91GbgDzmedBDvpsRu1YxDMME) <gltewalt (Greg T)>:
https://imgur.com/a/UeciJPa

[2:54:56](#DWal2-vhLmqjkSTzbMT542qiwCDcfq7AKZPMXRfWBkg) <gltewalt (Greg T)>:
compose/deep?

[3:09:53](#6Zz_-qV2bDyqXnV0O1io3_dngPyJerC_ByfzwV1FR6w) <ne1uno (ne1uno)>:
that is useful, can load words in rule tab. probably should rename simple words in use by the script.

[3:52:31](#9aB3qN0qByS3dRsTXcT2WARF6f-pgbg20TcVIi4sydo) <gltewalt (Greg T)>:
Yeah, renaming simple words is kind of a way, but no guarantee that non-simple words won't be typed in by a user

[3:54:20](#LPS_lG_ffAqyWgBOpMoifq0zcsbhG4jWwtB5B7SqeoU) <gltewalt (Greg T)>:
The only other thing I can think of is some kind of `protect` function that would do nothing if one of the protected words was typed in after `insert` or `change`

[4:42:40](#hwLKdxWD5KP5bNjFqAxzn9DrMLhalAw5cpSbog-0msA) <gltewalt (Greg T)>:
Grabs Red words, too.  `insert ask` will put `?function?` in the input field

[4:46:44](#wQLVcbrwSS3jpDL5OMN8oZ3FSdcf5EekGvejJtiaNHo) <gltewalt (Greg T)>:
But that's parse/trace, or parse-trace
```
>> parse-trace [one] [thru word! copy x insert input]
 -->
   match: [thru word! copy x insert input] 
   input: [one]   
   -->
     ==> matched
   <--
   match: [copy x insert input] 
   input: []   
   -->
   <--
 <--
return: true
== true
>> x
== [func ["Wait for console user input"][ask ""]]
```

[4:51:27](#NGtJL1Adi0QJs3u6uEfC0bMN0HNYXNqRr94p8yMr0fU) <gltewalt (Greg T)>:
Seems like I didn't have these issues earlier on. Oh well...

[5:52:31](#PeSqPbKuCFQXdqRZIxuJvz4hp-UjNiwNtDn2NwR0A1A) <gltewalt (Greg T)>:
Ì†ΩÌ∞± 

[8:24:34](#0gyG-gQUuWA1tUTGWogUKc-GBdLOkq81s6lTOOdnQ_I) <toomasv>:
```
x: func ["Wait for console user input"][ask ""]
parse input: [one] [thru word! (answer: x) insert (answer)] input
```

[8:40:23](#DnjbNTvF1OnjxAi5vBg9nqfMYHCHkZ7TWMN5zZVC788) <toomasv>:
Ah, better just
```
parse input: [one] [thru word! insert (x)] input
```

## 16-Mar-2021

[0:19:07](#bfNUaMMr4Nk2eS4itO_cpGHUe_LA0fVdTzeU8aoTHsI) <gltewalt (Greg T)>:
@greggirwin How do you do a Change Log, like you did for Diagrammar?

[0:38:04](#yXoVz3UKD9I9mr0mHK-ER65c2Eo28-0a-NfxTf8Z2Cg) <greggirwin (Gregg Irwin)>:
I make @toomasv do it. :^)  It's a manual process, because we obviously don't want every commit to be in there.

[1:24:17](#JPHGxFs3ZYpXsjATCnW4m1CX_zygDT3mUr_14XfYM24) <gltewalt (Greg T)>:
Oh, manually slogging through

[1:39:24](#p10ZkzolAEAMivdxqotcmh79rZFOVL_fT_7Bn3HUKpI) <gltewalt (Greg T)>:
make a tool :-)

[1:47:00](#Q8ftGF6gkpFoGJFUZCZHmMoHOuH-XAq3Ox1gX0SBG_c) <greggirwin (Gregg Irwin)>:
Of course, but then we have to figure out how it should work. :^)

## 29-Mar-2021

[2:28:42](#47KMcS8N5WwgtxnvldHCYFjiMTYlbYDFFAyUY4xrDuc) <gltewalt (Greg T)>:
What do you think about 'predicate' functions?

[2:28:58](#fUtR8-cfol2J6ZBGAt0qBw6Nl_IK55UeogvjlTZJcD8) <gltewalt (Greg T)>:
```
true?: function [
	"Returns true if the value is not false or none"
	value [any-type!]
][
	either :value [true][false]
]

false?: function [
	"Returns false if the value is false or none"
	value [any-type!]
][
	either not :value [true][false]
]
```

[2:44:26](#yT7_s53qyO1jAKzneK9gCJX_O6SmlcJJ03EJWLG7iOU) <greggirwin (Gregg Irwin)>:
They come up from time to time, but are a tough sell. First, it hides the detail of what truthy values are a bit. More importantly, those words are only 2 of the names for logic that we use in Red. Should they get special treatment, or do we have `[true? false? on? off? yes? no?]` for consistency? What we need are some examples where we all agree they make things clearer, but I don't think that's happened in the past. Subjectivity rules. :^)

Here's how R2 does it:
```
true?: func [
    {Returns true if an expression can be used as true.} 
    value [any-type!]
][
    not not :value
]
```

[2:46:37](#2dmt4XCFKW-SdOR6IQjAQEnNFdN5UxVsfMXwcbQiOrg) <9214 (Vladimir Vasilyev)>:
@gltewalt, `true?: :to-logic`, `false?: :not`.

[2:46:44](#-8FoRdhGNZWhUSAn5_hYXvZp8USR0afS_gCA63pT_Fs) <gltewalt (Greg T)>:
Could possibly build them all automagically. Nenad does something like it (building funcs) somewhere in the source - that I looked at in the past

[2:47:22](#zePV8t15Pcp_fiHLO6tmwKsRh7ULnKygoZNxYK8pLYc) <gltewalt (Greg T)>:
There we go, even simpler

[2:51:58](#uQyYPgDihNS5OWVb7hwZcg-z6Ga7vXNukS6dFRqHNCw) <greggirwin (Gregg Irwin)>:
Oh man, very nice @9214.

[2:52:41](#Wo10O1T2TTd9tP785nqD25YPYk_i7FDw1eLnAsabA-A) <greggirwin (Gregg Irwin)>:
The point is not that they're hard to build. On the contrary, they're so easy that what's the point? :^) The question is whether they add value. 

[2:53:42](#Kpr0um3XcbytM2YpB98-gtZ2jERt9nVUdGKhOwmxCTk) <gltewalt (Greg T)>:
The same point as `url?`. That's also easy to check without `url?`

[2:54:10](#zrf9j8YA3V3AwxmuY1rzQE8l6E7uu2h2Ow6VcVbSQYg) <greggirwin (Gregg Irwin)>:
One catch with the quick alias approach is that you can't use them with `unset!`. 

[2:54:34](#Zhm09Y61NDBR6A2GiBmUmw390G4C_IDO4_SeBQlkvAI) <gltewalt (Greg T)>:
Good, I hate unset!

[2:55:58](#HJrLU7RsskKZVB0Eh2fE48jBYYq2_skupCLGhXqs3wM) <greggirwin (Gregg Irwin)>:
Totally different than type checking IMO @gltewalt. It's more like `one? two? three? ...`. But what you need to do is make the case for them; show their value.

[2:56:07](#bKwGi32xcoqIwQfyqEkHTkyRXUsTt7RaIhJ090dnim4) <gltewalt (Greg T)>:
well, hate is a strong word, and they say it's bad for the health

[2:56:39](#lngc1iwZNnmjH0uy-FBFbznkviF3Qz0MjqrK033iHvE) <gltewalt (Greg T)>:
Personal value is that it reads 'better'.

[2:59:43](#TYtcuZhtL8gjx0X4M4pCd3umAbpqIPrCloZtvDSwQE4) <gltewalt (Greg T)>:
I couldn't say what the value would be, objectively, to Red users

[3:00:34](#sg6IVMx_80jVFvW3fnL30nE-WpqFbEsmnMj6k8Ok-Qk) <gltewalt (Greg T)>:
Good to see you around @9214 

[3:01:07](#49bAqTvIVa0fq9t8jhSUEMT_TEmhoSkPW0lamyX6GnU) <9214 (Vladimir Vasilyev)>:
Gee, thanks @gltewalt!

[3:02:29](#aqsGJfwVI1kyeVlTwj856SYDZ_IxYTdmioLUjHFGvn0) <greggirwin (Gregg Irwin)>:
I was going to say that too but, as usual, he keeps beating me both in time and with better answers. <grrrr>. ;^)

## 30-Apr-2021

[18:07:48](#od1jWEKONem_sWnUd9BHirYHuJfbi8NBowQYAiB2jYg) <hiiamboris (NOT THIS ONE)>:
Runtime profiling of code scattered anywhere across the project:
![](https://i.gyazo.com/70605ed966ab4f5ddb72019b5b80c0f7.gif)

[18:08:43](#eOKZZAumotBFRKq0p6vpZE-uqvQ3vHhIf06dFpSrHcI) <hiiamboris (NOT THIS ONE)>:
* Runtime [profiling](https://gitlab.com/hiiamboris/red-mezz-warehouse/-/raw/master/profiling.red) of code scattered anywhere across the project:
![](https://i.gyazo.com/70605ed966ab4f5ddb72019b5b80c0f7.gif)

[19:29:26](#II6iQJV8BaKsnHdOsJ-0joG5BfMxRIN8aebIHHIbL1Q) <toomasv>:
Amazing! Ì†ΩÌ±è 

[20:13:48](#hqfN5wyYp00LOjkDKPey1V-z9olznG9EKFB6uMHZJK4) <pekr (Petr Krenzelok)>:
Looks good :-)

[22:30:18](#fLjAxtv_Ljq_nb0pU1x6sXLaZ_JyXvORardxHNyYnlQ) <greggirwin (Gregg Irwin)>:
:+1:

[23:04:18](#5ZbPVWtcWkTUKxAbiGaZaxvJ9618UBZRSVBZgi8nHyI) <GiuseppeChillemi (GiuseppeChillemi)>:
Great!

## 5-May-2021

[19:43:43](#jY3O0S39n99p3cG6lqLh1EHK7RKBV0UU-XJy4QdSOlo) <planetsizecpu (Jose Luis)>:
Good job!

## 15-May-2021

[1:40:56](#IOzQbuQ3Lg82C2SSZJoJTSc3RBzLW0tW6M2rKxWe3f8) <TimeSlip (James_Nak)>:
@hiiamboris  Nice work on red-spaces. 

[1:41:59](#ho0pIW5bhFI363vzjdWug-Wu9gg6oNS4I7O9xJ1roPI) <TimeSlip (James_Nak)>:
@pekr Thank you for posting that announcement on FB. 

[3:08:23](#FVcgTkQh5O6tXvuXd_twSQarai4LZ9VeRqIoRhNXm_g) <greggirwin (Gregg Irwin)>:
Yes, thanks @pekr !

## 20-May-2021

[11:57:28](#GvOuZsFWpaZlBYAkYA9AVFkUDXkiX-MxQ4Yldq0F_QM) <rebolek (Boleslav B≈ôezovsk√Ω)>:
@GiuseppeChillemi I believe this may be interesting to you:
```
>> do %mysql-client.red
#{85A6EF01}
== [
    print "mysql client"
    client: open tcp://192.168.45.162:3306
>> do start
mysql client
epoll_ctl fd: 6 op: 1 evts: -2147483644
events: 1 1
val: 0
=== Client event: connect
connect
socket/recv -1 state: 1028
epoll_ctl fd: 6 op: 3 evts: -2147483643
events: 1 1
events: 1 1
read-io in wait fd: 00000006
read-io in wait: 93
=== Client event: read
read
"client read done"
#{
590000000A352E352E352D31302E322E33312D4D61726961444200AC2F01004F
40327B3534454000FEF72D0200BF8115000000000000070000004E485F263D41
6E277331375F006D7973716C5F6E61746976655F70617373776F726400
}
---
Y....5.5.5-10.2.31-MariaDB.¬¨/..O@2{54E@.√æ√∑-..¬ø¬Å...........NH_&=An's17_.mysql_native_password.
---
FLAGS: #{7261332E}
FLAGS: #{81BFF7FE}
make object! [
    length: 89
    seq-id: 0
    type: 'handshake
    payload: make object! [
        server-version: "5.5.5-10.2.31-MariaDB"
        version: 10
        thread-id: 77740
        auth-plugin-data: "O@2{54E@NH_&=An's17_"
        capability-flags: [
            found-rows
            long-flag
            connect-with-db
            no-schema
            compress
            odbc
            local-files
            ignore-space
            protocol-41
            interactive
            ignore-sigpipe
            transactions
            reserved
            reserved2
            multi-statements
            multi-results
            ps-multi-results
            plugin-auth
            connect-attrs
            plugin-auth-lenenc-client-data
            session-track
            deprecate-eof
            remember-options
        ]
        character-set: #{2D}
        status-flags: #{0200}
        auth-plugin-name: "mysql_native_password"
    ]
]
--write--
#{
5000000185A6EF01FFFF00002D00000000000000000000000000000000000000
00000000726F6F740014F9D395DFB289EB584C1217F0C08CEF0400DADDF56D79
73716C5F6E61746976655F70617373776F726400
}
6 00000405 84
iocp/post: 4
queue/push: 1
insert#1
events: 1 1
queue/take: 0
=== Client event: wrote
wrote
socket/recv -1 state: 1029
events: 1 1
read-io in wait fd: 00000006
read-io in wait: 11
=== Client event: read
read
"client read done"
#{0700000200000002000000}
---
...........
---
make object! [
    length: 7
    seq-id: 2
    type: 'ok
    payload: make object! [
        affected-rows: #{}
        last-insert-id: #{}
        status-flags: [
            status-autocommit
        ]
        warnings: 0
        info: none
        session-state-info: none
    ]
]
```

[12:39:28](#YAHz3of2d-gO7vbw0xfSOwqCuScgGxJ8WJujsp7sXbw) <GiuseppeChillemi (GiuseppeChillemi)>:
@rebolek Would you marry me?

[12:51:52](#9I9lQLf3W3h5pRZ6KeWmIFwyQm85CjMMMmay-mqkVBY) <rebolek (Boleslav B≈ôezovsk√Ω)>:
No, I‚Äôm happy with my wife :)

[12:52:03](#m44-fanUEogC_ga_FoUYdl2sHLZe_76hNm2_xGCA-_M) <rebolek (Boleslav B≈ôezovsk√Ω)>:
now with prompt! 

[12:52:08](#mIypmgcjaHzxsIO1fFEPuLML2ZGvYlkABd23KO-0FJE) <rebolek (Boleslav B≈ôezovsk√Ω)>:
```
mysql> ping
#{010000000E}
6 00000405 5
iocp/post: 4
queue/push: 1
events: 1 1
queue/take: 0
=== Client event: wrote
wrote
socket/recv -1 state: 1029
events: 1 1
read-io in wait fd: 00000006
read-io in wait: 11
=== Client event: read
read
"client read done"
#{0700000100000002000000}
---
...........
---
make object! [
    length: 7
    seq-id: 1
    type: 'ok
    payload: make object! [
        affected-rows: #{}
        last-insert-id: #{}
        status-flags: [
            status-autocommit
        ]
        warnings: 0
        info: none
        session-state-info: none
    ]
]
epoll_ctl fd: 6 op: 2 evts: 1029

*** Runtime Error 1: access violation
*** at: 080D7AE7h


```

[12:57:47](#Z3ZcBrW7wIO_y410ar82mN3xHTMZZXiwuh3l-RCTSWA) <hiiamboris (NOT THIS ONE)>:
epic ending :)

[12:59:33](#U5AzAtFgkTd1J55EBD7rZtfDltltbdCOl7-Gijg-1a8) <GiuseppeChillemi (GiuseppeChillemi)>:
I am currently working on SQL-Server via munge, and I am building some high liever objects to work with different DBs using a coherent interface. You work and mine will soon converge.

[12:59:45](#sUCS9mfor76sPCgWxTeS5ONLlShX9ZBmGpM2iQRB56o) <GiuseppeChillemi (GiuseppeChillemi)>:
* I am currently working on SQL-Server via munge, and I am building some high level objects to work with different DBs using a coherent interface. You work and mine will soon converge.

[13:01:05](#7NDguUK_UEnjnaXdwlrSbL-DGbR8X2Nb9MKjZ_IMYTo) <GiuseppeChillemi (GiuseppeChillemi)>:
* I am currently working on SQL-Server via munge, and I am building some high level objects to work with different DBMS using a coherent interface. You work and mine will soon converge.

[13:01:55](#DkH88B8eOiTZn4-JEr8LQwsdF2mfwYgC7I00JFAjs-Y) <rebolek (Boleslav B≈ôezovsk√Ω)>:
@hiiamboris :) That‚Äôs actually intended. It‚Äôs probably IO bug (caused by closing the client in the read event) but it helps me to stop the docker container without some unnecessary effort.

[13:02:23](#1f2_PGhpah8iLx4rPPE-oOw4oVaLIfPqg0OGOIH3zTg) <hiiamboris (NOT THIS ONE)>:
Haha nice :)

[13:02:35](#O0pXGarP6iwedlLGuxOTZlRQQVhrVxP6Wc9cqqHYFuk) <rebolek (Boleslav B≈ôezovsk√Ω)>:
But now that I have a prompt I probably can get rid of it and stop it from prompt.

[13:03:09](#MTuOE1V8_vKyAQ24kpciryNkGS8FXu5xTlx_rTngXjQ) <rebolek (Boleslav B≈ôezovsk√Ω)>:
And report the bug  Ì†ΩÌ∏É

[17:43:30](#-iv8-AWJ46ag6BeognJf5eqgfDU99lMLe2HMiS5FCAM) <Respectech (Respectech)>:
@rebolek Awesome!

[20:48:42](#0c1V2KuW7utacMQG0IuvoZGsPFFQ-Y9jiUG1iMR_fOY) <rebolek (Boleslav B≈ôezovsk√Ω)>:
@Respectech thanks!

## 22-May-2021

[18:11:19](#8gan_D_YzkRsm3IPhJyW1e6BUTmPZnpKdJcJ6_DkCiA) <hiiamboris (NOT THIS ONE)>:
https://i.gyazo.com/d2bb4c569b7b796fe77bc5f572570dde.png 
flow layouts ‚ò∫

[18:15:11](#rqegitNQQSBPgHhfSa3vldK_I_8E04YTFy3Hqxwkf_8) <hiiamboris (NOT THIS ONE)>:
actually I wish this was the direction taken by VID, layout function being separate from the face creation, so faces could be laid out again at any time (e.g. after resize)

## 24-May-2021

[20:00:12](#AdwlhMU40bEx115Nh7FPRQuz8pkqhvry0Sq456i6MUA) <greggirwin (Gregg Irwin)>:
Nice work @rebolek. :+1:

[20:02:44](#398DwTSxpOhvgEh-JYSxAzq-R7I-MpJzsg6d2CDD8vk) <greggirwin (Gregg Irwin)>:
Also *really* nice @hiiamboris. What if we create an `arrange` function that operates on faces? At least to experiment.

[20:15:56](#ENJP1_5lS2y6NPxK-gvAkcu0K7Jsm8P4x57aUwJZRMA) <hiiamboris (NOT THIS ONE)>:
Good name. I'll add that to my 400 todos list.

[20:18:43](#gxhx5evL1NrPjq4biqZEKH4rjQxO0CQlDSKk53RmaOY) <greggirwin (Gregg Irwin)>:
You're catching up to me! ;^)

## 25-May-2021

[10:39:54](#ZZ3r-VHcW6VHIHuDaXxAGlI9Uw9MuQ0YoHrtPJMsvek) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I‚Äôve been doing some HTTP request from Red and looking at them with Wireshark and I noticed some funny things:

* if you do `read http://www.google.com`, `User-Agent` is set to `Mozilla/5.0 (Windows NT 6.1; Win64; x64)` (I am on Mac)
* if you do `write/binary http://www.google.com [GET []]`, `User-Agent` is set to `Go-http-client/1.1`

If you set your own `User-Agent` the above values are replaced. I‚Äôm not sure what‚Äôs going on here :) Can someone confirm it?

[10:40:05](#aWxpbgxr_xnmz5BVghLr3IMkUwcHQ18x1jfIfnbjqrA) <rebolek (Boleslav B≈ôezovsk√Ω)>:
* I‚Äôve been doing some HTTP requests from Red and looking at them with Wireshark and I noticed some funny things:

* if you do `read http://www.google.com`, `User-Agent` is set to `Mozilla/5.0 (Windows NT 6.1; Win64; x64)` (I am on Mac)
* if you do `write/binary http://www.google.com [GET []]`, `User-Agent` is set to `Go-http-client/1.1`

If you set your own `User-Agent` the above values are replaced. I‚Äôm not sure what‚Äôs going on here :) Can someone confirm it?

[10:45:45](#QxispEBx_JJbbeDd1fubKLXQynuSV721axPiyys99BE) <hiiamboris (NOT THIS ONE)>:
* I‚Äôve been doing some HTTP requests from Red and looking at them with Wireshark and I noticed some funny things:

* if you do `read http://www.google.com`, `User-Agent` is set to `Mozilla/5.0 (Windows NT 6.1; Win64; x64)` (I am on Mac)
* if you do `write/binary http://www.google.com [GET []]`, `User-Agent` is set to `Go-http-client/1.1`

If you set your own `User-Agent` the above values are replaced. I‚Äôm not sure what‚Äôs going on here :) Can someone confirm it?

[10:45:54](#FXi6ZpEFuptNNkUaPYq87BkFaEsNsQlv7N1cpfV3to4) <hiiamboris (NOT THIS ONE)>:
* 

[10:58:52](#6bKEGFgeL5c9gy-Cl3GW0GwL02M5IxcDB9pK_z6bPyk) <rebolek (Boleslav B≈ôezovsk√Ω)>:
btw, cookie handling added to `send-request`

[18:12:50](#n-yFdb7tAPqmKxJz7AbT-52VGSPtck60NeKdzw-XsY0) <greggirwin (Gregg Irwin)>:
Maybe @qtxie can say.

## 21-Jun-2021

[23:33:40](#prHKhA2kB-98H4X-VZdMOxta-afy746JUf6flm6uO7U) <gltewalt (Greg T)>:
User-Agent on `read` is the same on Linux Mint.  

[23:43:40](#or26ZoLMgkoLSNw1hsh1lstnwZtIfJgDKDcrGtT_lUs) <gltewalt (Greg T)>:
I seem to have a foggy memory that it's a default when it can't identify the User-Agent. But... it could be a false memory :)

## 22-Jun-2021

[4:38:30](#JxOA5V0AzrJaXn1hsuBmgg9JWpPp32PgFkbYcRDbcnw) <rebolek (Boleslav B≈ôezovsk√Ω)>:
@gltewalt I now know the answer, it's comming from libcurl

[4:39:54](#K2oU3sPMTL_NC4fxh-8-H4QNPNKdVqalnchFytel7zA) <gltewalt (The other Greg)>:
Ah, ok.
I was WRONNNNNG 

[4:44:13](#wEPrfJMDJNS-ezCfCa-mzl4URzfhMyKgh3U-osSGzBc) <rebolek (Boleslav B≈ôezovsk√Ω)>:
the second one. The first one is default set but qtxie :)

[4:44:21](#2SsbpEEwcP6_OhRuv38AyGqeK8aiFOgp6VU_QTtIuJU) <rebolek (Boleslav B≈ôezovsk√Ω)>:
* the second one. The first one is default set by qtxie :)

## 7-Jul-2021

[0:01:32](#v7l8H2CDbWQdEQoJsYayXVCvP0tNpdyLb_XfNUAEohY) <greggirwin (Gregg Irwin)>:
For @Respectech and others who mess with hardware.

https://eighty-twenty.org/2020/09/10/booting-samsung-galaxy-s7-modem

[18:57:11](#sJDs9tMHnTr31KCoLIFCCAaAg3CnMyXK1937RdQpqBk) <Respectech (Respectech)>:
Yes, that is pretty standard with cell modems nowadays. Most cell modems actually are a closed system that run a proprietary minimal Linux OS. The Quectel modem in the PinePhone was recently reverse engineered by the open source community to run an open OS firmware as that was the last bit of the phone to be a "binary blob".

[18:57:35](#w700vqNJNuHRcRGk_z349rtM6qj1CVXKnYacJiFlFz8) <Respectech (Respectech)>:
BTW @greggirwin - Have you received your PinePhones yet? If so, have you gotten Red/GTK to run on them yet?

[19:06:14](#fz-a_PRjgW1K61vElVLgqkrrPJABQZVbDWolrsIiB4E) <greggirwin (Gregg Irwin)>:
I did get the Pine phones, then life got crazy and there they sit. Waiting. Maybe I'll hand one off to @gltewalt:matrix.org to play with. Give me a reason to meet him for coffee. :^)

[23:21:18](#Nz-DY-ew3u8FqRcfcIpHl1-oGG0M-aLZsILcazexKuw) <gltewalt (Greg T)>:
That could be pretty fun setting one of those up. , or very "hair-pully", depending

[23:21:32](#zRb-eX5s7hBk7GKFpMIMMlFkVRWXeNt57Foe-TEUrKQ) <gltewalt (Greg T)>:
:-)

## 8-Jul-2021

[2:49:21](#U0377IvJa1wjHdYMbV7e8EE1Ejizq7s29SRuvXlLDOc) <greggirwin (Gregg Irwin)>:
I'm in town for a couple meetings tomorrow @gltewalt. Let me know if you're free before 4:30 or after 7:30. I can do a quick exchange around 6:00 as well. 

You have @Respectech on hand, and can then provide more feedback for them too. Good for everyone.

[3:17:53](#unN2pBh2cP2UtMDtfbJG27_siPesOD_umrrtk3cCzC8) <gltewalt (The other Greg)>:
Most likely free at some block of time before 4Ì†ΩÌµì

[16:40:15](#iMdbUVsPDKjqqRKAY6X4F7MGBp8EGQwQl8nXSFb_XwM) <Respectech (Respectech)>:
I'm going to be driving to Wyoming and then Montana and back to California later this month. Boise is a bit out of the way depending on the route we take home from Montana, but it would be fun to meet up if I could work it into the schedule.

[16:41:27](#PrCGgqaN21aOE7GMyYHq-jIk3pxCc8bIs24-hllI7wk) <Respectech (Respectech)>:
I'll be using the PinePhone as my mobile 4G router on the trip. I'll probably use my Pinebook Pro as my main laptop on the trip as it doesn't download stuff without you allowing it to (unlike Windows).

[16:42:42](#A4_qVFtF_m7H8rYQTR8erc9RSZUSDLMxhfrOrfEvkTI) <greggirwin (Gregg Irwin)>:
Let me know timing and your route when the time comes. Would be great to see you.

[16:50:19](#0l410bd6KCBsSwC7TgFIbpIg_z18JkdA5OWsZGAWZNs) <Respectech (Respectech)>:
Looks like it is 45 hours of road time if we bypass Boise, and 46 hours if we go through Boise. I'll see if I can sell Rosemary on the idea of an extra hour on the road. Ì†ΩÌ∏ú

[16:54:44](#Sbz1V3X6C7hLPiWl0pEniX2k_cRrwCKos5J68-fwyFs) <greggirwin (Gregg Irwin)>:
I can come to you as well, if it's not too far. We can talk more privately.

[18:00:42](#7oSPnqB1URd6fCRwprmKPbeDKPT5P647XWYx_KJpebI) <gltewalt (The other Greg)>:
Tell her it's too far without nice services If you cut across to end up in Eastern Idaho

[18:02:14](#YxiGhxaYXHkXHdK1ke-nwzHBIPw7PsTsDuODzNbuBZs) <gltewalt (The other Greg)>:
Or it's better to cut down from boise area and go through Reno

[18:02:49](#pcqQ1CCsqOVN38xLYJRsFD-88wNV4gZAJYyd9vR9lJM) <gltewalt (The other Greg)>:
You always wanted to race down Donner pass

[18:26:40](#fB_SH4e3NlxeZbjsgKw8DNgjtuTl_dNgF8qzaX05cXA) <greggirwin (Gregg Irwin)>:
Everybody should see Winnemucca at least once. Or is it at most once?

[18:31:04](#4l5IVpTA9RPx6yEHMxhQwL_9xahY1fCz8KQ5qwixa78) <Respectech (Respectech)>:
Well, none of that will work with her. She's been all over multiple times. We've been to Winnemucca (and most other Nevada cities, especially on Hwy 50 and I-80) dozens of times. I joke and tell her she should be a long-haul trucker because of how much she drives, and how good she is at doing long stretches.

[18:31:18](#5pk6OdTHf6yNaAc2pmDg5QsKA9H-Un_cYEAykWExPak) <gltewalt (The other Greg)>:
They used to have a great breakfast place along the business route. But it had been 11 years

[18:31:22](#FCdDsrcqZkyFeLYlwxAvty2gshxm8IR1Wg2mOT3xbZw) <Respectech (Respectech)>:
But that also works in our favor, because she doesn't mind an extra hour on the road if it fits in the schedule.

[19:54:17](#lSiMC2XjbPQBVgRAF4pNPJcevWKNFQmGtRCN7k3sAfs) <gltewalt (The other Greg)>:
greggirwin (Gregg Irwin) I have between right now and four something.
Maybe another block after 7

[23:12:42](#gzEXVwARxqaST7xD3eRq3Y0ByBuuyHng6fx05V_-2PI) <Greg T>:
pine phone, but it might be awhile to figure out Red android

## 9-Jul-2021

[0:04:37](#acUCfP9Z41Wh23cPOzbtMTXhVEbSnLd8mEZJ63SQIqA) <Respectech (Respectech)>:
PinePhone runs Linux, not Android.

[0:04:42](#17gTEDu2SBdYr2FyFZHUxVLLPEIBjti2S2OtGfkRz4k) <Respectech (Respectech)>:
Well, it CAN run Android, but that's not the target.

[0:05:29](#irUxAlp_K1mCCNgteVrFWJHuZLtjCb1MxnPhfQZXNoI) <Respectech (Respectech)>:
So PinePhone will run Linux ARM, like Mobian, Ubuntu Touch, Nemo, Sailfish, etc.

[0:06:04](#Il-5Kb2_tEJbLaZt0cb4IzkQLlZsYh4PKv1dz4dE5so) <Respectech (Respectech)>:
PinePhone can also run Anbox on Linux, so some Android apps are also available through that compatibility layer.

[0:19:33](#KAo9B8Ca4-MTloVa5Hq6RtxZbPj1pgDYBK-qcrrBsEA) <gltewalt (The other Greg)>:
Yeah not sure why I typed android

[0:22:04](#mBDWFq_u01_0dpqSQVIpSTqPoQHT3JkhijwB-1mQt3Q) <Respectech (Respectech)>:
BTW, I'll probably be coming through Idaho on July 26th.

[1:00:43](#4d8fpUpMpLk33LhuUl0lDaOKkJrNaRZlOjSBqicLlT0) <gltewalt (Greg T)>:
manjaro

[1:56:29](#K7sR2ro4CQfWmItFOQSuuNbCkEGUxRYQmcYlXZM75s0) <gltewalt (The other Greg)>:
Might be a challenge with manjaro on the phone

[17:42:25](#7Uo4eanP-RRKJSjfJB2-BQ1V17k8zYrtU2uFhdSTu04) <Respectech (Respectech)>:
Be forewarned that the PinePhone has a very low-end quad-core processor, so it will be a good opportunity to work on code optimization. :-)

[18:15:22](#6WP-0edvvZMcqnm81cLsrb0-dGJxLlSmsNkd935qbh4) <rebolek (Boleslav B≈ôezovsk√Ω)>:
quad-core? I'm using Red on rPi zero, so quad-core is like Cray compared to it :-)

[18:20:22](#6b_7t-mCD0m8_eHSyBkG9yLmkjvxVyaADdzPkEvuAHk) <greggirwin (Gregg Irwin)>:
One of my thoughts is that playing with gestures, cameras, and a phone environment will help flush out issues we can address sooner, so they're solved for Android when we do that update.

[18:22:38](#AJ5T8ivufQypYMIs1BQxvv_yGEQDKcIGXPShsvIQ1s0) <gltewalt (The other Greg)>:
First issue, manjaro arm has no 32bit stuff. (That I can tell)

*goes to see if there's an ARM branch*

[18:52:01](#nn7JbdNAiPFrwX1KDb0PGhWyIqTVrAxTJ6H9HmtD3ao) <Respectech (Respectech)>:
Yes, the PinePhone is quite a bit more powerful than the Pi Zero.

[18:54:41](#IeT1uCpBBkWWnREpAarAJnix8pkKWdHeb9Xdn0qGvZ0) <Respectech (Respectech)>:
The 32-bit thing could be a challenge. I was finally able to get Red to run on my Garuda 64-bit Intel Arch Linux system - which was more of a challenge than I thought. I am running some encapped Rebol2 programs on Garuda as well, but I'm doing that through Wine. That works surprisingly well.

[19:52:25](#u9rAT-0MQ4i5RztFiDyI7oaqxVMIi_UvY4X_-8jF3yI) <gltewalt (The other Greg)>:
It came with this dongle that has USB, hdmi and ethernet. I can use a keyboard to type in the terminal out of the box.
Can I install a different distribution from USB or does it have to be a flash via SD card?

[20:20:37](#zKuZCk6a_ufdZqCVEUI76z4OHIQG_mdbkpHG_GEmuGA) <Greg T>:
Ì†ΩÌ∞ë

[20:54:11](#fLF_uNrR78TSxA4F5Tauvw926cujxCrmGgBLZk2VdfM) <greggirwin (Gregg Irwin)>:
I don't know what the sheep means, but that's very cool about using a keyboard so easily.

[21:01:02](#b1Vk9-LJ5bhZrcSyLN8fNVlLE-zIOSnnL8SD9vQJhuE) <gltewalt (The other Greg)>:
Yes I was surprised, but it picks it up right out of the box

[21:44:25](#0sF-gAhDc68-yAx1wrD6hHqYxNdRL_Xk2XgpM52QhCQ) <Respectech (Respectech)>:
I believe you have to use a microSD to boot into a different distro. But you don't have to flash that image to the eMMC, so it makes it really easy to try different distros.

[21:45:24](#B1k0UCrZBKfC-wS11A7JEkiIwNfg27f4qfVTupAVfoI) <Respectech (Respectech)>:
Regarding 32-bit/64-bit, Box86 / Box64 may be useful as they are made for ARM Linux distros: https://box86.org/

## 15-Jul-2021

[17:25:47](#pKOepTHWuhpVuWaAtO4OmwSnMNAz4Q0wCXLRVEAAW-I) <TimeSlip (James_Nak)>:
@greggirwin "so they're solved for Android when we do that update." A major teaser, you are!

## 31-Jul-2021

[20:31:59](#gXQY9UxqeZqAd0i0H76fBB-ZY65ZkkxJn5MEQiBgUSs) <gltewalt (Greg T)>:
Vaporware?

https://imgur.com/a/ROBd2Jm

[21:30:26](#cT5RFfNtxJ10_Hgbuu4OU-zVcW7oEfVJ9gpkgd_XirY) <greggirwin (Gregg Irwin)>:
I still like this one: https://www.youtube.com/watch?v=y3RIHnK0_NE

## 1-Aug-2021

[5:37:19](#MJ_TiBWCfWKZPxnM--IwUmb3eRfLw3mu47v3O3u_moQ) <TimeSlip (James_Nak)>:
@greggirwin Great.

## 3-Aug-2021

[13:12:03](#Ql2BawZkVQpcWcq-lYmKtGU2q4fJ3UQkdae1fnvMMSg) <planetsizecpu (Jose Luis)>:
Amazing @greggirwin   Ì†ΩÌ∏Ñ

## 12-Sep-2021

[17:36:40](#Pjyz60pBHZCvvWS0NRWk7fstI2jkUtOzvp_WCFcqdqQ) <gltewalt (Greg T)>:
@hiiamboris Which glob of docs did you like to use? I forget.
(link)

[18:13:57](#RqXnl3UJ22maT_xyU3fwomCc0LJMCXhELt01vskqvUE) <hiiamboris (NOT THIS ONE)>:
Glob of docs?

[18:16:40](#7WEIRAwgDKYiBEXlQWJTzxHaAjLCHmmp43qKCdx3NXs) <gltewalt (The other Greg)>:
The docs for red that you prefer to reference 

[18:19:56](#xMRQQHo6pNy86qHuvM2-nIllHtQvBhttnx3Rhr4tccw) <hiiamboris (NOT THIS ONE)>:
I don't use any tools if that's what you mean

[18:20:49](#blIEFsIGOy1Ol-Zuf9XkmxkvaxXldxKVdd0bZdXjG18) <gltewalt (The other Greg)>:
No I mean the docs with the sidebar menu

[18:22:37](#5ZecQleus3HbCM2HK5NZXgr-p3Oak3-1zFOVxV97hMs) <hiiamboris (NOT THIS ONE)>:
I guess your question points so far out of my cache, that I still have no idea what you're asking about ‚òª

[18:24:35](#b_mKe_kJKZcWdaEZLmL_DgzkRn4dXjO5rva6j0xhByM) <gltewalt (The other Greg)>:
You were using an alternate website that had at least some of the official red docs on it. Weren't you?

[18:43:22](#GihSLMNfZT3jxetwqlEiAmIOSnw5IlnJB4iY0zSzor4) <hiiamboris (NOT THIS ONE)>:
Ah.

[18:43:31](#atl76SDtJNm1sOZhxxCy1lu4d-Yhc2ya6rsLgwVV6Uk) <hiiamboris (NOT THIS ONE)>:
http://w.red-lang.org/ ?

[18:44:23](#BC1HU_6Drz2jn2-Qm0wLSGJCoBW4P1tZiKekEo3ib7Y) <hiiamboris (NOT THIS ONE)>:
It's probably the official site now.

[18:44:53](#NtNBKc4Y9G6qfa1PY1Re0FiOY2iRM3VBueD7qFq95wI) <hiiamboris (NOT THIS ONE)>:
* It's probably the official site now that the other one is down.

[18:46:04](#JKIFFMhIXWeUTBWD4jqXjIVxbdUjsUKEJWRQhv5KPIs) <gltewalt (The other Greg)>:
That's it. Couldn't remember it for the life of me.

[18:46:59](#GJzKHMLhJqBqeQ0P375L3BgLHc1vz5E616UvjudoGSc) <hiiamboris (NOT THIS ONE)>:
Right :) So many disparate resources...

[19:54:11](#tSdDwy5N0z70y73n5XV3tCuK2WiFhUip015gDVQSk7Q) <greggirwin (Gregg Irwin)>:
Which other one is down?

[20:42:10](#n46rh58Tn9iM17r_NpGah09hkbUSTZKlTxDwL_n92Lc) <hiiamboris (NOT THIS ONE)>:
doc.red-lang.org

## 13-Sep-2021

[1:43:30](#Wt9AA44OE76vWKwOryX8v3fOXX1-MQ0U3BMsL_h4sPY) <greggirwin (Gregg Irwin)>:
Ah, right. I've been back to direct github viewing for so long I forgot.

## 25-Sep-2021

[9:12:11](#cYAGgxuNi57s5jtx2fXLCPZ3EPw0GCNLOm8-gVnIloU) <toomasv>:
I played with idea Oldes presented in /red room ‚òù [September 22, 2021 9:11 PM](https://gitter.im/red/red?at=614b71d15b92082de1b754ee):
```
make-block: function [data /all /with selection [word! block!]][
	if word? selection [selection: to-block selection]
	either any [
		accessors: select system/catalog/accessors type?/word data 
		system/words/all [
			url? data 
			data: decode-url data 
			accessors: words-of data
		]
	][
		either selection [
			if not empty? weird: exclude selection accessors [
				cause-error 'user 'message rejoin ["make-block: Unknown accessor" pick [": " "s: "] single? weird weird]
			]
		][
			selection: accessors
		]
		collect [
			foreach sel selection [
				if all [keep to set-word! sel] 
				keep switch/default type?/word d: data/:sel [
					word! [to-lit-word d] 
					path! [to-lit-path d]
				][d]
			]
		]
	][
		if any [all with][
			cause-error 'user 'message rejoin ["make-block: Data of type `" mold type? data "` does not have accessors!"]
		]
		append copy [] data
	]
]
```
It helps to work with data that have accessors (date, email, event, image, pair, time, money) + url, including also the idea of `query/mode`. For other data it just en-blocks it.
E.g.:
```
make-block 3x2
;== [3 2]
make-block/all tom@est.ee
;== [user: "tom" host: "est.ee"]
make-block/all url: https://tom@www.est.ee?q=me
;== [scheme: 'https user-info: "tom" host: "www.est.ee" port: none path: none target: none query: "q=...
vars: [query user-info host]
;== [query user-info host]
reduce make-block/with/all url vars    ;Careful -- modifies global query
;== ["q=me" "tom" "www.est.ee"]
reduce vars
;== ["q=me" "tom" "www.est.ee"]
make-block "hi"
;== ["hi"]
to-block "hi"
;== [hi]
```
Might also add accessors for other types, e.g. `file`, into `either any [...]` block:
```
system/words/all [
	file? data
	accessors: [path name suffix modified]
	data: object [
		path: 
		name: none
		set [path name] split-path data
		suffix: suffix? data
		modified: query data
	]
]
```
E.g.:
```
make-block %abc/def.red
;== [%abc/ %def.red %.red none]
make-block/all %entities.red
;== [path: %./ name: %entities.red suffix: %.red modified: 19-Dec-2018/21:08:35.815]
```

[17:11:42](#ydRLm3ZNO9Z7tM3QNQ52akE4POzl6jI6YyGeFDfj-_E) <greggirwin (Gregg Irwin)>:
:+1:

## 13-Oct-2021

[12:08:01](#wMN-MwQEeSyxF7yfqT2bNhGBdEBwdrw67Rp-xlbW-fE) <abdllhygt (Abdullah Yiƒüiterol)>:
:+1:

[12:09:01](#sqhlBe9GHd-_4tGv0RWYP-wynnwJvCqrMC9ba_oy_no) <abdllhygt (Abdullah Yiƒüiterol)>:
:+1:

## 31-Oct-2021

[9:24:54](#pCxKHgdNrtKIdZAWxtmdVY8GPe9yeAamFoqDiAnkyfo) <toomasv>:
@hiiamboris Any idea why closing mark of `<h1>` is eaten here:
```
print rejoin morph read %morph.md do %md.scan [<h1> 'h1 </h1> lf (<h2> 'h2 </h2> lf ...)]
<h1[MORPH DSL - A dialect for efficient local series conversion](morph.red)</h1>
<h2>Status</h2>
<h2>Goals</h2>
<h2>Origins</h2>
<h2>Examples</h2>
<h2>Data model</h2>
<h2>How it works</h2>
<h2>Scanner type rules</h2>
<h2>Emitter type rules</h2>
<h2>Default rule dictionaries</h2>
<h2>Partial update logic</h2>
<h2>Further considerations</h2>
```
with `md.scan` as
```
Red []
context [
	line: [not lf skip ...] 
	return [
	  "# " h1: line 
	| "## " h2: line 
	| sub: [not "## " [line lf] ...] 
	| skip ...
	]
]
```

[9:30:59](#I6mwNqGDBCINC6rppDKFNdtMUA_fYTXch2GGcNm0KBE) <hiiamboris (NOT THIS ONE)>:
what do you mean by 'eaten'?

[9:31:17](#GW_oU_p0-bplwmqxK6IuPHvPMu3rfxPGvMkrSV2AyVg) <toomasv>:
`<h1[MORPH`

[9:31:27](#Z9Domggs-NZxKd3xqlK1ldi_nZdbAZgcaahGdq94mC0) <hiiamboris (NOT THIS ONE)>:
ah

[9:35:17](#2lhCtIxbiAB8sopyxwcvjeTOpEj43YdUlldnbz2IeD8) <hiiamboris (NOT THIS ONE)>:
```
>> rejoin [<h1> {x} </h1>]
== <h1x</h1>>
```

[9:35:41](#AHtfPelctJF1lPF58IrnFP2q1mWhCQQgLWUNnluiH-M) <hiiamboris (NOT THIS ONE)>:
I guess you need to add `"" ` to rejoin

[9:36:12](#6uMztLvW0Vsyok2j73IDS22-DDX9w_-p-4hGh4E28Xw) <hiiamboris (NOT THIS ONE)>:
or `morph/into ... ""`

[9:40:39](#BFgezFn7hBCMWMOLsMFa6RscO7wWpUjJojTOhHhKztw) <toomasv>:
Ah, ok, thanks!

## 2-Nov-2021

[10:59:42](#fQzaIb0WODiBo_i5C2l0WOuUQWQG_kL6III9JlUijrI) <hiiamboris (NOT THIS ONE)>:
@toomasv of note, morph is now tested to be able to convert files from one format into another: https://gitlab.com/hiiamboris/icu

[11:07:57](#ZhjcZZpgOKucToOnr3KVvGmzExKFGjiIAXa43OqOUKU) <toomasv>:
Great, thanks! I'll have to study it...

## 3-Nov-2021

[12:26:00](#XfKNlrjX9v2BsQqhD792cNYc8wAvWuz2dayonmb_x7A) <rebolek (Boleslav B≈ôezovsk√Ω)>:
cool profiler https://github.com/csurfer/pyheatmagic

[13:57:51](#9WD8Mgl83sQDat4IMAiF3ZYlEcDplO8kr3FmEX_LMUQ) <pekr (Petr Krenzelok)>:
Aren't we getting some kind of profiler with the upcoming Interpret events branch?

[15:25:21](#vEhHg9TO6AmheMAWey3c8SSzDlnpFz1VvcN9iRy8pec) <greggirwin (Gregg Irwin)>:
@pekr, yes.

[18:37:24](#HeO-sLFCIb0v8kxnUUsEJW4veYdsFfJlsWJTs2Fj8Sw) <GaryMiller (GaryMiller)>:
What is the interpret events branch?

[18:38:38](#wUlvB5iqN4AyrZmfx0lXNlDFyNSf2e3g2OyG_dGIIrU) <greggirwin (Gregg Irwin)>:
Instrumentation added to the interpreter for profiling, debugging, and more. Info coming soon.

[20:12:25](#XKaFS1WR937PuJARp3znZCz4e2f5p20HIqct6p9KMaI) <GaryMiller (GaryMiller)>:
Sounds Good!

[20:13:02](#Vi2-F2fUHOhXzowdfGk9BgF6t5AaaTEOUnNxqdNQXQc) <GaryMiller (GaryMiller)>:
It will help with those missing ] that are so hard to find sometimes!

[20:14:30](#TFjWC2zsiGdSzooDj2zsc23Th49XuhIT3shxFFY7S2w) <hiiamboris (NOT THIS ONE)>:
https://gitlab.com/hiiamboris/red-cli/-/tree/master/mockups/bmatch @GaryMiller 

## 1-Jan-2022

[7:57:08](#SS4KNevjbvmYORRFeKve3nuKYyQIRRpqp9ezM_zKk5k) <gltewalt (Greg T)>:
Roughly hewn as I sampled wines and listened to fireworks outside.  Admonishments welcome.
https://gist.github.com/gltewalt/e68bfabacfe5747909976f0f989c1e3b

[20:39:53](#bpZOg8ccoEPNpqdSnvWMsPF1dm4qREu-wAWgdEp8Ea0) <greggirwin (Gregg Irwin)>:
Looks very clean to me! :+1:

[23:49:56](#4PZ4fjRTZPkYQ2w1mOG75gJcp4LJdsJsmXgH-So_4pQ) <gltewalt (Greg T)>:
@greggirwin 
I don;t think that `remove-each` is workable in functions `get-cards` and `check-for-books`, where I use `take/part i length? i`
Is it?

## 2-Jan-2022

[0:03:09](#yZnMQ3oDzqPcf4tqIRGVd9C7Jk1uXOo3QO04ATqWTcs) <greggirwin (Gregg Irwin)>:
I'd have to review the code in detail, which will have to wait for another day.

[0:04:05](#COffj3BS_GdNMGgwVxBjKrNxYCWsS9tMQn4me64S6rE) <gltewalt (The other Greg)>:
Yeah.
It works as is, but leaving behind "" elements is a wart

[23:05:06](#lnlrjkCJ1Sni65ix2Shx8gbVR7CbwCCq-WAcrvJ95g4) <gltewalt (Greg T)>:
Yeah.
It works as is, but leaving behind "" elements is a wart

## 6-Jan-2022

[6:08:33](#AFgN4qMDauTJmra3Kbw6UDSEs_aTYC_RRbdmO-yVkX0) <gltewalt (Greg T)>:
Can you folks see this with a direct link?

[6:08:35](#J_ZBo1eWitYkhySfwk5PwJXYKUDniSPcLNgFMzVD9SU) <gltewalt (Greg T)>:
https://github.com/gltewalt/go-fish

[6:11:35](#-0g9vegKrhc8MYFNGpDYWq0T-T-Nmyi3r1sAVIgG2fc) <rebolek (Boleslav B≈ôezovsk√Ω)>:
404

[6:13:02](#L53lqs_G9bYo3xxotzljhAgE4-FwxobqmLUaowR4bnQ) <gltewalt (Greg T)>:
ok

[6:31:10](#pEhV9tm-4JdSkDyb1vP2l5En3PdGayo4ZYqv_NRxrjg) <gltewalt (Greg T)>:
Should be public now. 
For a few days. I figured it was better than a gist for saving in the cloud, until I'm done poking at it

[12:47:01](#_c8lLKcr8Uz-j-WZiBiOiyxWCQShjP9SYnOSfNhsyEE) <toomasv>:
Nice pic!

[19:25:37](#aXtJOQtDDXlRHSbXFU2r9DSxrezmzpPuWfC4na86kPw) <gltewalt (Greg T)>:
Let me move to red/help. Experiment in code review if anybody has the time and the inclination

## 8-Jan-2022

[2:06:41](#hZGI_hdOcPAmiHOhf_B77S-ui1rMvpK-saf0bBajSbM) <ne1uno (ne1uno)>:
is there any way around case insensitive keys?

[2:06:41](#LuSfB9xftRGBPN3kyH-SlFGgsBqB7GhZNcQR54wO1jU) <ne1uno (ne1uno)>:
I'm doing an old advent of code with json, https://adventofcode.com/2015/day/12

[2:10:52](#7QkyWLfHjLZrVR7BXPGjhEbVlXJd-zQ3HrNe7gLrxKY) <ne1uno (ne1uno)>:
help should probably warn about potential data loss if not

[2:18:28](#2o9kX5vaRlYGQGvxBBBGAjDQ-GzVW9efdQqzt0ph5vI) <gltewalt (The other Greg)>:
Constrain any IO to one case or another?

[2:19:52](#Mu1PJirwA0JHPr-u20bcpKcv-7Qa4XlMflhxwk6QqVU) <gltewalt (The other Greg)>:
Ah, I just read it

[2:21:13](#tTOdaxKsWTeohgyPBq_ezmrp6IvU227nHPGFncBEzaE) <ne1uno (ne1uno)>:
yea. I'll probably pre-process the keys, but it wasn't obvious why I wasn't able to see everything at first

[2:21:54](#pqw-pAOvQH_tbsREx_yIenNE_1IF7O3-cDZDjlDmyeU) <gltewalt (The other Greg)>:
Ah, yes. Help should probably mention it

[2:22:20](#9y54_aqHGsCytnAuKFNwDE_9fa0X1Ke7zHCygBQoDAk) <ne1uno (ne1uno)>:
for some reason I thought map keys were case sensitive

[2:55:23](#Q3N-vi2CLOEJhGgvaB2Gr1pDTQlP5zRriVX-UzykFlk) <greggirwin (Gregg Irwin)>:
When in doubt, read the docs: https://github.com/red/docs/blob/master/en/datatypes/map.adoc

[3:06:35](#-W7RO6QL9Nv8w7NMFvfZiDteIBUcVePe4wRkD3dqhEA) <ne1uno (ne1uno)>:
thanks, will try get/case

[4:06:36](#Vq7oXKGOYWMsGWUqjw75JR4CWNPoUKkvOccP5QbbQm4) <gltewalt (The other Greg)>:
Amazing what a person (me) forgets 

[4:09:38](#1_v1VbsYzxKJZXn7KfgwxKC7GID8doYcqSpdlbol5QU) <ne1uno (ne1uno)>:
https://codegolf.stackexchange.com/questions/195476/extract-all-keys-from-an-object-json     --spoiler--

[4:25:49](#DOnry0vNDboZsVsK1VovtwF1Lwp2P13ID_-WF4R7rg4) <gltewalt (The other Greg)>:
y: to-map x
keys-of y

[4:30:26](#B2BlXji3tAKR5LYajIrDHapfr7rKnAFCykUAXtlVmMw) <ne1uno (ne1uno)>:
needs recurse,  some keys are maps or blocks etc

## 9-Jan-2022

[1:36:42](#W0nHCelpZZQtNbigoPicGHj95VJvrXAf5_urIqDNgQY) <gltewalt (Greg T)>:
` parse trim/with form load/as %test.json 'json "#(^/)"` [do your stuff]

[1:55:45](#QSVOoQLX-3ARcTILASCYnTBzobXjVWxTxrBq0B5fGV0) <ne1uno (ne1uno)>:
nice flatten for maps, I'm still getting same wrong sum

[2:06:31](#Sv6i_HbVx0--Msw1mjbcK2JU04SKWntOysXqJnpSvmA) <gltewalt (The other Greg)>:
For which thing? Advent?

[2:13:11](#wYt0PTKroByQNCVmSC-VPLOEhkplUIigv6Fg3BvB50s) <ne1uno (ne1uno)>:
yes. wondering if load-json is missing the last map. haven't tried older version yet

[3:10:04](#LPAmUqHLGimOJ41Z0jpGHiGK4FDZxagy4FZQJ5uhB8s) <gltewalt (Greg T)>:
```
>> blk: load form load trim/with form load/as %advent.json 'json "#()^/,:"
== [e e 86 c 23 a a 120 169 green red orange b red g yellow b yellow d red f -1...
>> foreach i blk [if integer? i [append nums: [] i]]
== none
>> nums
== [86 23 120 169 -19 -47 2 59 47 43 168 78 82 -41 2 77 147 49 -1 142 136 166 -...

```


[3:10:46](#dFGj1WSpYO-W2JubMBdZ5LedapFL9fA5bYQPnS-1rgc) <gltewalt (Greg T)>:
try `load/as <file> 'json`

[3:11:25](#56rUBrxPzuBXddfyoZcCIs3QXzdxA7_ycud_36EJ6A0) <gltewalt (Greg T)>:
Those load form things flatten blocks

[3:15:34](#mj9TzTgmYHEyfJX08btF9sobhmqIyOEcUHjqajYDTMc) <gltewalt (The other Greg)>:
And it isn't like I knew up front how many I needed or the order. It was a "look, then chisel away at it" process 

[3:17:03](#TibT7rM6_rvL680Wcqt2-bEhllrNkdzdBa3_HNxPM_Q) <ne1uno (ne1uno)>:
there are a dozen or more different puzzle inputs, mine may have just stopped loading half way for some reason as a string.  `load/as` does error at the place the string stopped

[3:18:46](#Vd4guDUaLWkyLKu6m04Z4ifmXMM_EPA8yKPKPOW5TjA) <gltewalt (The other Greg)>:
I logged in and did that day. Pasted their data into a text file and save it

[3:19:23](#K-57KgzDNVt9ixMqbvKiCjX50KGOBjweK6lSvdjCnMA) <gltewalt (The other Greg)>:
First attempt at pasting into a text file bogged down though

[3:21:15](#6xyub7eymXvUJBNLRIdTM2g0a0JYpcKOwIGP3Kj5jmg) <ne1uno (ne1uno)>:
https://pastebin.com/PFA0zwNf

[3:22:14](#bp1cgXn6x__sezIXpMDutNG_BNF9RC5Pmqbsmw3dhZE) <ne1uno (ne1uno)>:
there's a coma between two objects may be the problem

[3:23:36](#4_9giR76pP2q09iPa0QvA-w3AHZ0msfi4taRKg46Qgw) <ne1uno (ne1uno)>:
probably not standard json either

[3:33:10](#4MyAoQr53yssOhBrcJNJKrFEmhoeKk42yborQGbe7Yk) <gltewalt (Greg T)>:
copy this long-ass thing and save it in a txt file

[3:33:11](#KbMvuxNf2fP-uxNwDQ9KfavrDfJz1_gp4BQkAkRBv4Q) <gltewalt (Greg T)>:
https://gist.github.com/gltewalt/b840a8beb749fdd71ff7c0b646303720

[3:33:49](#X85vAqnge9PxQln-LKLzxulu1rKcTJqAnRqeCa1SjTM) <gltewalt (Greg T)>:
That is part 1

[3:34:37](#uNoEHD2HhjM0T8Bn8Tlxw0erqNQv0Hfo3l8dk1xjfoQ) <gltewalt (Greg T)>:
my shortcut way won't work for part 2

[3:40:33](#wMaCB5NmLzCb5P9R45ZCQl8bx_qN4r3uyzUCQv3OVBo) <ne1uno (ne1uno)>:
no for pt#2 valid json parsing will work better, I looked on on the reddit solution thread.  

[3:42:36](#94pi9NGH4k9Vwa_lRgi956L5I2BHW1wivotyNSLa0Y8) <gltewalt (Greg T)>:
I don't know how to solve part 2

[3:43:54](#cClf2Hq-lzmZqUGH9TzMalxXLWDQPbZpGa_7lF6sAT4) <gltewalt (Greg T)>:
When I tried to go through all the days a couple years ago I fell in to the same trap of hacking my way through a part 1, only to see it woulnt work for part 2

[3:45:12](#HkYfVelFmjVyvh9vAmPAJ18bSKLqbDXMojkHdGVWt9Q) <ne1uno (ne1uno)>:
solving for the examples usually sets you up well for part 2

[3:45:35](#TlI-Cz8un_zsiDYwD7tSAIZiUsaPEZYXEqKTiI_ILio) <gltewalt (Greg T)>:
Not when you're a little nutty and lazy like me

[3:46:38](#3emMy5UQlJLi1IUV7pZ63h8PlrNjBIANgm-eg_B40Ys) <gltewalt (Greg T)>:
first instinct is "be hacky"

[3:47:19](#hgOEdouoz03hZKxTe_KRNhvo9xTyhvRa8fVUFC7ylSA) <ne1uno (ne1uno)>:
they get more complicated after the first week. I am stuck on part one usually

[3:50:08](#V4AQXnw6ta5PmymiFtRiHCbxKl_-Gg9rJHCs5WGTKPQ) <ne1uno (ne1uno)>:
some are too memory/cpu intensive to solve without shortcuts

[4:05:47](#ruMwOf6o7Li7GZFX5u2zwiRxVV7dhXXP165J_DlGyZk) <gltewalt (Greg T)>:
Might be a start:
`nested-block: load trim/with form load/as %advent.json 'json "#()^/"`

[4:12:05](#0bl9Yia0jn5gJWoGV5s1LboIF3196ICeC_tv388fIQU) <gltewalt (Greg T)>:
Nope... don't know how to solve it.

[4:21:09](#2ckKl9Qgapvqwk9QRDNSTiSyL5lc_qhOkbfKN-p4ytU) <ne1uno (ne1uno)>:
nested block probably simpler than map,  `mold/all/flat` maybe

[5:13:29](#-GYfGyQ4rgzz-3rs-xS8IDwjXbbKp-j9eg6OH1nAMcE) <gltewalt (Greg T)>:
Hmm, if you save the file with .json, don't need load/as, just load

[5:22:27](#QeaB44Y3ZUeVDqeMXRaOB9o-MEApQJmNRnnQgmZXtYY) <ne1uno (ne1uno)>:
@rebolek tools worked,  flatten load-json/flat read file

[5:23:28](#2-aHAyH9O179JCHR_Eczmz4b9bRtYYEhkXYJAFznkCY) <ne1uno (ne1uno)>:
red-lang doesn't have flatten or load-json/flat

[5:25:09](#JD29bgK4CN-wvvC5cfYd9NJ8qxil2Ro_62oNEfnqDZM) <ne1uno (ne1uno)>:
then just loop over blocks.   part#2 don't flatten and skip blocks contain red?

[5:28:21](#HnJf5y1NcKrAo9Gtu2aIa3dcpnY6a5Gu0e7vAtezp9A) <ne1uno (ne1uno)>:
 I see now part 2 will need to look more closely at types

[5:31:52](#sNjwJI_UbrUiDjkD6UfbPYorzhgiL7Ep8L7yCae5zgc) <gltewalt (Greg T)>:
"Ignore any object (and all of its children) which has any property with the value "red"."
Which is anything between `{` and `}`

[5:37:09](#r8F3IGRQNxdnIARvULa6g-XGT6iB3Mgaa-7uelhUcnk) <ne1uno (ne1uno)>:
flatten red https://gist.github.com/toomasv/f9730db91c365bf1ed94453028bfc1c0

[5:38:41](#gr58wEucmjURXpN-9FvPBO6HVKlU_k7l4VCmyKha86k) <ne1uno (ne1uno)>:
form is probably too aggressive as flatten

[5:47:06](#oOe8NOIHk8ctRDUkic5gSMQ0KcDTtUl0SKS_-3nYAoM) <gltewalt (Greg T)>:
It would be between `#(` and `)` for objects, since red converts into map

[6:10:57](#7QdNuFq3RVoOnv6H-q1wOD_z87Ym1PmqNPmd0Zk1muY) <gltewalt (Greg T)>:
Maybe this, using toomas flatten:

[6:11:08](#FqxTlsWOl7naLqffBy-YVwennLg_5G4rDT8pXjiOr88) <gltewalt (Greg T)>:
```
>> j:  load %advent.json
== #(
    e: [[#(
        e: 86
        c: 23
        a: #(
            a: [120...
>> j: replace/all form j "#(" "["
== {e: [[[^/    e: 86^/    c: 23^/    a: [^/        a: [120 169 "green" "red" "...
>> j: replace/all form j ")" "]"
== {e: [[[^/    e: 86^/    c: 23^/    a: [^/        a: [120 169 "green" "red" "...
>> flat: flatten load j
== [e: 
    e: 86 
    c: 23 
    a: 
    a: 120 169 "green" "red" "orange" 

```

[6:26:38](#tDefsyGwD69my_y_8bVTct8WiGlw75HcOaK1s4Iw_hY) <ne1uno (ne1uno)>:
 j: replace/all form j "#(" "['o "

[6:27:28](#F9IkWgy66JjiN9o291Vss-Vp-D1-u6W4_yFMNrtPyXI) <ne1uno (ne1uno)>:
then will have a hope of excluding any of the right objects

[6:28:05](#qhUIrnOuqi7N7QVTRtMaJZJh0X8Yz0Il6-TBATXn000) <ne1uno (ne1uno)>:
flatten/level  might be useful

[6:28:23](#w8OfM9E5xtM7gW2bmRIkuQdESPP7xrgueoIEGT3eIEE) <gltewalt (The other Greg)>:
Like a level 1 maybe

[7:26:02](#RrwmTCH0of-0OSpb7_825q6PvqmjinXpYgofBHbY-Rk) <ne1uno (ne1uno)>:
will be simpler 2 pass, remove all the objects required, then handle like pt#1

[14:32:25](#IIIEwFaW5cB9TVFoYAyI9Q8Sl7DTgi_UYLUhFhzn5qU) <toomasv>:
‚òù [January 9, 2022 5:21 AM](https://gitter.im/red/sandbox?at=61da54aa5dc6213cd4d14362)
@ne1uno this loads ok here.

[15:19:35](#RzqHr8cWbk62y9h40JjRbuwRpdLGFgslab4QqJGAa2w) <toomasv>:
A func checking three types suffices to solve 12/2.

[15:19:56](#D0XGHReqY3gqPHmbbQZJ7u0fC6Km_3p9IlsAgOcn2Ig) <toomasv>:
* A self-alling func checking three types suffices to solve 12/2.

[15:20:02](#yVK-FUfJoZhuQpyHEcmTdRZTv3Ji7mboNHzpmlyirTc) <toomasv>:
* A self-calling func checking three types suffices to solve 12/2.

[15:20:33](#aTCFZgBaLiMl3yV6lha8kJxLZlVYlzOtL9tVh_1UrOs) <toomasv>:
* A recursive func checking three types suffices to solve 12/2.

## 10-Jan-2022

[1:13:54](#axlAzrLsfVYqytANa5CWuHdT0g_KNSEKUYEMh1neaIU) <gltewalt (The other Greg)>:
How are you going to recurse through a map?

[1:17:07](#GpUYCDtLu1mIn--0Vg8SVMEEwy1bi20ok7RO0_PjZ2c) <ne1uno (ne1uno)>:
values-of

[6:24:56](#kHWzRebXoNDADv63zJbdxXRmEiTGkT6WiNBhJUqiaD8) <toomasv>:
`values-of` for checking "red", `keys-of` for recursing.

[6:30:07](#YcbdHOW24PZd91ueIwqmZOkmjby1v2Z4_89PFotZxYg) <toomasv>:
* I used `values-of` for checking "red", `keys-of` for recursing, but `values-of` an be used for both.

[6:30:24](#NOATyTlxSLvqolkBsE9iYvOzPlsbHeDo2KTOe-8yCU4) <toomasv>:
* I used `values-of` for checking "red", `keys-of` for recursing, but `values-of` an be used for both, yes.

## 12-Jan-2022

[1:13:18](#OxHECvLaBozb4H45ohZ1Mxy3KXnbnLHzAVexm5FFRCo) <gltewalt (Greg T)>:
how's this for a `unique-each` ? (Or maybe some other name)
```
unique-each: func [blk [block! hash!]][
    forall blk [
        case [
            string? blk/1 [blk/1: unique blk/1]
            block? blk/1 [blk/1: unique-each blk/1]
        ]
    ]
    head unique blk 
]

list: make hash! [a a ["BBB" ["cc" [d d]]]]
unique-each list 
unique-each [a b b [c c] ["dd"]]
```

[1:18:17](#_eIJNCfgXpkjYavkN6afZSC5GyhLz3SaMFa5EzQU9XA) <gltewalt (Greg T)>:
or just a `unique-deep`:
```
unique-deep: func [blk [block! hash!]][
    forall blk [
        if block? blk/1 [blk/1: unique-deep blk/1]
    ]
    head unique blk 
]
```

[1:19:20](#H2ue7Bb-ar3njZT_62VHbYY4Vo_yvGkuG7opMAehzkY) <gltewalt (Greg T)>:
```
>> unique-deep [a a b [c d d] [e [f f] e]]
== [a b [c d] [e [f]]]
```



[1:20:34](#jXFvdkXu6ooOrh6t1zCNaNUdFWIXJxTWwc400miOB0I) <gltewalt (Greg T)>:
* how's this for a `unique-each` ? (Or maybe some other name)
```
unique-each: func [blk [block! hash!]][
    forall blk [
        case [
            string? blk/1 [blk/1: unique blk/1]
            block? blk/1 [blk/1: unique-each blk/1]
        ]
    ]
    head unique blk 
]

list: make hash! [a a ["BBB" ["cc" [d d]]]]
>> unique-each list
== make hash! [a ["B" ["c" [d]]]]
>> unique-each [a b b [c c] ["dd"]]
== [a b [c] ["d"]]

```

[1:23:06](#exWfvJYb57-L16BWGTkjpBaEQI_URjEfkYDR0n4csAw) <gltewalt (Greg T)>:
@toomasv @greggirwin 

[4:35:01](#bgPTY5BpRTcsLYRlTP2L0m_NYIOOOY4Xv2OBpGXDbIM) <greggirwin (Gregg Irwin)>:
What about adding `/deep` to something like this, so it's generalized?
```
change-all: func [
	"Change each value in the series by applying a function to it"
	series  [series!]
	fn      [any-function!] "Function that takes one arg"
][
	forall series [change/only series fn first series]
	series
]
```

[4:53:45](#3P_LwNcvwxn0_TZZ4oX-PZqdW0A0qI7ZlhNwTW9Noqg) <gltewalt (The other Greg)>:
I cant recall atm if unique accepts all series. 

[5:12:48](#u3N-LtqTbYtj-m7sm2DfCFUdMvvU1aT5OoWr28CTYmU) <gltewalt (The other Greg)>:
There's a valley that lies between generality and specificity, and the shadows that it holds befuddle my sense of direction 

[5:39:45](#51tfOAyppETwDkYk1A_2QMX_fhRNbWrIkkoicQb0xDA) <gltewalt (The other Greg)>:
An aside, the code that I formatted above via that browser looked fine, but through matrix it's all wonky.
What do you see?

[6:07:33](#WdQF_u2GYxeMm9Vnne5i1dn9uFH6WFg5EY0x58uNSNw) <greggirwin (Gregg Irwin)>:
Looks fine on Gitter.

Even if `unique` doesn't (it's `[hash! block! string!]`), HOF wrappers don't have to be concerned with that. It's on the user to match their data to their funcs.

[6:16:47](#1PLDdAM3kH9hiqGLp1K-7OKpHLY-2_2MPvtJtsWYlf0) <gltewalt (The other Greg)>:
When's the right time for generality? Do you have graphs or things that aide you with the decision, or is it a matter of a lot of experience?
What guides you?

[15:31:51](#UE2MphWRx5NEOKUwheOqJROMyo6UNRAfZ4vmWuL85DI) <toomasv>:
Some time ago I added two bits to rosettacode: [sieve of Eratosthenes](https://rosettacode.org/wiki/Sieve_of_Eratosthenes#Red) and [prime generator/checker/counter](https://rosettacode.org/wiki/Extensible_prime_generator#Red). Any improvements to these?

## 13-Jan-2022

[0:48:03](#7L2RriJe4BUZc02QH04GPROcCfR1LBJMJA_arDhSpBE) <gltewalt (The other Greg)>:
I'm not qualified to suggest anything with math. 
If we had Ranges, it would be even fewer lines, though

[0:48:48](#CDJd0jd4t1qDH9Cy8gGvI99j0InLTtWGPHkJ77pkung) <gltewalt (The other Greg)>:
Bitset is efficient 

[1:47:04](#BK0MiJBvU4Ca2T-RQxmexpthiy2U4uBpdgLwDYVmgbU) <gltewalt (Greg T)>:
What is `q` in it?

[1:47:25](#5kH5iZY_GaUxmE5y2ympFP_RrsscddzPrc9T9L83tTs) <gltewalt (Greg T)>:
```
primes: function [n [integer!]][
   poke prim: make bitset! n 1 true
   r: 2 while [r * r <= n][
      repeat q n / r - 1 [poke prim q + 1 * r true] 
      until [not pick prim r: r + 1]
   ]
   collect [repeat i n [if not prim/:i [keep i]]]
]
```


[6:28:51](#EW7dg9hjUa_doKv32lpRSQL-_T4vqyREbxtNbytjHAU) <toomasv>:
@gltewalt Thanks for looking into it! `q` is traversing over bitset, `r` is last prime found, `n` is top until which to look for primes.

[7:30:09](#fr8hYr0xcyhJBf1PpV7mjP_Q5Q7TnSOjioowxJeBMcg) <gltewalt (The other Greg)>:
Oh that's embarrassing. I hardley ever use repeat, and forgot that it sets iterator word. 
I was thinking "where did q come from?" lol 

[7:33:22](#b2s2Uld-B_mT5u4xACgxFzpPvXLR-_v_gobTXrEbwgI) <gltewalt (The other Greg)>:
A gui version would be cool, and could post animated gif for the result example  if rosetta site allows them.
Similar to this:

[7:33:44](#ah-FtrrBWoUau70kBSbmIuqgijUcamnWqSkKLzG0ksA) <gltewalt (The other Greg)>:
![](https://matrix-client.matrix.org/_matrix/media/v3/download/matrix.org/mPQAwiaRBdzfvJlxSnwGISXW)

[7:40:38](#f_qxzUqCiEwjzEbpNq4PsuV_q6uJ9DdtBJa37i4-yGA) <gltewalt (The other Greg)>:
Loop <number> 
vs.
Repeat <word> <number>

[7:48:40](#AAkD-mFA38SzVebAQEJBvvFw0oq3XBdI4YqJV-tdQjs) <toomasv>:
Nice visualisation!

[12:22:48](#ejCd8izjeVYcm0XDxe0emR_h9nbqN7OCvJalpzVmHuY) <toomasv>:
Challenge accepted:
[![sieve](https://toomasv.red/images/Animations/sieve.gif)](https://toomasv.red/images/Animations/sieve.gif)

[12:26:33](#aShZVLjcYBeyQif8c4G1wmbv58rqyonYtLuTcgleXPk) <pekr (Petr Krenzelok)>:
Excellent :-)

[12:26:45](#eASbauxkAArfg6hnEowVlfs5YHLqLMO1NhzZZPE8Pv4) <rebolek (Boleslav B≈ôezovsk√Ω)>:
yes, really nice :)

[12:28:26](#Ha3MmHxm1kU4KLh2KW4nV6IVieT_I-EB5xOzh-nlCZ4) <hiiamboris (NOT THIS ONE)>:
Ì†ΩÌ±è

[12:41:06](#XnTh5y5rcf3eLZK57fir6Nvbx_OnUxyKSHs4PxMeo_M) <toomasv>:
Thanks! Here is another:
[![sieve2](https://toomasv.red/images/Animations/sieve2.gif)](https://toomasv.red/images/Animations/sieve2.gif)

[13:03:33](#ckOjnJl5LykKoA_OA-j8eUjJkX7Ina0plvWzKwYwTio) <hiiamboris (NOT THIS ONE)>:
this is cleaner

[13:05:36](#8lqUcZGdot-HTYvRgoXpgwlRzT7-kdrhOLbKv2o_xEY) <gltewalt (The other Greg)>:
Yes, the second one

[13:12:42](#zQSC2cONdYNmnaJWa1AJ30mZ_8kvL7IleJLGXojWi6A) <toomasv>:
Agreed. And, sorry, one more - primes up to 1200 in 30 cols:
[![sieve3](https://toomasv.red/images/Animations/sieve3.gif)](https://toomasv.red/images/Animations/sieve3.gif)

[14:51:33](#sNAWPWOhlwGGGBSM9w5BeWjlWFKmLA0aHNGNe95gBpk) <gltewalt (The other Greg)>:
Awesome 

[15:26:07](#H7_sikohbexjEo_3YMowC890K0GI9nAHA1D6Pipe4c0) <toomasv>:
:)

[19:39:21](#XBp5jcTEHhjHPrAMkZ3_MDdvtm0YlhucCsF5q4E13I8) <greggirwin (Gregg Irwin)>:
This would make a great blog entry.

[21:02:43](#xKN_q9VNmS-o6qel2jyTt2BZIXWauvwKCn6L2B_3334) <toomasv>:
This was an exercise with diagram dialect, at least partly. Not ready for blogging yet.

[21:03:49](#ZDvLtKVhm3q8OTaH83AJri8YT6ctk_cZuArceWBeEK0) <greggirwin (Gregg Irwin)>:
Ooooh. Now I'm *really* intrigued. It's something I wouldn't have imagined could be done, which is great. 

## 17-Jan-2022

[7:36:54](#XtJWQ3Vb2mkyLxa3R6rFn0TVc1sMSg9Q9Hl9aR3NlUE) <gltewalt (Greg T)>:
anyone want to fix this, or make it shorter or prettier?
https://rosettacode.org/wiki/Go_Fish#Red

[15:38:19](#LE8dXNnt4b6S0O9PHClx8M3c8BXGhlsSgkieyaH1fms) <greggirwin (Gregg Irwin)>:
Is there a way in RC to see which tasks are viewed most often? Those are where we'll get the biggest ROI.

[19:27:21](#YS1z93nI0xeS0h60XIdh0dpwwPFfdIT5WRXIYwIjxXk) <gltewalt (The other Greg)>:
I dont know

[19:38:34](#gzqV-Xo_vYv7_RPsbAO55ML4Qhj1gWXH0AILG-pnlrg) <hiiamboris (NOT THIS ONE)>:
tried google? https://www.reddit.com/r/ProgrammingLanguages/comments/lj48jw/rosetta_code_tasks_ranked_by_most_language/

[19:41:49](#OXxFl_0oy2uIS2RxpQ3UDaSbQeTc-DglQctPie-WwA4) <gltewalt (The other Greg)>:
No I hadn't because I've been busy

[20:01:02](#p9lhkoEQzxH6-WF5vJpWCbsc7KzLoDzsdWXjkhrD4Jo) <greggirwin (Gregg Irwin)>:
That doesn't say how often they're *viewed* though.

[20:16:21](#OWWdmU1snRmTX81XtO-emSNQjWAaljKT18UlBJUV1BA) <hiiamboris (NOT THIS ONE)>:
indeed, but it must correlate

[20:28:29](#yzUIH5QHzcDw0UQ-2f38Yu9oe5RQa1KReCjF7jEV6jQ) <greggirwin (Gregg Irwin)>:
I don't think so. It may even be inverse. That is, the less langs that have it the more we stand out, and the harder those tasks may be, showing us off more. The goal is to be seen more, not be in the most crowded places.

[20:36:34](#FAVW9vtKczo4bzEwVR2_bChS4Fe6ilWQ5AogpRTfXmQ) <hiiamboris (NOT THIS ONE)>:
Showing off doesn't correlate, in fact to show off we should pick the simplest tasks I think, where Red strikes with one-liner, a few max.
But how often they are viewed should correlate with how often someone adds a solution.

[20:37:46](#pABUZNJdiNSleigqVQqceBvVGIvjNA5epSx-d8VuTkY) <greggirwin (Gregg Irwin)>:
Popular solutions are what were the easiest to do I imagine. Hence `hello world` far in the lead.

[20:38:34](#pi-EtuUhsFORZSHYgBYqiZTwBn_B_keb118fKNfX5G8) <gltewalt (Greg T)>:
There are a lot of the easiest in the most viewed. Except for the sieve

[20:39:23](#pMv9jOAI9SB0L7Hsbgs5G3TuE-d5Fj2w6shxCYA7fGg) <greggirwin (Gregg Irwin)>:
So there is a most viewed filter?

[20:39:39](#08nuOZ2X3EUj8WCCKuhXru9FW8i2KXaGyGgFbkBLBFQ) <greggirwin (Gregg Irwin)>:
* So there is a most viewed filter/page?

[20:40:47](#Vv5e2QMu1xCPDeMRHnG3JgVF57p1PDHk0hUhOfo7hss) <gltewalt (Greg T)>:
Oh, not viewed.  But.. correlation

[20:45:43](#AdvH3AEDpfSpHzd2IL8tjvh2w24wWcNo1zteyBeQUYs) <gltewalt (Greg T)>:
How useful would something like this be to you if it was "built in"?
```
equal-length?: function [
    v1 [series!]
    v2 [series!]
][
    equal? length? v1 length? v2
]
```

[20:51:20](#vibBBuT6odaG7bVNdfbuldUPAHA-tZwXyJ8vODQYdkw) <ne1uno (ne1uno)>:
Red‚Äè‚Äé (154 members) Rust‚Äè‚Äé (852 members)  they turned it into a task

[20:51:20](#x46DbNZX3pQuO_tBnfgRJgIFvPMDZ0YXNZElJRZoq-4) <ne1uno (ne1uno)>:
https://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_number_of_users

[20:52:48](#FK-v44v2YoCzr9Bb76viM97Cde1nCxxz1X2WYvnqnSE) <greggirwin (Gregg Irwin)>:
@gltewalt I can only say I don't have it in either my Red or R2 series libs. So probably nut much value to me as standard.

[20:53:35](#SaHCtQlYU2K2tsIKXXqjg61uJguFr-vABVj04MbIlYI) <ne1uno (ne1uno)>:
return [-1 0 1 ]  less equal or more

[20:58:58](#w3Me-d46bLgblIbFhwN6Nl70WNQ83SJpZiSnAE8l6XA) <gltewalt (Greg T)>:
How about the REBOL `array` function? That seems handy.
`array/initial 10 'closed`

[21:04:36](#rYpEGzHPV2NMV-JWzagjnVHdxsg8VF9XVrJIz7X7ZN0) <greggirwin (Gregg Irwin)>:
`Array` has come up. I have a Red version. It's an unfortunate name, because it's simply prefilling/allocating.

[21:13:29](#xRcrSl6O_4n4ndKLZ28XQWgngOyiKh1ienfDcvyNuJw) <gltewalt (The other Greg)>:
https://rosettacode.org/wiki/Category:Solutions_by_Programming_Task

[21:18:18](#rt_cym84G38YroJ-JR195HFxpJAlrEaUlCXbrLgsxg8) <gltewalt (The other Greg)>:
Could pick what should be the hardest programming tasks, and see how Red does

## 18-Jan-2022

[0:12:36](#E3zDV7Kd2-r7negVRZWiB3dh46w6Fb2b9kWQhQV2QNA) <gltewalt (Greg T)>:
Is this valid for the 24 Game?
There's already an entry for it, but I thought I'd try with simple `parse`

https://gist.github.com/gltewalt/6a8d71ad7f87b6b8cbfed8203fab6f34

[0:14:49](#co52ZLGArjgiXacnfVGmP_MZS-fIMMAyHy8hU5ZYMzk) <gltewalt (Greg T)>:
strictly left to right

[0:40:27](#Nn6ilX71BdW3jMyY17KE58p69FE6vtaQJ3EKMywr_Z4) <ne1uno (ne1uno)>:
`random/seed now/time/precise`

[2:03:36](#fJo0DSG9Zw4szqYTWFILVZSsoXBbjEgr4fpELI3QeBc) <gltewalt (Greg T)>:
I don't think seeding is necessary because it allows for repeated numbers?

[2:33:34](#-8CM-2C2VmkuZRdLR1NhXbRkqzdgn4dkHFIwCZ5bH_o) <ne1uno (ne1uno)>:
not seeding/seeding with known seed is sometimes useful to repeat sequences while debugging. usually you want more random in a game

[4:16:00](#JpddFIyrkww2ycDuWx8nMX1rQDPlDLbLUZJqcXaCrlA) <gltewalt (The other Greg)>:
Seems like the one that is already posted could be less wordy.

https://rosettacode.org/wiki/24_game#Red

[9:24:14](#kQoFf_8pMWDlBs34ceVH9OeWELPWC_uBXk3tQ4j27fc) <hiiamboris (NOT THIS ONE)>:
Red seeds by default

[12:29:46](#5dBw7h8kgZka5dPSG_MDtNzXQE99LOXFwYoFAV9M8H4) <ne1uno (ne1uno)>:
^habit

[13:03:10](#7JjWn228aREfeg2vzX1IGFSpmKOZZq9ecZihDBCKlss) <ne1uno (ne1uno)>:
work in progress https://usercontent.irccloud-cdn.com/file/rmkwcU2N/mandala-3d.png

[13:04:49](#59GXG2zwY2J9iImnzitBnKXSPorhZw4vpWDJz8vIgkQ) <gltewalt (The other Greg)>:
Ì†ΩÌ±ç

[14:50:47](#cWHV2sms2JHW6oK-7wFE8MhFIXS3w8f0PPVtintPWdw) <toomasv>:
@ne1uno Interesting! 

[17:15:27](#KJlqRFwWWqAkIpY7gJk3pWNe5AnijfWAwidOU3W-vGc) <gltewalt (The other Greg)>:
If it seeds by default it hasn't behaved like it. Based on recent experiences.

[17:21:08](#5QPyIs3bfOG32Y-1QsS-3-j71EBG1nlkw9fAvkrMTqg) <hiiamboris (NOT THIS ONE)>:
confirmed, it regressed

[17:33:09](#aVgVU3eZSLOX9srjhMWxkvdTvPgA_-KFbjRAv-p7x88) <hiiamboris (NOT THIS ONE)>:
actually I can't find any commits that seeded it, nor a build that seeds automatically

[17:33:33](#evS6oUYvoPUYmTNhrXVxjKIcsm9UtN8yIAhXGm_mJMo) <hiiamboris (NOT THIS ONE)>:
but I have a strong memory that at some point we switched to auto seeding

[17:33:50](#Zd2tswvVMk7Bx3IgwlhHN9dFnixK2uSU_Ny4M4T2e2U) <hiiamboris (NOT THIS ONE)>:
so don't mind me I am probably a visitor from parallel universe anyway :)

[18:12:34](#bll3YCZAZcYMiSEpIRxnBAF47EGDaoM1XtmYTfr16eg) <gltewalt (Greg T)>:
Well you could be right, or it was on a "to do" list

[19:38:31](#Yv3meX9Sae1zniBOLqOswtdrBRBKseHvEqVv19CY05s) <greggirwin (Gregg Irwin)>:
AFAIK Red follows Rebol and always starts with the same seed. If you want to randomize, you have to do that yourself. There was a whole R2 thread, long long ago, about what seed was best.

[19:46:13](#tDTn8jwGx3wdVg4xRozkN374GlnnMZaN7Lvg0iz_Y2w) <hiiamboris (NOT THIS ONE)>:
but surely seeding is more user friendly, don't you think? we're not in 80s

[19:46:28](#9__w0L8EzlAV_9N3t6vtZUVkFqSBNjtrRSxgzDMVFnA) <hiiamboris (NOT THIS ONE)>:
* but surely auto seeding is more user friendly, don't you think? we're not in 80s

[20:04:47](#zt9hiR0fpWmaosASUesEHVYf-3upJnORbdVmX5va9Q0) <greggirwin (Gregg Irwin)>:
I don't remember if there was a reason Carl chose not to, but it does seem like the better choice today.

[20:05:10](#re2EUBxYPPYqnxRsYgYMJdKJ-UeEH5q_87xIis-DLtU) <greggirwin (Gregg Irwin)>:
It does help when testing, but that's where seeding yourself also makes the intent clear.

[21:58:23](#PxK7I3z6Pk5k8v5VpjiVnXqfqf1sTKdKUS7cgWV6Omc) <Respectech (Respectech)>:
I vote that for `random` auto-seeding should be the default and user-seeding should be the option.

[22:53:31](#ieCzjnbfCLJKPAuyMx6TqpPDCav2WNwUGK9HmQ6fzOI) <greggirwin (Gregg Irwin)>:
It's possible that Carl didn't do it because it was another thing to do on startup, and he wanted Rebol to start as instantly as possible. CGI was a big use case at the time, which he mentioned more than once.

[22:54:02](#a9AIRGJceXt3mBbjp8ZfqbHrivB_D0MQl3b-dkpC7lc) <greggirwin (Gregg Irwin)>:
Also why there were so many kernel options to build against when encapping.

[23:41:12](#BTiF5kVw7m2rAQM03zuOaoZwaw9iKxrJIzyfRwme3Fw) <hiiamboris (NOT THIS ONE)>:
hmm it's like 1/100000000th of program's startup time or what? ‚òª

## 19-Jan-2022

[0:04:31](#sCQLaUU6ittMbg-bfUZzDPpj00HVOX2CTDUlF24CJWo) <greggirwin (Gregg Irwin)>:
Old habits die hard.

[0:13:06](#L8QlQZbba-Q25ZDxYMNynQzLBb987dWuyoBc8rr_9GM) <ne1uno (ne1uno)>:
there is no universally available random source. leave seeding to users gives them the actual options.  do any languages call them any thing other than pseudo random?  being slightly more random conveys a false sense of security. 

[0:14:30](#wDqnGtWAcD9D8fPjnAZQlLQ06I_QWNo-WqhegdZXZEQ) <greggirwin (Gregg Irwin)>:
Red offers the basics (Mersenne Twister and `/secure`), and users can always write their own. If a new one becomes popular enough, it can be added as a refinement.

## 3-Mar-2022

[20:29:53](#hOXkDv79Or_PI9_fvc_Fw1t0w6PRbWIQCx8YNXwPkKg) <ne1uno (ne1uno)>:
https://github.com/red/red/wiki/red-run-checklist

[20:44:10](#aJnSNS4ZvGWjC79O2pgm4C98ni0uEZsOe1KP83xI9qQ) <greggirwin (Gregg Irwin)>:
@ne1uno :+1:

## 18-Jul-2022

[17:27:02](#VW6IaX5833Qfcst-CMI0zQJczHnDJ2YQPIPIkF8X-f4) <GiuseppeChillemi (GiuseppeChillemi)>:
I often use code as scratchpad: if I have an idea and I am in the editor, I test the idea where I am actually coding, just between a section a note.
To avoid having any interference creating words, I isolate the section and execute it with with:

```
isolating: func [
	"Executes a block with all locals"
	body "The body (WARNING: Modified by Bind)"
] [
 body: function [] body 		
 do body
]
```

So you can:

```
x: 33
isolating [x: 99 "... my code here"]
probe x
> 33
```

Just to share with you to see if you like this one.

[17:27:31](#qFWdna3kGH8I2iFKBPenmlcFBugizmcQqgWgwHvu2Bk) <GiuseppeChillemi (GiuseppeChillemi)>:
* I often use code as scratchpad: if I have an idea and I am in the editor, I test the idea where I am actually coding, just between a sections where I can put it.
To avoid having any interference creating words, I isolate the section and execute it with with:

```
isolating: func [
	"Executes a block with all locals"
	body "The body (WARNING: Modified by Bind)"
] [
 body: function [] body 		
 do body
]
```

So you can:

```
x: 33
isolating [x: 99 "... my code here"]
probe x
> 33
```

Just to share with you to see if you like this one.

[17:29:49](#f_oFofH7BDKc1moFouzyXyo58EuGS6vIgGUNGhIr-JI) <GiuseppeChillemi (GiuseppeChillemi)>:
* I often use code as scratchpad: if I have an idea and I am in the editor, I test the idea where I am actually coding, just between a sections where I can put it.
To avoid having any interference creating words, I isolate the section and execute it with with:

```
isolating: func [
	"Executes a block with all locals"
	body "The body (WARNING: Modified by Bind)"
] [
 body: function [] body 		
]
```

So you can:

```
x: 33
isolating [x: 99 "... my code here"]
probe x
> 33
```

Just to share with you to see if you like this one.

[17:30:02](#x19kapaAmLmbVmJi1L7A8pvN6MvoLTJCfAU257xj9-c) <GiuseppeChillemi (GiuseppeChillemi)>:
* I often use code as scratchpad: if I have an idea and I am in the editor, I test the idea where I am actually coding, just between a sections where I can put it.
To avoid having any interference creating words, I isolate the section and execute it with with:

```
isolating: func [
	"Executes a block with all locals"
	body "The body (WARNING: Modified by Bind)"
] [
 body: function [] body
 body 		
]
```

So you can:

```
x: 33
isolating [x: 99 "... my code here"]
probe x
> 33
```

Just to share with you to see if you like this one.

[17:34:10](#hNQaWUIhxha7ZUAXkZ7yWuuy1OOhqHGjsKlXZvNAkuQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* I often use code as scratchpad: if I have an idea and I am in the editor, I test the idea where I am actually coding, just between a sections where I can put it.
To avoid having any interference creating words, I isolate the section and execute it with with:

```
isolating: func [
	"Executes a block with all locals"
	body "The body (WARNING: Modified by Bind)"
] [
 body: function [] body
 body 		
]
```

So you can:

```
x: 33
isolating [x: 99 <... my code here>]
probe x
> 33
```

Just to share with you to see if you like this one.

[18:08:54](#qRgmzTfgKmU1hIN25zG1-qwwV6qT9Xf5645YQdMgAGI) <rebolek (Boleslav B≈ôezovsk√Ω)>:
very nice example

## 19-Aug-2022

[19:16:45](#ic2nQco-c6VmK-r8d_J4Z_hqIHhtG9AM_0HGRI1Ilcc) <GiuseppeChillemi (GiuseppeChillemi)>:
I have created a little [sort-by-length](https://gist.github.com/GiuseppeChillemi/8574182a514e0c32f1ab2ece0f60a497) function:

It normally sorts from smallest to biggest
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length inn-data
;---RESULT---
["a" "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It could be reversed
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length/reverse inn-data
;---RESULT---
["aaaaaaaaaaa" "aaaaaaa" "aaa" "a"]
```
It generates an error if the other elements are not of the same datatype of the first one:
```
[inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length inn-data]
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: block!
	expected: string!
```
...But a `/safe` refinement exists to sort any kind of series

```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length/safe inn-data
;---RESULT---
["a" [1] "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It throws an error if a datatype which is not a series is found
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data 1
probe sorted-series: sort-by-length inn-data
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: integer!
	should be a SERIES!
```

Note: `throw` does not work in Red but a printout is generated at the error point 

Any suggestion is welcome. Actually, it returns a copy of the original block and does not sort in place.


[19:17:24](#qGq6UkgxpNW_6r1CzERcFp2_MWkOr41O0mXzUUr_weE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have created a little [sort-by-length](https://gist.github.com/GiuseppeChillemi/8574182a514e0c32f1ab2ece0f60a497) function:

It normally sorts from smallest to biggest
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length inn-data
;---RESULT---
["a" "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It could be reversed
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length/reverse inn-data
;---RESULT---
["aaaaaaaaaaa" "aaaaaaa" "aaa" "a"]
```
It generates an error if the other elements are not of the same datatype of the first one:
```
[inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length inn-data
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: block!
	expected: string!
```
...But a `/safe` refinement exists to sort any kind of series

```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length/safe inn-data
;---RESULT---
["a" [1] "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It throws an error if a datatype which is not a series is found
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data 1
probe sorted-series: sort-by-length inn-data
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: integer!
	should be a SERIES!
```

Note: `throw` does not work in Red but a printout is generated at the error point 

Any suggestion is welcome. Actually, it returns a copy of the original block and does not sort in place.


[19:18:41](#KP3Fqi5mocf9D7F_TdzXEaR-pp2Xc4n08wiWrMI6Oug) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have created a little [sort-by-length](https://gist.github.com/GiuseppeChillemi/8574182a514e0c32f1ab2ece0f60a497) function:

It normally sorts from smallest to biggest
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length inn-data
;---RESULT---
["a" "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It could be reversed
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length/reverse inn-data
;---RESULT---
["aaaaaaaaaaa" "aaaaaaa" "aaa" "a"]
```
It generates an error if the other elements are not of the same datatype of the first one:
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length inn-data
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: block!
	expected: string!
```
...But a `/safe` refinement exists to sort any kind of series

```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length/safe inn-data
;---RESULT---
["a" [1] "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It throws an error if a datatype which is not a series is found
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data 1
probe sorted-series: sort-by-length inn-data
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: integer!
	should be a SERIES!
```

Note: `throw` does not work in Red but a printout is generated at the error point 

Any suggestion is welcome. Actually, it returns a copy of the original block and does not sort in place.


[19:19:19](#u6xgCLUAbxUBxMcWDgMbZVIlD0X16RHgFVSvpTvmdhc) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have created a little [sort-by-length](https://gist.github.com/GiuseppeChillemi/8574182a514e0c32f1ab2ece0f60a497) function:

It normally sorts from smallest to biggest
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length inn-data
;---RESULT---
["a" "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It could be reversed
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
probe sorted-series: sort-by-length/reverse inn-data
;---RESULT---
["aaaaaaaaaaa" "aaaaaaa" "aaa" "a"]
```
It generates an error if the other elements are not of the same datatype of the first one:
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length inn-data
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: block!
	expected: string!
```
...But a `/safe` refinement exists to sort any kind of series

```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data [1]
probe sorted-series: sort-by-length/safe inn-data
;---RESULT---
["a" [1] "aaa" "aaaaaaa" "aaaaaaaaaaa"]
```
It throws an error if a datatype which is not a series is found
```
inn-data: ["aaa" "aaaaaaa" "aaaaaaaaaaa" "a"]
append/only inn-data 1
probe sorted-series: sort-by-length inn-data
;---RESULT---
Function: Sort-by-Length
	Element at index: 5 is: integer!
	should be a SERIES!
```

Note: `throw` does not work in Red but a printout is generated for the error condition 

Any suggestion is welcome. Actually, it returns a copy of the original block and does not sort in place.


[19:25:45](#gnAIj52HouZe_d-AwDUXOKoFxZ9sCJczVy3j9GYL37M) <hiiamboris (NOT THIS ONE)>:
Generalize it to `sort-by series any-function` and make a REP.

[19:28:00](#d0C_2dbK1-lQ_wqWgKJI1TsCCRJIFzq4tmqU8RZsi4k) <greggirwin (Gregg Irwin)>:
Why not use `sort/compare`? Scanning quickly so I may miss something.

[20:36:39](#NAvXsVGeK_e4qZVn3pvwDSzWcFc2fRVbs8Yq9XHVx-M) <gurzgri>:
That's the way to go I thought of too reading this, @greggirwin @GiuseppeChillemi 
```Red
>> by-length: func [a b] [sign? subtract any [length? b 0] any [length? a 0]] ()
>> sort/compare ["aaa" "aaaaaaa" "aaaaaaaaaaa" 1.2.3.4 "a" #[none] [1]] :by-length
== [none "a" [1] "aaa" 1.2.3.4 "aaaaaaa" "aaaaaaaaaaa"]
```

[20:44:01](#cpSrNTNrKq6pipkn6dKsbEDcRWwCtSqoBXDty7FlrCU) <hiiamboris (NOT THIS ONE)>:
Still a good idea. Why doesn't `/compare` accept unary functions?

[20:44:37](#fbN_qRICP3iFbK_gUYcqpXR1S138fFdsB3eJpPeth_s) <hiiamboris (NOT THIS ONE)>:
* Still a good idea. Why doesn't `/compare` accept unary (any-)functions?

[21:26:00](#SuR68FULM4klSv49RiCiiXDTp6iI25rnIeZjv0V23a4) <greggirwin (Gregg Irwin)>:
Doesn't the func need to know the *two* items being compared?

[21:26:42](#yUlUDa196EouuxY-R1P0TbNJ4L1N-G8y0LBKKUSoaSc) <gurzgri>:
```Red
by-func: func [fun [any-function!]] [get in context [f: :fun g: func [a b] [case [greater? a: f a b: f b [-1] lesser? a b [1] true [0]]]] 'g]
>> sort/compare [0 45 90 135 180 225 270 315 360] by-func Ì†ΩÌ∏ñine
== [270 225 315 360 180 0 45 135 90]
>> sort/compare [0 45 90 135 180 225 270 315 360] by-func :cosine
== [180 135 225 270 90 315 45 360 0]
```

[21:30:37](#Apq4cw-5o_jgQwWO89J5hzT1DPtJoa0FMJaSBfKtccE) <gurzgri>:
It needs to know *how* the two items should be compared (by which measure). That's not something which is easily derived from arbitrary unary any-functions. Best / canonical thing is a per-datatype order. Don't know how useful that might be in practice.

[21:31:22](#iS-KYkh9EiXg1pUasJZSpYwE5IU_XAsiijebIfg8gtk) <gurzgri>:
* It needs to know *how* the two items should be compared (by which measure). That's not something which is easily derived from arbitrary unary any-functions. Best / canonical thing is probably a per-datatype order. Don't know how useful that might be in practice.

[21:34:40](#s4PBosm4vIYOtiJixrBmR2YQhPeS8Q69Zg2TvDINWHA) <hiiamboris (NOT THIS ONE)>:
Piece of cake. Let `sort` given `unary-func` call it with each item it compares and compare resulting values with each other.

[21:34:56](#pl_0MlzvGFtzQ3MPgZV9DypPvuZyC2Qa9fJDzTq_pGM) <hiiamboris (NOT THIS ONE)>:
* Piece of cake. Let `sort` given `unary-func` call it with each item in the pair it compares and compare resulting values with each other.

[21:36:19](#sqmggLgRzAR1RNHfApme-HpQh-3ew-U42VsgIaFAcHY) <gurzgri>:
Ah, yes, now I see what you meant.

[21:37:21](#ToOUI9eoPWYACZjd3VutkItR-kcJig5xf8nD4LFiBAo) <hiiamboris (NOT THIS ONE)>:
A mockup would be `by-unary: func [f] [func [a b] [a: sort reduce [f :a f :b] :a/2 =? :b]]`

[21:47:59](#b4scnowzwKXhWongTYgzM1vvqD3yOPE0i9XARtATyFE) <hiiamboris (NOT THIS ONE)>:
`=? f :b` that is

[22:17:08](#9Lk6-amzgL5p-S9qeIP8ABDiiMj0tqBUPsPByT-BmgY) <gurzgri>:
Something like 
```Red
>> sort-by: func [values fun /local val] [extract sort/skip/compare parse values [collect [any [keep set val skip keep (fun :val)]]] 2 2 2]
>> sort-by [0 45 90 135 180 225 270 315 360] :cosine ;== [180 135 225 270 90 315 45 360 0]
>> sort-by [0 90 135 180 225 270 315 360] :random ;== [0 360 135 225 90 270 180 315]
>> sort-by words-of system/words func [word] [checksum form :word 'sha256]
== [red-system ctrl? url-parser level quiet ...
```
applies the unary functions only once per value but needs more memory.

[23:57:50](#sCfLkkznCWBemgEo84DbUKPihLRH6RfsW6o5C7VHUYo) <GiuseppeChillemi (GiuseppeChillemi)>:
> Why not use `sort/compare`? Scanning quickly so I may miss something.

Never used sort compare, I don't know I it works but I am looking at the following posts.

[23:59:36](#TXWvroWPFe440K6J7xqkFXsVwcy29ZU7SvnuEJoKGC8) <GiuseppeChillemi (GiuseppeChillemi)>:
@hiiamboris 
> Generalize it to `sort-by series any-function` and make a REP.

What does mean that `any-function`? Where should I use it?

[23:59:52](#vKJE8dz2ynOFWoFeZGsgduHLwPwH0t65lDjas0lwOVQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* @gregg
> Why not use `sort/compare`? Scanning quickly so I may miss something.

Never used sort compare, I don't know I it works but I am looking at the following posts.

## 20-Aug-2022

[13:09:09](#Hcj3lu-nGypCJRv-pL6l92brdFtkvzLv65Vw5wFTmXg) <GiuseppeChillemi (GiuseppeChillemi)>:
Could please someone explain how `/compare` works?
I suppose `find` scan each element and passes the current and the next one to the comparison function. Then if a `true` is returned it.... and if a `false` is returned it... Well, what it does? 

I have made a little experiment to understand it:

Function returning `true`
```
;===Sort/Compare Experiments
probe x: [a c d z]
f: func [o1 o2] [
	print [o1 o2]
	true
]
sort/compare x :f 
```
output:
```
[a c d z]
c a
d a
d c
z a
z c
z d
;Result
>> probe x
[z d c a]
```
function returning `false`:
```
sort/compare x :f 
probe x: [a c d z]
f: func [o1 o2] [
	print [o1 o2]
	false
]
```
Output:
```
[a c d z]
c a
d c
z d
;Result
>> probe x
[a c d z]
```
From the experiments, it seems it scans all data as supposed but, the second argument is set to the current one and the first is set to the next. If a `false` is returned, it skips to the next couple, if a `true` is returned... I really do not understand what it does!


[13:09:30](#SHELd1h_2_uSbI5T7ItCmLRkcYp8JQ2jOWsYST6V7Kc) <GiuseppeChillemi (GiuseppeChillemi)>:
* Could please someone explain how `/compare` works?
I suppose `find` scans each element and passes the current and the next one to the comparison function. Then if a `true` is returned it.... and if a `false` is returned it... Well, what it does? 

I have made a little experiment to understand it:

Function returning `true`
```
;===Sort/Compare Experiments
probe x: [a c d z]
f: func [o1 o2] [
	print [o1 o2]
	true
]
sort/compare x :f 
```
output:
```
[a c d z]
c a
d a
d c
z a
z c
z d
;Result
>> probe x
[z d c a]
```
function returning `false`:
```
sort/compare x :f 
probe x: [a c d z]
f: func [o1 o2] [
	print [o1 o2]
	false
]
```
Output:
```
[a c d z]
c a
d c
z d
;Result
>> probe x
[a c d z]
```
From the experiments, it seems it scans all data as supposed but, the second argument is set to the current one and the first is set to the next. If a `false` is returned, it skips to the next couple, if a `true` is returned... I really do not understand what it does!


[13:34:35](#M23frFHi4MwTGS5gDfmCRnt0PDmWgj-Zput-P9weZJw) <hiiamboris (NOT THIS ONE)>:
`compare` function should take 2 items and answer if they are *ordered* or not

[13:35:12](#amdKaTWaFDrBMVWBsgql-4OI6yx2J4XSQiBGMzD6Zpc) <hiiamboris (NOT THIS ONE)>:
But for stable sort the return value is more complex: -1 for unordered, 0 for equal, 1 for ordered

[13:35:55](#U-5qgoiv9TN8T-6Zke38lq0LTQZ_1Z8walW7g-LNesM) <hiiamboris (NOT THIS ONE)>:
Or vice versa. I never can quite recall the sign Ì†ΩÌ∏É

[14:16:08](#lwHLD4JO9OjUlAA3rJsNu9QhukGoQ-tEprXA0EqEua0) <GiuseppeChillemi (GiuseppeChillemi)>:
Answering false, the order does not change, maybe the question is: should it be changed? `True`: yes, `False`: no ?

[14:21:22](#tI-A8GJNrsD26JY-dh3yVGj49uNvHA_P73sWNiXm12k) <hiiamboris (NOT THIS ONE)>:
no

[14:21:49](#X8RmSHTLcIbmriARvVpDK0gopXoOqZocW_K1lRX7D5s) <hiiamboris (NOT THIS ONE)>:
```
>> sort/compare [1 8 5 3 6 2] func [a b] [ordered?: a < b]
== [1 2 3 5 6 8]
>> sort/compare [1 8 5 3 6 2] func [a b] [ordered?: a > b]
== [8 6 5 3 2 1]
```

[18:58:39](#9jGi80gbX1CnC3snn1tr2i5ZDI3UZRIAsQ9yxMHm9DQ) <gurzgri>:
Never but only now it occurred to me that for stable sorting you're not limited to 1=ordered, 0=equal, -1=unordered. truthy, none, falsey also works.

[18:59:39](#L0lay9MKC7Q6QItVRPq_W9a3VP0uyD03eiu3FYNUlBw) <greggirwin (Gregg Irwin)>:
Hah! I never thought about that. 

## 21-Aug-2022

[1:06:43](#MAcpcgY9VYZis3OYHbI0n58AIvOeCxD56MHm_YXsBDE) <GiuseppeChillemi (GiuseppeChillemi)>:
Red is infinite, even at this alpha stage. I think that even spending other 10 years, I will never know it fully

[1:06:59](#GCl3JoU7Ik1i8oritEaRNwU2fTCUVeGGwfvpiEGuflc) <GiuseppeChillemi (GiuseppeChillemi)>:
* Red is infinite, even at this alpha stage. I think that even spending another10 years, I will never know it fully

[1:07:05](#_XuUF1ijciG-PUyKvX8YxsUgS4-f6dvDXFZXt2H7acM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Red is infinite, even at this alpha stage. I think that even spending another 10 years, I will never know it fully

## 3-Sep-2022

[17:28:40](#OR1auqkMcAZQyyxm9HQ3NQKEkRHK-jV8TSY2PuTvcoc) <hiiamboris (NOT THIS ONE)>:
Playing with a simple [typechecked object](https://gist.github.com/hiiamboris/167b13603359440dea4b6a444fdb0d88):
```
>> obj: typed-object [x: 1  restrict [integer! float!] y: 2]
== make object! [
    x: 1
    y: 2
]

>> obj/x: 2
== 2
>> obj/y: 3
== 3
>> obj
== make object! [
    x: 2
    y: 3
]

>> obj/x: 'word
== word
>> obj/y: 'word
*** Script Error: type-checker does not allow word! for its y argument
*** Where: type-checker
*** Near : :new set-quiet word :new
*** Stack:  
>> obj
== make object! [
    x: 'word
    y: 3
]

>> set obj 4
== 4
>> obj
== make object! [
    x: 4
    y: 4
]
```

[17:29:55](#MYeun8aBoVa6E-PpvR1cauf4dGz9qndLn6J0PJb5eJw) <hiiamboris (NOT THIS ONE)>:
* Playing with a simple [typechecked object](https://gist.github.com/hiiamboris/167b13603359440dea4b6a444fdb0d88):
```
>> obj: typed-object [x: 1  restrict [integer! float!] y: 2]
== make object! [
    x: 1
    y: 2
]

>> obj/x: 2
== 2
>> obj/y: 3
== 3
>> obj
== make object! [
    x: 2
    y: 3
]

>> obj/x: 'word
== word
>> obj/y: 'word
*** Script Error: type-checker does not allow word! for its y argument
*** Where: type-checker
*** Near : :new set-quiet word :new
*** Stack:  
>> obj
== make object! [
    x: 'word
    y: 3
]

>> set obj 4
== 4
>> obj
== make object! [
    x: 4
    y: 4
]

>> set obj none
*** Script Error: type-checker does not allow none! for its y argument
*** Where: type-checker
*** Near : :new set-quiet word :new
*** Stack:  
>> obj
== make object! [
    x: none
    y: 4
]
```

[18:57:36](#tZ2gwTBz6AhBXZtLykjH2DmA1-ToXO7G621FGlUifn8) <greggirwin (Gregg Irwin)>:
Fun. I played with some ideas quite a while back. I started with the premise of a generic data object and a separate spec that could be applied to them, to `vet` them. You'd get back a result object that told you what was wrong, or if it passed muster. A primary use case being objects used as complex args to funcs. I never got to granular control that could be used from change handlers. Here's how it works at the coarse level.

Given:
```
sub-o: object [aa: 1 bb: 2 cc: 3 dd: 'test]
o: object [a: 1 b: 2 c: 3 s: ss: sub-o]
spec: object [
	a: integer!
	b: string!
	c: func [value [integer!]][value < 2]
	d: integer!
	s: object [aa: bb: integer! cc: string!]
	ss: object [
		aa: bbb: cc: integer!
		dd: reduce [string! file!]
		ee: [
;			< 2
;			ee >= 3             _ >= 3
;			between? ee 0 5     between? _ 0 5
;			all [>= 0 < 5]
		]
	]
]
probe vet-spec o spec
probe vet-spec/with o spec [minimize]
```
It returns the following for the test calls:
```
make object! [
    a: 'OK
    b: "Wrong type. Expected: string!"
    c: "Predicate failed: value < 2"
    d: 'Missing
    s: make object! [
        aa: 'OK
        bb: 'OK
        cc: "Wrong type. Expected: string!"
    ]
    ss: make object! [
        aa: 'OK
        bbb: 'Missing
        cc: 'OK
        dd: "Wrong type. Expected one of: [string! file!]"
        ee: 'Missing
    ]
]
make object! [
    b: "Wrong type. Expected: string!"
    c: "Predicate failed: value < 2"
    d: 'Missing
    s: make object! [
        cc: "Wrong type. Expected: string!"
    ]
    ss: make object! [
        bbb: 'Missing
        dd: "Wrong type. Expected one of: [string! file!]"
        ee: 'Missing
    ]
]
```
The `ee` predicates are just draft syntax placeholders.


## 4-Sep-2022

[10:35:47](#yHciSxQipnNE-vFmWaOav4ppCP3v5Kpw4P3TnWzdksQ) <hiiamboris (NOT THIS ONE)>:
Separate spec is a bad idea, as it will get out of sync during refactoring :)

[10:36:47](#rECS_4v4AcP4ENFf9J9EQS3cOvzfLEuRQlHuXEuvi10) <hiiamboris (NOT THIS ONE)>:
On the other hand, I do need to figure out how to have these checks per-class rather than per-object (otherwise RAM cost will be too high).

[17:42:31](#3b1GFUqFdM4JYSeYIoKelFbvlCd4ZxjxcAg5OFEyWKg) <greggirwin (Gregg Irwin)>:
> Separate spec is a bad idea, as it will get out of sync during refactoring

Different use cases. Mine isn't primarily about enforcing strict object constraints, but checking whether an aggregate arg to a func meets the func's expectations. Duck typing meets type spec.

[17:47:28](#z5kM_kmWXSHA_jwGPWRsQ6xZ87pUnsC9XqQugdWY8RA) <hiiamboris (NOT THIS ONE)>:
I will REP this topic later, as it's important and seems totally missed by Redbol.

[17:50:46](#dWQFpCmKkvaM7MJ7YZOXGRbjqYOATXV6Yt1HWO2J4P4) <greggirwin (Gregg Irwin)>:
Another use case, and why I played with returning rich information, is API use. That is, you spec an API, but have little control over what you'll get from remote callers, but want to be helpful in returning information that let's them solve problems. Can then also be used on a wider scale to check for compatibility, interrogate systems, etc..

[17:52:09](#r8s-2skGYJ84VT3_etM05U3Y5ebHupzIMCno4u8QKxs) <hiiamboris (NOT THIS ONE)>:
Good point

## 8-Sep-2022

[18:51:55](#ntvld8eX_BG7U2qVD_gE1pBtkHNiRi1sMPsDouUI7Jk) <hiiamboris (NOT THIS ONE)>:
Got an advanced implementation now: https://codeberg.org/hiiamboris/red-common/src/branch/master/classy-object.red (but not fit for API scope)

[18:53:03](#AiUltA5syyRIXQnfgJrQ5Bl47GFMATPfHQAJf9aOCok) <hiiamboris (NOT THIS ONE)>:
Type and value checking and more:
```
>> my-object1/x: 2
== 2
>> my-object1/x: 'oops
*** User Error: {Word x can't accept `oops` of type word!, only [integer!]}
*** Where: do
*** Near : types'
*** Stack: on-change-dispatch check-type

>> my-object1/y: 10000
== 10000
>> my-object1/y: -10000
*** User Error: "Word y can't accept `-10000` value, only [y >= 0]"
*** Where: do
*** Near : values'
*** Stack: on-change-dispatch check-value
```

[18:58:12](#RLwoPfehzwY_qil21Yeu-Eu8GkIf0MfwOD_E-fKzsUs) <greggirwin (Gregg Irwin)>:
Thanks for including all the design notes.

[19:05:36](#ibh20FKo8ZMcswJ-2yCJaug01wGfcJznE5KCai2y-G4) <hiiamboris (NOT THIS ONE)>:
Yeah, couldn't do otherwise Ì†ΩÌ∏â Too many different design aspects coming in touch with this.

## 23-Sep-2022

[11:10:23](#9hm_9dtua7Tnwd-lcosNHXPNyi7qN8aIzlD1zua2Ywo) <ne1uno (ne1uno)>:
I made a [little] utility script to convert to & from base 64 png image strings: 

[11:10:23](#patVbEl5_Oegqm9mSL3aWxSImTsBimHvK2xK8cA72jY) <ne1uno (ne1uno)>:
[screenshot](https://usercontent.irccloud-cdn.com/file/2zLaOKXj/b64-png-screenshot.jpg)

[11:10:23](#MX2MWgR1WW6fMTA4cQUh87kr3odAZhLifrK8ZZoLUSg) <ne1uno (ne1uno)>:
[gist b64-png-red](https://gist.github.com/ne1uno/74efc2bda96a662dbf7d8858a60cfcf1#file-b64-png-red)

[11:10:23](#CbuC7T7hhBF7o-qcbeGyDQ9leN9kMj3hFFKM-JjXmsQ) <ne1uno (ne1uno)>:
I have most things working, including from base 64 to image.

[11:10:23](#KtZ0nlyvfSFQIw8Bb3kuVxi_HVq2xm621d39WGBSHEc) <ne1uno (ne1uno)>:
code around lines 1100 in  "make to-b64 from image" button

[11:10:23](#46LQuD8myiL5dNAltuF8EsleylQyf9d1FUMpMxzkSOs) <ne1uno (ne1uno)>:
 but can't work out `encode`, kinda the whole point of program. what am I missing?

[11:10:25](#3Nq3SxBTanZhKYWKCF_08LoOTAooULNdI_0g0Lx5zUM) <ne1uno (ne1uno)>:
I tried `encode img/image` `encode img/image/rgb` and directly from `%image.png`

[11:10:26](#E_KQvIdUGI9kJ5kQnD_wZJkMS7c7vqqBXIfMvbyCFpU) <ne1uno (ne1uno)>:
shorter example in comments at end of gist

[11:31:19](#egN_ec3DIYP-OjQn-nhx0nq3eUOGyrvvKbFv3hDwZcw) <hiiamboris (NOT THIS ONE)>:
since you're `load`ing, you should also `save`.

[12:39:13](#CLebpaBNf4Q67WofE-YatX7HRFCwfbfEcrKsVGcAGas) <ne1uno (ne1uno)>:
`enbase save/as copy ""  i/image 'png`  ;closer, still no

[12:52:57](#i4OtwvVw4qa4e47_ZOWEqxgGq0WqkIKfNd_StPlQRcw) <gurzgri>:
```Red
>> probe system/catalog/accessors/image!
[size argb rgb alpha]
>> img/argb   ;-- #{FF0000FFFF0907...
>> enbase img/argb ;--  {/wAA//8JB/
```

[12:53:03](#8EGOEuYIno7ESR1ws8bfzThj1JaKtacy_eSw5n24U1Q) <gurzgri>:
maybe?

[12:53:16](#VVMtjaFpmuH9Iw3BRvG9-Snm0gzTtee2x8p_IpqPT6w) <gurzgri>:
* ```Red
>> probe system/catalog/accessors/image!
[size argb rgb alpha]
>> img/argb   ;-- #{FF0000FFFF0907...
>> enbase img/argb ;--  {/wAA//8JB/...
```

[12:57:45](#b_pP-TPdhw8AJfvOs4vNCrBTSgNhWpeKvhqqzo3lasA) <gurzgri>:
Most problably not, though. More like `enbase read/binary %image.png` I guess.

[12:58:47](#Zojbl2UOfsXakU6FLkP1Xji8Mb7NqpUyHH4b94J6xrI) <hiiamboris (NOT THIS ONE)>:
or `save/as copy #{}`

[13:39:12](#0CycngvfUdsJ3-2Ya2vvGge5SzMherLH3p4noxY_vWY) <ne1uno (ne1uno)>:
`enbase save/as none i/image 'png  ;worked!`  thanks for `probe system/catalog/accessors/image!` too.  , will update gist when my internet is less flaky.

[15:23:45](#UdHAVqDmo5Rl1GpT-0LFnUuqZewQmjlJrcpbUJ6RkUM) <gurzgri>:
You're welcome. For clarification I'd like to point out that for a image already loaded `save/as none i/image 'png` is the same as `enbase read/binary %image.png` for an image not loaded but read in binary. The difference you had to cope with here is the one between the binary on-disk file format and the image as represented in-memory as a Red datataype. You want to `enbase` a file format, not Red's in-memory image.

## 5-Oct-2022

[16:00:34](#f56JpADhQBMNnRIDwlmLFjoqt28qyANSmIBH3piEV2A) <toomasv>:
Playing with [SPARQL](https://gist.github.com/toomasv/201b445e115d1aba7caae2d4943bea7e)

[![SPARQL](https://toomasv.red/images/SemanticWeb/sparql.gif)](https://toomasv.red/images/SemanticWeb/sparql.gif)

[20:51:45](#lSTi-WB2p3jxFxoSxTScBVmNl10RQQBQ3OSCjDPVvk8) <Respectech (Respectech)>:
That's really neat!

[20:53:21](#PZrRm4OPT_e0NuvQttIzROdSckcvU1HhJFkAfUsxaP4) <GiuseppeChillemi (GiuseppeChillemi)>:
Wow, great work!

[20:53:43](#92sovxARF0AlP4NivIx9zS3au6lPmlkSi37zxjUsITs) <GiuseppeChillemi (GiuseppeChillemi)>:
Fantastic as always, Toomas.

## 6-Oct-2022

[4:11:38](#ExB5Jyyt-TvTfLQ9GvEOiKj_jdTjIDK8PFfqowyM66s) <toomasv>:
Thanks, guys! Red still amazes me :)

[16:06:18](#Zo44Fly39vHyEQP6s6roESkHAV5804KlB-JHtJtrjVQ) <greggirwin (Gregg Irwin)>:
Good stuff as always @toomasv. :+1:

## 15-Oct-2022

[18:07:56](#B8zPEwdF0rNEXifisJdi_18PXWhICfsOR8pRZdmlfTo) <hiiamboris (NOT THIS ONE)>:
[Extended `function`](https://codeberg.org/hiiamboris/red-common/src/branch/master/advanced-function.red) in action:
```
>> probe f: function [/ref x: 1  [integer! (x >= 0) string!]  (find x "0")] [x]
;;                            ^default     ^check for integer  ^fallback check (applies for string)
func [/ref x [integer! string!]][
	switch/default type? :x [
		none! [x: 1] 						Ì†ΩÌ∏â applies default when X is not given
		integer! [							Ì†ΩÌ∏â integer type check
			unless (x >= 0) [
				do make error! form reduce [
					"Failed" "(x >= 0)" "for" type? :x "value:" mold/flat/part :x 40
				]
			]
		]
	] [
		unless (find x "0") [				Ì†ΩÌ∏â fallback type check
			do make error! form reduce [
				"Failed" {(find x "0")} "for" type? :x "value:" mold/flat/part :x 40
			]
		]
	] 
	x										Ì†ΩÌ∏â actual body starts...
]
```
@GiuseppeChillemi IIRC you wanted some parts of this, I think defaults for locals or something...


[18:10:47](#weLEYcdV9kr19zFcWCL2W90B4OVX-oQw72mi3AcKe3k) <greggirwin (Gregg Irwin)>:
Very nice @hiiamboris.

[18:12:49](#9eCGFHFGouDe4y6HvquHNqpTOcBIsB7VbCXusIcLKpo) <GiuseppeChillemi (GiuseppeChillemi)>:
@hiiamboris Great Work!

[18:51:24](#M2SS--njmWUic2MLcU6x02kGOlCZEIJfWqx1uDxcpuk) <greggirwin (Gregg Irwin)>:
It seems like a short wrapper for `do make error! form reduce` would be worth it, given how much code this could be used. I understand that its primary use is not code generation, per se, but even if `make error!` supports string interpolation someday, it seems worth it. 

[19:10:20](#cAr1BQ8jTO1mkaA-LdL29ENcAdV1SOfSfU19UwVtCJQ) <hiiamboris (NOT THIS ONE)>:
I'm using `ERROR` as you know in the code I write manually. For generated code, I care less.

## 4-Dec-2022

[0:05:36](#gbNKP7dP8CyzbsZucHeVsi_eX8RfL2wFT5E9z-t8ZPA) <ne1uno (ne1uno)>:
>Fully automated solving & submission for #AdventOfCode¬†using #OpenAI¬†text-davinci-003

[0:05:36](#eIV6jjz6mQ0LyfQPaUHmvw362PaUFP8SuhgHyWx-sa4) <ne1uno (ne1uno)>:
https://twitter.com/ostwilkens/status/1598458146187628544

[0:05:38](#QWoXvhjzczVAVNvdwo54jxW56XmNVUtUiuyYy9u89tI) <ne1uno (ne1uno)>:
10 seconds is the new time to beat

## 27-Feb-2023

[18:12:42](#3MITIRa0bk2rZkx0uuGBq8GuoFiZtBDcATl908WREB4) <toomasv>:
Looking through the magnifying glass
[![magnifying-glass](https://toomasv.red/images/Varia/magnifying-glass.gif)](https://toomasv.red/images/Varia/magnifying-glass.gif)

[18:21:38](#60GoZEIDB-TfIEmZ7nQkDhOjQ50ggotJlmr8CPiIkDc) <hiiamboris>:
can you upload the pic? not visible

[18:41:17](#TZwuY9UvMWxIzrm_Xh39fd8NwK1ogVaU7gawqzn6IgA) <toomasv>:
https://toomasv.red/images/Varia/magnifying-glass.gif

[18:41:59](#KeDzPQDd0RjfmvONh8OLCgtJYwBWfnN97k5CU5hrb-A) <toomasv>:
 * Can you see this: https://toomasv.red/images/Varia/magnifying-glass.gif

[18:42:08](#UPbqP5kCEfRXvc1qlKWbsJw2sDk-qeBLlhAcGY7X9uQ) <toomasv>:
 * Can you see this? https://toomasv.red/images/Varia/magnifying-glass.gif

[19:02:23](#D0DyZRCjffu02mWwME73Qz_wrp6XnFMhpA9mrV33Peo) <hiiamboris>:
cool!

[22:04:03](#G-3dlxV_gquglum-M0EA-3YQSmVotctmj4kzCFO09iw) <greggirwin (Gregg Irwin)>:
Very nice!

## 1-Mar-2023

[1:44:16](#bwI_PnCp89nuke7EANvl8x_1lUy0vYgWYgr6WbR91og) <GaryMiller (GaryMiller)>:
I did not see the Magnifying Glass handle at first. So my mind was thinking Eye in the Pyramid like the Eye of Horus but it did not look like an Eye and then I saw the handle and it clicked.

[18:45:32](#7vaIHLK-fpNdiSWBHGSACAzt0LvmN6mqMB5Y1TqNb4k) <toomasv>:
Upgraded: https://github.com/toomasv/magnifying-glass

## 14-May-2023

[16:45:29](#NC6yamh7DrNp7sZjH0SnQz4XARgjuCBPNHPGDJN2DrM) <GiuseppeChillemi (GiuseppeChillemi)>:
Hi, when you create a function inside another one, it is created at each run. What about this approach to reuse it? Do you see any problem?

```
inner-function: func [
	"Create an inner function that is reused between each run without need to be created each time"
	value "A test value"
	/local
	test-function
] [
	
	test-function: [
		func [
			val
		] [
			either :val = 25 [
				Print ["Condition met, val is: " :val]
			] [
				Print "Condition NOT MET!"
			]
			
		]
			
	]
	
	if not function? :test-function/1 [insert head test-function first reduce test-function  clear next head test-function] 
	
	case [
		block? :value [
			forall value [
				test-function/1 value/1
			]
		]
		true [
			test-function/1 value
		]
	]
]


inner-function 10
inner-function 25
inner-function 10

probe :inner-function

>>> inner-function 25
Condition NOT MET!
Condition met, val is:  25
Condition NOT MET!
func [
    {Create an inner function that is reused between each run without need to be created each time} 
    value "A test value" ....
```

[16:46:49](#VGTLzYi1psPYoHJ0vf24PsfIE5XMpE5P9WlYE37QSMU) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Hi, when you create a function inside another one, it is created at each run. What about this approach to reuse it? Do you see any problem?

```
inner-function: func [
	"Create an inner function that is reused between each run without need to be created each time"
	value "A test value"
	/local
	test-function
] [
	
	test-function: [
		func [
			val
		] [
			either :val = 25 [
				Print ["Condition met, val is: " :val]
			] [
				Print "Condition NOT MET!"
			]
			
		]
			
	]
	
	if not function? :test-function/1 [insert head test-function first reduce test-function  clear next head test-function] 
	
	case [
		block? :value [
			forall value [
				test-function/1 value/1
			]
		]
		true [
			test-function/1 value
		]
	]
]

;----- TESTS 
inner-function 10
inner-function 25
inner-function 10

probe :inner-function

---- RESULTS ------
Condition NOT MET!
Condition met, val is:  25
Condition NOT MET!
func [
    {Create an inner function that is reused between each run without need to be created each time} 
    value "A test value" ....
```

[16:47:01](#drbr0JcwBRjNF_jbqGeZXQ4d2ebJokCeGtpoqB5ZlDM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Hi, when you create a function inside another one, it is created at each run. What about this approach to reuse it? Do you see any problem?

```
inner-function: func [
	"Create an inner function that is reused between each run without need to be created each time"
	value "A test value"
	/local
	test-function
] [
	
	test-function: [
		func [
			val
		] [
			either :val = 25 [
				Print ["Condition met, val is: " :val]
			] [
				Print "Condition NOT MET!"
			]
			
		]
			
	]
	
	if not function? :test-function/1 [insert head test-function first reduce test-function  clear next head test-function] 
	
	case [
		block? :value [
			forall value [
				test-function/1 value/1
			]
		]
		true [
			test-function/1 value
		]
	]
]

;----- TESTS -----
inner-function 10
inner-function 25
inner-function 10

probe :inner-function

---- RESULTS ------
Condition NOT MET!
Condition met, val is:  25
Condition NOT MET!
func [
    {Create an inner function that is reused between each run without need to be created each time} 
    value "A test value" ....
```

[17:36:23](#vcm0LPGF10CIWdKqjX09FvCjdnOAz5hDm7VzaMejSCs) <hiiamboris>:
it's much easier to move the inner function out, but yes this will work

[21:51:20](#3opK6qBKoTVLN2EuaRkS_V-ZnxnNETo5Is5m2Xjdq1g) <GiuseppeChillemi (GiuseppeChillemi)>:
I know but I liked to experiment into having persistence of a function without the need to recreate it at each function call. 

[21:51:33](#kkyK34dg6IWtTXEtdPcpPp3e89pzB-PU_JE-3fTONXA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I know but I liked to experiment having persistence of a function without the need to recreate it at each function call. 

[21:51:46](#DySo1h3bqNOqj1232icS5a7W2LSDP-YAIoJsms6HXjw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I know but I liked to experiment having persistence of a function without the need to recreate it at each container function call. 

[21:57:15](#0HDfjvYKjsQeQH8xyd_E98wyznGwCdMlEWzLIHbaWKQ) <hiiamboris>:
```
>> f: func [x] [g]
== func [x][g]
>> g: does with :f [print ["F/x is " x]]
== func [][print ["F/x is " x]]
>> f 420
F/x is  420
```

## 15-May-2023

[4:59:21](#8S1I1FbpDIvWJlbBJofarqRz_iy1EqrlOM8pzkN-eiM) <greggirwin (Gregg Irwin)>:
`with` isn't standard yet hiiamboris, but the idea holds.

[5:00:32](#bSa05ExQ_v5b1ZvnR2SyRp0t68fCc0XmRC3Mw5ivJmE) <greggirwin (Gregg Irwin)>:
GiuseppeChillemi (GiuseppeChillemi): it's in Boris' codeberg %red-common/with.red.

## 27-May-2023

[21:03:55](#UrVwJH9-vIn63NQWxHFeKtH1i6wa4PDb1QZWTHm5MB0) <hiiamboris>:
greggirwin (Gregg Irwin) do you have any useful design notes on the [match function](https://codeberg.org/hiiamboris/red-common/src/branch/master/match.red) ?

[22:18:20](#v_tat02NPmSF_PCj_0qAHJZOEHMO0Nwg4I6I_VGYD1A) <greggirwin (Gregg Irwin)>:
- I'm all for wildcard matching support. toomasv did a regex translator, but I don't think we want to encourage it for mainstream Red use.
- In the long-ago, MS had a product called `Test`, which had some nice programming-level features. One was `FileList`, which built lists of files from glob specs. *Really* handy IMO, and why I did a version for R2, also in the long-ago. Times have changed, but file systems are still ubiquitous and with the same basic metadata to query. I see them as a primary use case for this functionality.
- Along those same lines, and used by them, are things like AWK and grep. Matching within content after matching file names. I think you know that while I want basic AWK/grep (and a ReddyBox app/portable shell), I also want them to work at a higher, Red value level, for IPC and more.
- For `match`, `*?` cover the bulk of use cases, so that's a good place to start. Digit matching, e.g. `#`, less so, but I use ISO8601 naming a lot, so I have a bias for it. 
- Since it returns logic, should it be called `match?` ?
- In the grand scheme, we want a matching/pattern dialect that can be used widely.


- https://gist.github.com/greggirwin/0e9085af43984f1fdf400498ba8ceb11
- https://gist.github.com/toomasv/58040ccbbfb70150dee90ba0e27b16b8
- http://www.rebol.org/view-script.r?script=file-list.r
- https://gist.github.com/greggirwin/6397bdfe8e9e7dd9f3d543bc4b0e570c
- https://gist.github.com/greggirwin/2dfe6bc45f596592c890b52d1d7f9475


[22:25:42](#LPql2xcWirqaBR6EoRRCV_eTh8mtcBI6Z-cgT2ozR8k) <hiiamboris>:
Thanks. I can't figure out even the scope of features for it.

## 28-May-2023

[1:48:41](#vi0sSjNP5jKkdYkTC-wrFzJxWGdtx6UB6UvBQoT9m1s) <greggirwin (Gregg Irwin)>:
It's a tricky problem in general, because we want a reasonable number of powerful functions, but can't overload them too much for everyday use, since we want that easy and obvious. I read John Ousterhout's book, A Philosophy of Software Design, and makes a similar point about writing deep modules with small interfaces. Too deep, and you can't follow the abstractions and module-level complexity; too shallow and connections explode. This is the same problem I thought about a lot for `split`, which probably originated in the lengthy and discussion over `round`. It's a shame the mezz level `round` was so slow, because it was wonderfully dense. OK, maybe a little too dense in the end, but wow. :^) I fought for the consolidated design, but Ladislav Mecir was the brains behind the implementation. With `split` I can see the hybrid approach working, and why I did that in my new version (main func dispatching to specialized funcs for each type of splitting), but `match` could go in a lot of different directions.

e.g. `find-while` underlies other `*-while` funcs in my HOF experiments.
```
find-while: function [
	"Find leading items that match test; return last found index; zero if no matches."
	series	[series!] "(modified)"
	test	[any-function!] "Test (predicate) to perform on each value; must take one arg"
][
	n: 0
	repeat i length? series [
		either test pick series i [n: n + 1][break]
	]
	n
]
```
That's functional, but in light of something like your `count` func, and new features supporting it, this could be much more accessible and flexible.

[1:50:03](#udxG1swZO7zPPdLI1dNNdb9mCocHstHLp4edU28henI) <greggirwin (Gregg Irwin)>:
And things like this:
```
find-all: function [
	"Returns all positions in a series that match a test."
	series [series!]
	test   [any-function!] "Test (predicate) to perform on each value; must take one arg"
][
	collect [
		forall series [if test series/1 [keep/only series]]
	]
]
```
Where we want multiple results, but maybe we want its location vs value.

[1:55:35](#as75AsgtQRkcR9Mh88ghWsLERB5hcnGpIB_K2t6hIog) <greggirwin (Gregg Irwin)>:
And think of `filter/partition/transform`, or even `remove-each` which applies `remove`. Could be `remove/at match-each blk pattern`. I don't want to become a *more* functional language, but I do want to leverage things as best we can. A few strong pilings in the foundation, and we should be able to get the tower up faster.

[8:52:38](#I9iGNsVbrVP0X-J5b5arbMUPkm0UpFISNXTz8dPRxfQ) <hiiamboris>:
I guess what match is lacking the most then is slices

[18:30:45](#eT71VR9L_YVbxB-7YI1aW_5rQ6XRZc8qzDNVKRFbiuA) <greggirwin (Gregg Irwin)>:
Can you give me an example of what you mean? I know what slices are, but how you see them relating to `match`.

[18:33:26](#C0xNuZanlEcaCzrReElH5XiRCtJ1Ihi9BUs4Q2Aszso) <hiiamboris>:
Take the `find-all` as an example. If you find all the locations, how do you know where they end, so you can do something with them?

[18:35:00](#MEkg3Nrt_veReFarx_T0C_ApFk42jH2vt6FC88cskQQ) <greggirwin (Gregg Irwin)>:
Ah, I see. Good thought.

[18:35:50](#3DWWhGARUP9yOWT7NolQR_AGMC04hmp0kxNTcD8yjlE) <hiiamboris>:
And then there may be intersections...

## 31-May-2023

[23:44:50](#-y6cbGmxh9tohToAycNyU6tSww8YSp8o-pxjiJzxfEk) <zentrog>:
I really love the functional way of doing things, but I've been experimenting with this `where` function that's a bit more hybrid... I guess I really just want to get rid of the function argument.

```
where: function [
    {Return a new series containing items for which the predicate 'matching'
    evaluates to true.
    When the predicate is a block, individual items will the the first arg if
    the block starts with an op!, otherwise the last arg}
    items [series!] matching [block! any-function!]
][
    unless any-function? :matching [
        matching: function [_] 
            either all [word? val1: first :matching op? get/any val1][
                head insert :matching '_
            ][
                append :matching '_
            ]
    ]
    collect [foreach item :items [if matching item [keep/only item]]]
]

items: [1 2 3 4 5 6 7 8 9 10]
blocks: [[] [123] [1 2 3] []]
other: [a 3 x 2 y]

probe where items [> 4] ; >> [5 6 7 8 9 10]
probe where items [even?] ; >> [2 4 6 8 10]
probe where items :even?  ; >> [2 4 6 8 10]
probe where items [find other] ; >> [2 3]
probe where blocks [not empty?] ; >> [[123] [1 2 3]]
```

I thought about having `_` as a general placeholder for the predicate block if the front or back doesn't work, but so far I haven't thought up a case where I would need it yet, and there is still `func` for that, and it just feels kind of messy to me anyway. But I like how these examples end up looking.

## 1-Jun-2023

[3:00:14](#8DaTmUeEcm8Y7sPzNWHpes8lOENO-POYREuySC8hTSY) <greggirwin (Gregg Irwin)>:
Yes, this is where we may end up having two parallel models. The functional approach, and the `-each` approach, `where-each item items [item > 4]` that avoids the placeholder issue and makes things explicit.

## 26-Aug-2023

[23:19:34](#TcTboC5cnBcVKrcuw4Vno0XoFZSyMghtJUECjD3tKw4) <GiuseppeChillemi (GiuseppeChillemi)>:
An experiment to mimic `object!` like protos for `map!`
```
compose-proto: func [
	proto [block!] {A prototype with SLF available inside to mimic objects} 
	/local 
	temp-ctx 
	key 
	sub 
	step
	value
] [
	step: 2
	temp-ctx: context [slf: #()]
	bind proto temp-ctx
	block: proto; for further use
	while [not tail? block] [
		key: block/1
		sub: block/2
		either any [set-word? key word? key string? key integer? key float? key ] [
			value: do sub
			put temp-ctx/slf key value
			block/2: value
			block: skip block step
		] [
			;manage error here
		]
	]
	proto
]

probe make map! compose-proto ["a" (100 + 101) "b" (slf/"a" + 10 + 50)]
```


[23:20:01](#ETZk59LwcW2XZHXfns1yDfGBbd_J_u4y8J4GzdmsROY) <GiuseppeChillemi (GiuseppeChillemi)>:
Result:

```
#(
    "a" 201
    "b" 261
)
```


[23:25:11](#8_mo6CmEh9uW-iu9R_VSTBs38yYTstlKA6VXIS428vM) <GiuseppeChillemi (GiuseppeChillemi)>:
To be done: 
add `quote` management after keys to indicate the parens must not be avaluated
Error management
Prototype validation
more?


[23:25:22](#RrGhAruA6bJoKF8Mg5q_Gkm4csRlW9pXbV65R_QXqvg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * To be done:
* add `quote` management after keys to indicate the parens must not be avaluated
* Error management
* Prototype validation
* more?

[23:27:54](#dNGJ2kx2aIwSneNkA3rM-4ypllcntlgSRMoEip-pSpg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Everything inside parens will be evaluated but as composing advances, the keys are available for for calculation. SLF object will be lost after the last processing when the map will be ready. 

To be done:

- add `quote` management after keys to indicate the parens must not be avaluated
- Error management
- Prototype validation
- more?

[23:28:34](#kBD9j2iXy1bcBth9ue-VC0nEJoRpXA-PlDV7G67LKSk) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Everything inside parens will be evaluated but as composing advances, the keys are available for for calculation. SLF word will be lost after the last processing when the map will be ready.

To be done:

- add `quote` management after keys to indicate the parens must not be avaluated
- Error management
- Prototype validation
- more?

[23:28:45](#tQMTLbBk-8xRE2VJKwokKxGPQpXE6IeBUmmHdjwtajE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Everything inside parens will be evaluated but as composing advances, the keys are available for for calculation. SLF word will be lost after the last processing when the map is ready.

To be done:

- add `quote` management after keys to indicate the parens must not be avaluated
- Error management
- Prototype validation
- more?

[23:28:55](#uhSUQBElRsKlPq6w7DxLd9j2IQMhJBv1p4IEHLvmC98) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Everything inside parens will be evaluated but as composing advances, the keys are available for for calculation. SLF word will be lost after the last processing when the map is ready.

To be done:

- add `quote` management after keys to indicate the parens must not be avaluated
- some error management
- Prototype validation
- more?

[23:29:00](#Py7ALpN6AZzOZGwQK0rlMM4HduodtOI8ob4bWRe28TU) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Everything inside parens will be evaluated but as composing advances, the keys are available for for calculation. SLF word will be lost after the last processing when the map is ready.

To be done:

- add `quote` management after keys to indicate the parens must not be avaluated
- some error management
- rototype validation
- more?

[23:30:16](#F5ahGRJLBfPv97OYViYmt618qu5Qg6EySw0ISAUza3Q) <GiuseppeChillemi (GiuseppeChillemi)>:
 * An experiment to mimic `object!` like protos for `map!`

```
compose-proto: func [
	"Composes a block making keys avaliable when their value is evaluated"
	proto [block!] {A prototype with SLF available inside to mimic objects} 
	/local 
	temp-ctx 
	key 
	sub 
	step
	value
] [
	step: 2
	temp-ctx: context [slf: #()]
	bind proto temp-ctx
	block: proto; for further use
	while [not tail? block] [
		key: block/1
		sub: block/2
		either any [set-word? key word? key string? key integer? key float? key ] [
			value: do sub
			put temp-ctx/slf key value
			block/2: value
			block: skip block step
		] [
			;manage error here
		]
	]
	proto
]

probe make map! compose-proto ["a" (100 + 101) "b" (slf/"a" + 10 + 50)]
```

[23:32:37](#EP0if15Z0gHeRWyTgq5pYuFKCPEepZ0AOd8JULcqvl4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * An experiment to mimic `object!` like protos for `map!`

```
compose-proto: func [
	"Composes a block to build map, keys avaliable when their value is evaluated"
	proto [block!] {prototype with values inside parens. SLF is available to access keys and mimic objects} 
	/local 
	temp-ctx 
	key 
	sub 
	step
	value
] [
	step: 2
	temp-ctx: context [slf: #()]
	bind proto temp-ctx
	block: proto; for further use
	while [not tail? block] [
		key: block/1
		sub: block/2
		either any [set-word? key word? key string? key integer? key float? key ] [
			value: do sub
			put temp-ctx/slf key value
			block/2: value
			block: skip block step
		] [
			;manage error here
		]
	]
	proto
]

probe make map! compose-proto ["a" (100 + 101) "b" (slf/"a" + 10 + 50)]
```

[23:33:06](#b5ud_aV8lkOvXCqKm4azSVP-CcqNvfrx5qOK-nvZkkE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Everything inside parens will be evaluated but as composing advances, the keys are available for for calculation. SLF word will be lost after the last processing when the map is ready.

To be done:

- add `quote` management after keys to indicate the parens must not be avaluated
- some error management
- rototype validation
- more?

What you think about it? Suggestions?

[23:33:26](#6fxzErYhcPy1kC86Ef_7iZPv2urzVi6GSIu0SjVzS50) <GiuseppeChillemi (GiuseppeChillemi)>:
 * An experiment to mimic `object!` like protos for `map!`

```
compose-proto: func [
	"Composes a block to build map, keys avaliable when their value is evaluated"
	proto [block!] {prototype with values inside parens. SLF is available to access keys and mimic objects} 
	/local 
	temp-ctx 
	key 
	sub 
	step
	value
] [
	step: 2
	temp-ctx: context [slf: #()]
	bind proto temp-ctx
	block: proto; for further use
	while [not tail? block] [
		key: block/1
		sub: block/2
		either any [set-word? key word? key string? key integer? key float? key ] [
			value: do sub
			put temp-ctx/slf key value
			block/2: :value
			block: skip block step
		] [
			;manage error here
		]
	]
	proto
]

probe make map! compose-proto ["a" (100 + 101) "b" (slf/"a" + 10 + 50)]
```

[23:33:55](#ko1U5OF3GGS_ojrwlrlYQ83OocuA5Y9kLZKiFmtNj2c) <GiuseppeChillemi (GiuseppeChillemi)>:
 * An experiment to mimic `object!` like protos for `map!`

```
compose-proto: func [
	"Composes a block to build map, keys avaliable when their value is evaluated"
	proto [block!] {prototype with values inside parens. SLF is available to access keys and mimic objects} 
	/local 
	temp-ctx 
	key 
	sub 
	step
	value
] [
	step: 2
	temp-ctx: context [slf: #()]
	bind proto temp-ctx
	block: proto; for further use
	while [not tail? block] [
		key: block/1
		sub: block/2
		either any [set-word? key word? key string? key integer? key float? key ] [
			value: do sub
			put temp-ctx/slf key :value
			block/2: :value
			block: skip block step
		] [
			;manage error here
		]
	]
	proto
]

probe make map! compose-proto ["a" (100 + 101) "b" (slf/"a" + 10 + 50)]
```

## 27-Aug-2023

[7:54:37](#lI55ruj-muJL5_Y4bQgnRmSFkDgXdPmTtQPwwE-5rAg) <hiiamboris>:
why not just `make map! compose ["a" (a: 100 + 101) "b" (a + 10 + 50)]`?

[10:24:50](#Tc3E1RXTceEL-RA0Ew8ZydTa_mcnVhwlGHZDE1m5J1o) <GiuseppeChillemi (GiuseppeChillemi)>:
Because it will be used for foreign DB tables that could use column names not convertibile to words. Also, such names are unpredictable so they need to be isolated. This prototype will be stored inside a "table" object, and each time a row will be created it will be used.

[10:27:37](#MZ_joyfnWCJe2dpiAGOCID8v8MU_9zhi_ECZGGBJuZY) <GiuseppeChillemi (GiuseppeChillemi)>:
Regular words will be used to pass parameters to the prototype for init. 

[10:47:21](#RlkDSC77jz8IQ0e5Go_fHeX2ZW9YCThFaxjj-JK4sPM) <hiiamboris>:
at least rename `slf` to `row` maybe

[10:54:06](#OV-PurkAxx_kg0pN7vJi-OXc3jUl5-ZkUCzjwj9aZB4) <hiiamboris>:
why do you modify the prototype?

[10:57:33](#-eahhid6Kw_vSVaHsR3xi_8dx7kN9pIP6rI0BozhJXo) <GiuseppeChillemi (GiuseppeChillemi)>:
For "modify" do you mean having additional words or something else? 

[11:00:23](#EzZNr8yrdfst7M4vwHBnS8yZr4LdeaWhSC_F6QWLFtQ) <hiiamboris>:
`block/2: :value`

[11:07:36](#aIGpf3hGVO4b_srlmoeDfxLtchcrjSY-PDpwCDUD4D8) <GiuseppeChillemi (GiuseppeChillemi)>:
It is temporary. The idea started with compose in mind, so you return back the provided block. 

[11:09:16](#o49LVTGMSb9xFJ3byGR43VI3XqjDJkQo_luSHu7aDnA) <GiuseppeChillemi (GiuseppeChillemi)>:
But it really must be independent as it is a template/prototype

[11:23:47](#-RA7X2qUV7z0FpNLcMrQt3GAH1RugpVO08gXQ52Cltk) <hiiamboris>:
```
>> ctx: context [row: #()]
>> compose-proto: function [proto [block!]] [
[    	also clear ctx/row
[    	foreach [key val] bind proto ctx [ctx/row/:key: do val]
[    ]
>> compose-proto ["a" (100 + 101) "b" (row/"a" + 10 + 50)]
== #(
    "a" 201
    "b" 261
)
```
why make a mess then?

[11:29:16](#rxpJrR8atWJ6746DianRsT94X9wBCTqFm8LPBvnifU8) <GiuseppeChillemi (GiuseppeChillemi)>:
Because it is was evolving idea. My interest was to show the concept.

[17:07:42](#egJv17JdlfF44Z_baStfOtkEK1_TRGltbV1b3_CkKRM) <greggirwin (Gregg Irwin)>:
In a use case like this, where you need quite a bit of control over how things work, there likely isn't a simple solution. So it will be a variant of something like this. Whether you want to keep it simple, as in Boris' approach, or allow more flexibility is for you to decide.

[17:08:08](#Ayhbhwr2dHtq8cFywAv9QfCgvi1FUO7mSQkm5MGQsoM) <greggirwin (Gregg Irwin)>:
`slf/"a"` does make me think of parens in paths, and how closely strings are related to that.

[17:40:13](#ibcqJVuBQnJFpQgL8O7lXzxtriVMOahNE-_i8lcnHQ8) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> In a use case like this, where you need quite a bit of control over how things work, there likely isn't a simple solution. So it will be a variant of something like this. Whether you want to keep it simple, as in Boris' approach, or allow more flexibility is for you to decide.

Boris solution has allowed me to know about ALSO and its use cases.



[17:40:49](#tl57KbqEkbdnGJIHZ0GpuPrA-ODCWvttHJRBqcZtZm4) <GiuseppeChillemi (GiuseppeChillemi)>:
I have extended it with parte of my code for some checks.

[17:43:39](#JOQ5UC4bc0Y0fjXJNJ-O6TP7yS4Rl-slAYPWOT67CsY) <greggirwin (Gregg Irwin)>:
Anytime `also` comes up I feel obligated to mention how much I don't like it. :^) It's a very clever function (Gabriele came up with it), but I think it makes code much harder to understand.

[17:45:04](#GUEHKdUHCni5HSxWf0LUtV7hpsnjk3G-yPTb7ybx5vE) <GiuseppeChillemi (GiuseppeChillemi)>:
Also my idea contains 2 more ideas. The map is very useful to experiment creating contexts which have other type of keys than words. I could create a string where some words have values and reduce them

[17:46:17](#8FzMsg0b3klmNsnaLbPI1sv5KurXjluM7PU_lw4cFRU) <GiuseppeChillemi (GiuseppeChillemi)>:
The "quote" keyword is my attempt to do a conditional composing having words before partens.

[17:46:26](#OvYhihY4r4TRTePXrPmlNLJag51jfk660lFLpqaM5R0) <GiuseppeChillemi (GiuseppeChillemi)>:
* The "quote" keyword is my attempt to do a conditional composing having words before parens.

[17:47:37](#73pdn5WuRGF37clqc9mwafQo6sKArtYYwT1C90aDT_M) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> `slf/"a"` does make me think of parens in paths, and how closely strings are related to that.

What does let you think? 

[17:50:10](#ba3Rst9R9qLcUuuvUQT9Wp5aSfaPNWzQHF1ONjFXbMU) <greggirwin (Gregg Irwin)>:
@dockimbel doesn't like parens because they could be abused by being long, and let paths contain spaces. Strings do the same thing, but without line breaks (other than `^/` literals in the string).

[18:12:25](#XxIbk6XtTNVM2hG6wlFxBoznE2HIuMs8mmONoth7d8s) <GiuseppeChillemi (GiuseppeChillemi)>:
Parens create very short and portable lines where you don't have to use additional WORDS to store the parens code result. Also I am using them for custom paths DSL, because you can use parens to add parameters to the path.

[18:13:43](#8W6CMGGIg1q_42NfQ13OYttrb78GvYpQ8JoO-PfaorM) <GiuseppeChillemi (GiuseppeChillemi)>:
Think about a path with 2 parens and you will need 2 more words for each path.

[18:43:36](#ZOzPvKKKHgjeAxTrBJ6YkBW6olsCQ5bH3p_cXNuhSMc) <hiiamboris>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> @dockimbel doesn't like parens because they could be abused by being long, and let paths contain spaces. Strings do the same thing, but without line breaks (other than `^/` literals in the string).

I recently came to think that even worse part of parens is that `get path` becomes a side-effectful operation.

[18:45:56](#ctPSGzSKHaNBA8KCwcTDv91eDocSWDnBTzrz-w6v2Wg) <hiiamboris>:
`>> get 'system/(quit)`

[18:47:31](#Sq9mvtMKewoCYmYcfstEktoNMIYfhvyDeWKaWS_IlgA) <hiiamboris>:
They're good for `/(i + 1)` or `/(sub/path/selector)` cases but I wonder if there's a better alternative we haven't found yet.

[18:51:58](#SzhCblG6BMBh6P77GhXXOBNtn_C-zYFjUHGhbjI21bY) <hiiamboris>:
I have 16 cases of parens in path in common and spaces that fit into the above categories. And two function calls `/(type?/word :x)` and `/(class? obj)`.

[19:04:48](#cxfNVgcQJysWONqrYNy8YRvC-KWbw-etSJp4EdpM1ao) <hiiamboris>:
* I have 16 cases of parens in path in `common` and `spaces` that fit into the above categories. And two function calls `/(type?/word :x)` and `/(class? obj)`.

[19:34:39](#ZP8QGGXSOOOwDQcSwp4s8e63vwIBBQwLrslQeEkkdF8) <gurzgri>:
> <@hiiamboris:tchncs.de> They're good for `/(i + 1)` or `/(sub/path/selector)` cases but I wonder if there's a better alternative we haven't found yet.

Ouch, harmful side effects are a very strong argument against parens in path, never thought about these!

[19:36:13](#ZhZmG4suXf0fWdu_8bQmh1jiK6i7vIu73PrNvXWpGD0) <GiuseppeChillemi (GiuseppeChillemi)>:
Have you tried to parametrize the path? Put a function in parens which accept arguments and the bind it to a context containing them. You will then like them a lot and ask that bind accepts paths other then blocks

[19:36:30](#qnDDmZK0nsUkqMrvh0NzJGTZjAYJkgkowsOImHKhcq4) <GiuseppeChillemi (GiuseppeChillemi)>:
* Have you tried to parametrize a path? Put a function in parens which accept arguments and the bind it to a context containing them. You will then like them a lot and ask that bind accepts paths other then blocks

[19:36:45](#Dtd8Zqb3bKGBSNivKUfIVTskVbMBF2mSr8ATCSXHAOY) <GiuseppeChillemi (GiuseppeChillemi)>:
* Have you tried to parametrize a path? Put a function in parens which accepts arguments and the bind it to a context containing them. You will then like them a lot and ask that bind accepts paths other then blocks

[19:37:00](#559IDgGVDmBmIBfCg7ktPs9KmaJYdKJa7fGsNT0Hlr8) <GiuseppeChillemi (GiuseppeChillemi)>:
* Have you tried to parametrize a path? Put a function in parens which accepts arguments and then bind it to a context containing them. You will then like them a lot and ask that bind accepts paths other then blocks

[19:37:25](#z5uDii_M3lXufWLapO1-qu1kwrb2-psMMkoEo95Tkh8) <GiuseppeChillemi (GiuseppeChillemi)>:
* Have you tried to parametrize a path? Put a function in parens which accepts arguments and then bind it to a context containing their values. You will then like them a lot and ask that bind accepts paths other then blocks

[19:39:08](#xX47rBjMzOdeHnUAhg-7xXwklxxQf3KoQNbvSeSeTj0) <GiuseppeChillemi (GiuseppeChillemi)>:
* Have you tried to parametrize a path? Put there a function in parens which accepts arguments and then bind it to a context containing their values. You will then like them a lot and ask that bind accepts paths other then blocks

[19:41:04](#8C6p0o7O3SwsN0m045BLeV1t0ldevkFNidybw_DtiGk) <GiuseppeChillemi (GiuseppeChillemi)>:
* Have you tried to parametrize a path? Put there a function in parens which accepts arguments and then bind it to a context containing their values. You will then like them a lot and ask that BIND accepts paths other then blocks

[19:42:22](#0VdNfz2JxkkKuUrhVB5yrvVJvVtqnGJl14yvedzK2zE) <greggirwin (Gregg Irwin)>:
`get 'system/(quit)` seems like it shouldn't evaluate. Have to think more, but that is indeed perhaps the worst thing about them. Still, we can do that *kind of* thing many ways in Red.

[19:44:10](#7_UIo90UUTNI2IiTlA1LX3nVnjZoXmZGzEagreS92M4) <GiuseppeChillemi (GiuseppeChillemi)>:
Also, there is a totally unexplored area of DSLs for paths where parents are very helpful. I think even blocks should accepted.

[19:45:38](#zhhVnEOpf-cMgB4jF5FdWSityT0_GLVXMugulqrhoPQ) <greggirwin (Gregg Irwin)>:
I stumbled upon dialected paths in the `apply` design, and it could be a nice use case.

[20:06:12](#B3XuPKUAuChRaDg9yW2mH5z3L8RePWtOvQs_3CFkrsU) <GiuseppeChillemi (GiuseppeChillemi)>:
* Also, there is a totally unexplored area of DSLs for paths where parens are very helpful. I think even blocks should accepted.

## 29-Aug-2023

[17:48:37](#W278BWE-mY1_SS2dbYKd1tajdA0t7_hG10cxx00AtKc) <GiuseppeChillemi (GiuseppeChillemi)>:
How add a datatype to your data without writing it inside the container? Use paths!

Here is a GIF! prototype

```
gif!/(
    data: "binary-here" 
    size: 300x220 
    creation: 1-Jan-2023
)
```

Here is a table!
```
table!/(
    [ID Name City] 
    [1 "Rose" "New York"] 
    [2 "Robert" "Pisa"]
)
```


[17:49:46](#64CA39OOZp0H4q0dXWVguwL8U11YIMDhV120DYnXcaA) <GiuseppeChillemi (GiuseppeChillemi)>:
And the code to create them:

```
makes: func [
	type [word!]
	proto [block!]
	/local
	out-data
] [
	out-data: append copy quote () proto
	to-path reduce [type out-data]
]

```
probe makes 'gif! [
	data: "binary-here"
	size: 300x220
	creation: 01-01-2023
]
```

```
probe makes 'table! [
 [ID Name City]
 [1 "Rose" "New York" ]
 [2 "Robert" "Pisa" ]
]
```

[17:49:57](#YWOEDeG-ORSU3CIXYF4cVR7nuCnQanDBUd0Gg9xDNTU) <GiuseppeChillemi (GiuseppeChillemi)>:
 * And the code to create them:

```
makes: func [
	type [word!]
	proto [block!]
	/local
	out-data
] [
	out-data: append copy quote () proto
	to-path reduce [type out-data]
]

```

probe makes 'gif! \[
data: "binary-here"
size: 300x220
creation: 01-01-2023
\]

```
probe makes 'table! \[
\[ID Name City\]
\[1 "Rose" "New York" \]
\[2 "Robert" "Pisa" \]
\]

[17:50:20](#2n_mzC4ffCo2MUXM4YfyYoqjZQq0uExQx5KzxjLPOCc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * And the code to create them:

```
makes: func [
	type [word!]
	proto [block!]
	/local
	out-data
] [
	out-data: append copy quote () proto
	to-path reduce [type out-data]
]
```

probe makes 'gif! \[
data: "binary-here"
size: 300x220
creation: 01-01-2023
\]

```
probe makes 'table! \[
\[ID Name City\]
\[1 "Rose" "New York" \]
\[2 "Robert" "Pisa" \]
\]
```

[17:51:30](#0YiCPDDqjqpLevcrIAPn6Fm4xyUUXA12g-JRnweltX8) <GiuseppeChillemi (GiuseppeChillemi)>:
 * And the code to create them:

```
makes: func [
	type [word!]
	proto [block!]
	/local
	out-data
] [
	out-data: append copy quote () proto
	to-path reduce [type out-data]
]
```
```
probe makes 'gif! [
data: "binary-here"
size: 300x220
creation: 01-01-2023
]
```


```
probe makes 'table! [
 [ID Name City]
 [1 "Rose" "New York" ]
 [2 "Robert" "Pisa"]
]
```

[17:53:40](#moY1GyBQVYNjij-ru9bWqopgHZujlIh0-AMxgnwGXuw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * And the code to create them:

```
makes: func [
	type [word!]
	proto [block!]
	/local
	out-data
] [
	out-data: append copy quote () proto
	to-path reduce [type out-data]
]
```

```
probe x: makes 'gif! [
data: "binary-here"
size: 300x220
creation: 01-01-2023
]
```

```
probe x: makes 'table! [
 [ID Name City]
 [1 "Rose" "New York" ]
 [2 "Robert" "Pisa"]
]
```

[17:54:38](#_wd70Kub6H5r5Avr4fWMDLisYo7HnVTYfPKn11iJcoo) <GiuseppeChillemi (GiuseppeChillemi)>:
You can carry the path around and use `X/2` to access your `table!` or `gif!`

[17:56:25](#NB6PChw3yL-JJqhMX0qaRXxV1-EnrK7-6MakiiVStww) <GiuseppeChillemi (GiuseppeChillemi)>:
 * How add a datatype to your data without writing it inside the container? Use paths!

Here is a GIF! in combined `type!/container`

```
gif!/(
    data: "binary-here" 
    size: 300x220 
    creation: 1-Jan-2023
)
```

Here is a table!

```
table!/(
    [ID Name City] 
    [1 "Rose" "New York"] 
    [2 "Robert" "Pisa"]
)
```

[17:56:45](#KocqV2-ptQRakXNeYI6xE2WvZGwbanNCgwtDMb1z_JU) <GiuseppeChillemi (GiuseppeChillemi)>:
If paths supported blocks it would have been better

[17:59:04](#RjGw0YpzfkC0UeDIZS88cFKHT7iy5AXCs2zDDNRHDYY) <hiiamboris>:
what's the benefit over objects?

[18:02:01](#ccmrXWQjGJQCVckI4et7ksMEprCNKVEz-jKUg0IzukY) <GiuseppeChillemi (GiuseppeChillemi)>:
Just to have `/type` outside, it is useful for TABLES of block of blocks of FLAT ones, so you have the datatype outside without using words. 

[18:02:26](#IGUTxjsJHHZh1FHh2lDvXaKeihf9hpvoKrqVUtBVThI) <GiuseppeChillemi (GiuseppeChillemi)>:
It is just an experiment

[18:02:43](#tplD61FkQlQ39ycrWR1dxJQhnLWr6F2vqwxl33Hv1p8) <hiiamboris>:
I see

[18:03:15](#Urzvu9YcsTzBrLPuGw5GZA7H2KinwTPMMATWb_qK5Ko) <hiiamboris>:
an interesting one indeed

[18:04:43](#tSKXMnoTs0RPgPmb0yiG8xFvuBjsu-3tC6kHIPu5bWk) <GiuseppeChillemi (GiuseppeChillemi)>:
Does this raise usage scanarios for you?

[18:05:30](#Zi1XEQRU4KJ_k0IXq7xjsgW21lHX1N7lcoZuY1tJGEo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Does this raise usage scenarios for you?

[18:06:33](#DYqJObaFJyCqq_TFOErOtx4z2RfmSwO3aZ-5W6FkzFk) <hiiamboris>:
not yet, but it's always cool to keep unfamiliar designs in mind

[18:07:43](#S4nS5HVyax5rlUgKzAHAiyWzCp-vHwVXbwgcXikA-80) <GiuseppeChillemi (GiuseppeChillemi)>:
Have you seen the new `point4d!` ?

[18:07:48](#b8S2Of5shmAA6sOHU5LWb1Dsa6UmgMe_0dTJ6l_kwQs) <GiuseppeChillemi (GiuseppeChillemi)>:
`p: 'point4d!/(2.334 3.555 2.455 5.666)`

[18:07:54](#JxASn6BajCCgtohhWgTYrycj_9cVMPpBNTFfU8YrHLg) <GiuseppeChillemi (GiuseppeChillemi)>:
:D

[19:02:43](#vs_LwGFh_7G8-bDeqsm0BJo5YDwidWwiq4BDfZj7dco) <greggirwin (Gregg Irwin)>:
It's like a Red, structured version of URL/URN, with the content embedded.

[19:20:00](#y5DssNyOCJf07M3xOhtyhLymDC1BRXG8RhO8Q_5mIww) <greggirwin (Gregg Irwin)>:
It feels like it will be suited mainly for very small "records". Once you get into structures and more fields there's a lot of overlap with maps. In any case, it's a *very* cool experiment and shows the power of Red for creative thinking.

[19:55:34](#jvsxa8b2prTMIV2KN1iWoqjnQIetxx4I-4_BaqykcYs) <GiuseppeChillemi (GiuseppeChillemi)>:
And there something else which is not immediately visibile: if you have a management object for the data, the value of the first word could be set to it. Path are blocks, so each path could have its first word with a different management object.

[19:57:08](#mreF0ytwl19VmDXk6U8_YPcFC3ga2L2X8WdzQKDic4M) <GiuseppeChillemi (GiuseppeChillemi)>:
You just have to GET PICK PATH 1 and have the management object ready with the whole structure.

[20:04:24](#6cxPt3BVOUWT_N-nU9j_S6injgTBPVIRj3dt26m4emo) <GiuseppeChillemi (GiuseppeChillemi)>:
Each trunk of the path could carry objects, setting and finally the visibile  data itself.

[20:05:29](#cNevpyeDAuYwvZW5wKob6DHq9KSWgAGdhsUyNWRtKRw) <GiuseppeChillemi (GiuseppeChillemi)>:
Think about:
'SERVER/CONNECTION/(
   Select * from table where ...
)


[20:06:22](#SzfzZZhKmU2wKQH0qqF4GEAeFl8YF_u8NrdoeUJ7D8w) <GiuseppeChillemi (GiuseppeChillemi)>:
Where SERVER is the management object 
And CONNECTION is the connection string.

[20:23:42](#wrSVZ-i6upz34JyR9AyvC6o_bq-DTVD0saGBG-T5uwo) <GiuseppeChillemi (GiuseppeChillemi)>:
Now, Imagine a context where:

Ctx: [
     Server: mysql; management obj
     Connection: "connection string"
]

And you have a portable query. You just need to

QR: Bind as-block path ctx 

Run-query QR

(Pardon, I am on mobile and can't use code mode for texts)
     

[20:24:41](#47xpacCMiFGsq6obATJjFcjk_eCDXTAE8iqFG41O0_s) <GiuseppeChillemi (GiuseppeChillemi)>:
Rebind the path to another context and you query something else.

[20:25:22](#SAkAUEHRiJB1nxmoqEk5PGhzW5ryAkr0_9KcNGmpjjE) <GiuseppeChillemi (GiuseppeChillemi)>:
* Rebind the path to another context with different connection or management object and you will query another server.

[20:26:23](#AEod4xwtNpSGt8VaUDu4jo95QZFZKqX1LPU5eJjcNTk) <GiuseppeChillemi (GiuseppeChillemi)>:
* Rebind the path to another context with different connection or management object and you will query another server, even translating the query using code object that manages the server.

[20:26:44](#oA3SsiB_ktp_jQqYLT72zoBSZiX1sNz_JtwX0-UXNUw) <GiuseppeChillemi (GiuseppeChillemi)>:
* Rebind the path to another context with different connection or management object and you will query another server, even translating the query using code in the object that manages the server.

[20:59:04](#04dr54Ht9bbqutS6Pzt2XLXW14QJ5Cq7AryJ97paweA) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> It feels like it will be suited mainly for very small "records". Once you get into structures and more fields there's a lot of overlap with maps. In any case, it's a *very* cool experiment and shows the power of Red for creative thinking.

This is the reason I don't want parens to go away but instead have blocks too.

[22:11:10](#ydI8isWtWDoJoLiSzhqgVyPvYjV5DTyGKfN_XIAkX8s) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You just have to `GET PICK PATH 1` and have the management `object!` ready with the whole structure.

[22:11:36](#3hm5rhwPX6ncAeGaRMLgHqZdKv1b96OnsV6mS6H40ac) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Think about:
```
'SERVER/CONNECTION/(
   Select \* from table where ...
)
```

[22:12:02](#sUaLRckHUc7vBHFlBWXWrOkwj5a_QJicPq2g54LaBys) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Where `SERVER` is the management object 
And `CONNECTION` is the connection string.

[22:12:39](#c47AvPu7yJSdxSV2QPMZYs9kwABZQfifjN1Hamx0GBg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Now, Imagine a context where:
```
Ctx: [
     Server: mysql; management obj
     Connection: "connection string"
]
```
And you have a portable query. You just need to

`QR: Bind as-block path ctx `

`Run-query QR`

(Pardon, I am on mobile and can't use code mode for texts)
     

[22:13:16](#HuwgdBjV3CHkoYxSS3twARSbz7BiEF78J-0Mjmh0SeY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Now, Imagine a context where:

```
Ctx: [
     Server: mysql; management obj
     Connection: "connection string"
]
```

And you have a portable query. You just need to

`QR: Bind as-block path ctx `

`Run-query QR`

(Pardon, I am on mobile and can't use code mode for texts) Edit: Fixed

[22:22:00](#EVLjQBBueSfy-JzE73JCjGVgSeKDGFJfP5uRx6FTWZ8) <GiuseppeChillemi (GiuseppeChillemi)>:
Paths are very interesting... you can't create one with: 
```
word/#(a: 22 b: 33)`
```

But you can:

```
probe x: to-path reduce ['word #(a: 22 b: 33)]
probe x/2/a
```
Result:
```
word/#(
    a: 22
    b: 33
)

22
```


```
probe x: to-path reduce ['word make object! [a: 22 b: 33]]
probe x/2/a
```
Result:
```
word/make object! [
    a: 22
    b: 33
]
```



[22:22:50](#OonrKyGbD3oay2RR_q-qRyRjQIgHnseEd-kbKudaoxE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Paths are very interesting... you can't create one with a map inside in this way:

```
word/#(a: 22 b: 33)`
```

But you can:

```
probe x: to-path reduce ['word #(a: 22 b: 33)]
probe x/2/a
```

Result:

```
word/#(
    a: 22
    b: 33
)

22
```
And you can even put in an `object!`
```
probe x: to-path reduce ['word make object! [a: 22 b: 33]]
probe x/2/a
```

Result:

```
word/make object! [
    a: 22
    b: 33
]
```

[22:23:16](#oKPgNJAjsrcbsO4bukZI_7hG9f2i6EoLlq2qw-2Ii0E) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Paths are very interesting... you can't create one with a `map!` inside in this way:

```
word/#(a: 22 b: 33)`
```

But you can:

```
probe x: to-path reduce ['word #(a: 22 b: 33)]
probe x/2/a
```

Result:

```
word/#(
    a: 22
    b: 33
)

22
```

And you can even put in an `object!`

```
probe x: to-path reduce ['word make object! [a: 22 b: 33]]
probe x/2/a
```

Result:

```
word/make object! [
    a: 22
    b: 33
]
```

[22:23:38](#NfuO5nUUd0mEckGPlpQm8Ri2Qpo7xk72X-_N8fKf0rQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Paths are very interesting... you can't create one with a `map!` inside in this way:

```
word/#(a: 22 b: 33)`
```

But you can:

```
probe x: to-path reduce ['word #(a: 22 b: 33)]
probe x/2/a
```

Result:

```
word/#(
    a: 22
    b: 33
)

>> 22
```

And you can even put in an `object!`

```
probe x: to-path reduce ['word make object! [a: 22 b: 33]]
probe x/2/a
```

Result:

```
word/make object! [
    a: 22
    b: 33
]

>> 22
```

[22:23:48](#hD35y1n7J4fmAzsZmSrmpIC8AU7hJcVlry7KVkaRl4o) <greggirwin (Gregg Irwin)>:
One of the big issues here is that you can create values which won't round-trip, as they are not legal literal forms. That's a big downside.

[22:24:15](#PFj1EK4FBd2kqAglMiJMyh-JmrLr6jxusIktEvbmPqM) <GiuseppeChillemi (GiuseppeChillemi)>:
I don't know the term "round-trip"...

[22:24:28](#j75W4FxDXiL6LNckf_X8iCNf6aHIAxL4WPB8HxzB1Ls) <greggirwin (Gregg Irwin)>:
It means you can't save it and load it again.

[22:24:39](#GzbyDuGZLCAxhec-qe4bLL-NY7C66LQACG0jmDefvzE) <greggirwin (Gregg Irwin)>:
 * It means you can't save/mold it and load it again.

[22:24:48](#MfU1Lm2y2Jyoo_e-Rm5IDzvZwh1BMpMFxLvzbP2nyq8) <GiuseppeChillemi (GiuseppeChillemi)>:
Thank you

[22:25:31](#uUNkXPtOVCK63aICQr_icTHhTNKhJ31xgxNwvR1njDc) <GiuseppeChillemi (GiuseppeChillemi)>:
The only allowed literal form seems to be the one which uses parens

## 30-Sep-2023

[16:33:25](#aad4GWSdS2ClYMoEJGM86mXmqb5xLiQr5bTU696OM-0) <GiuseppeChillemi (GiuseppeChillemi)>:
The only allowed literal form seems to be the one which uses parens

[16:33:41](#R72hgSChOoaKUY4l33TXI11ldqtaB-MFW6Vw_xz1vaQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * A little experiment in parse to remove consecutive values:

```
remove-consecutive: func [
	"Remove consecutive elements of the same value  "
	string [String!] "String to remove from"
	value [string! char!] "The value to search"
	/min
	number [integer!] "The minumum number ov values to keep, otherwise 1"
] [
	
	parse string [any [number value remove any value | skip]]
	string
]

x: {some
word
to test
this parse rule

Ok

it



works!
}

probe remove-consecutive x lf
probe remove-consecutive/min x lf 2

[16:33:51](#W4QJEJnPjAi0nSecAPDbS2p3EuRkCrME1j9jEQ929AQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * A little experiment in parse to remove consecutive values:

```
remove-consecutive: func [
	"Remove consecutive elements of the same value  "
	string [String!] "String to remove from"
	value [string! char!] "The value to search"
	/min
	number [integer!] "The minumum number ov values to keep, otherwise 1"
] [
	
	parse string [any [number value remove any value | skip]]
	string
]

x: {some
word
to test
this parse rule

Ok

it



works!
}

probe remove-consecutive x lf
probe remove-consecutive/min x lf 2

[16:34:10](#VtxvRh5XlknmcXA_h7oYqSyGMfQGANCE2X1_hmR6kY0) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
probe remove-consecutive x lf
probe remove-consecutive/min x lf 2

{some^/word^/to test^/this parse rule^/^/Ok^/^/it^/^/^/^/works!^/}
{some^/word^/to test^/this parse rule^/^/Ok^/^/it^/^/works!^/}
```

[16:56:37](#owy4nqtTbwySfe5pYCLh5aqs-sUmEEDFOHyY7J4_MdM) <GiuseppeChillemi (GiuseppeChillemi)>:
I am starting to play with parse:
```
remove-consecutive: func [
	"Remove consecutive elements of the same value  "
	string [String!] "String to remove from"
	value [string! char!] "The value to search"
	/min
	number [integer!] "The minumum number ov values to keep, otherwise 1"
] [
	type? number: any [number 1]
	parse string [any [number value remove any value | skip]]
	string
]

x: {some
word
to test
this parse rule

Ok

it



works!
}
```

[16:57:06](#Mvog08iagJ0tllIqbNs3vcKX0s7ToKKjdeiSZ1BD3Ec) <GiuseppeChillemi (GiuseppeChillemi)>:
```


probe remove-consecutive copy x lf
>> {some^/word^/to test^/this parse rule^/Ok^/it^/works!^/}

>> probe remove-consecutive/min copy x lf 2
{some^/word^/to test^/this parse rule^/^/Ok^/^/it^/^/works!^/}
```

[16:57:13](#cZIFb1IIhNp4xLFpmVXoNNczSH5UsL-x7lgPtv4XFnE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
probe remove-consecutive copy x lf
>> {some^/word^/to test^/this parse rule^/Ok^/it^/works!^/}

>> probe remove-consecutive/min copy x lf 2
{some^/word^/to test^/this parse rule^/^/Ok^/^/it^/^/works!^/}
```

[16:57:30](#QDbLXeC7frc2qHdEVHZP--Ixl3ls2FRcXqYFbwZ_4yY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
>> probe remove-consecutive copy x lf
{some^/word^/to test^/this parse rule^/Ok^/it^/works!^/}

>> probe remove-consecutive/min copy x lf 2
{some^/word^/to test^/this parse rule^/^/Ok^/^/it^/^/works!^/}
```

[18:24:57](#aCdIicjr6iw5vmf4CpbgwYrF-BPa9-Go5CZUF7vHxVc) <GiuseppeChillemi (GiuseppeChillemi)>:
As Always, there are a couple of errors but I will fix them ;)

## 10-Oct-2023

[13:53:16](#7Z37hL69cRxVbZyWas8CIWegyFv6ssZ_n80jLLiFAlQ) <hiiamboris>:
![https://tchncs.de/_matrix/media/v3/download/tchncs.de/34aa6c0b34742d25764f4243e205f916d60761b2](https://tchncs.de/_matrix/media/v3/download/tchncs.de/c5fc797587fa4a4d3d915b414673bc5e7f3ae029)

[13:53:20](#PvKSL6Tpo3JJNBVbpKeYsdoXA9ZuzgsvhfcAb3XmGG4) <hiiamboris>:
![https://tchncs.de/_matrix/media/v3/download/tchncs.de/a2ad7deb569ebe09c0ff2575836f92c74a794540](https://tchncs.de/_matrix/media/v3/download/tchncs.de/e841a7528494e8c2b152eb3291bf5c6ae1ec7445)

[13:54:00](#8F2VFa7VPZ_FvYTA4hzCQvS6M3r1vcFp2ZmPj-Szb2s) <hiiamboris>:
Proof of concept: parsing progress interactive visualisation.

[18:01:40](#SygOgzGLSA5PGwTcV01ceF0aPYc0h0JjaBIg7EcQU3Q) <GiuseppeChillemi (GiuseppeChillemi)>:
Great work 

[19:26:01](#dbspX7HjfaOHiSVDXObU8t3BnTjV8YeZ_e9YC2VM2ds) <greggirwin (Gregg Irwin)>:
Very cool. Ì†ΩÌ±çÔ∏è Would be great to see the actual rule, optional or as a tooltip. I know this is an early prototype of course. Nice work.

[19:29:01](#Mrd0nPDd94JUgEtbqLvru4Sz0g5CPe6Nm2fRR-l5yz4) <hiiamboris>:
Thanks for the idea, may be useful indeed.

## 16-Oct-2023

[19:17:09](#uHI3SvuRLVMgKI20CjrUElD4I3kBtuTJ-30Ew1dCz9o) <hiiamboris>:
![https://tchncs.de/_matrix/media/v3/download/tchncs.de/5a04b741063306fda04116c3f14b7fb9dd9b2edc](https://tchncs.de/_matrix/media/v3/download/tchncs.de/0891caffaa274de4f7ab8691deea35f6af6eecea)

[19:17:24](#9MSknu_rIw3Ju9s3nEqpRaNh9McCL4I1vCcg8UceJG0) <hiiamboris>:
works with CSV decoder now

[19:18:32](#4xoGmTMSzdn_Oea_BxgFMueYIz12jKISM2C-9sUyu0w) <hiiamboris>:
top-level rule is red because `parse` never finishes in CSV, it just bails out using `return`
in the end of the gif you can also notice that CSV always processes the last token twice, which is likely not by design

[19:18:57](#cwSxkf6Jbn3eLvOG0yE7UryiV2LeD9fYyS991o4e3tk) <hiiamboris>:
* top-level rule is red because `parse` never finishes in CSV, it just bails out using `return`
in the end of the gif you can also notice (by darker color) that CSV always processes the last token twice, which is likely not by design

[22:03:12](#LeheF2RB1Stb18PDONtb5H5S2a1QSDwGXjQrCGt-zcI) <greggirwin (Gregg Irwin)>:
Wow. Super cool. With this, DiaGrammar tech, gltewalt (Greg T) 's Parse Caddy, and more, `parse` tooling has an exciting future. And rebolek (Boleslav B≈ôezovsk√Ω) can check out the CSV issue. 

## 17-Oct-2023

[6:50:08](#YI4-VGSVJjifmNJuREdiUEmqWEFVDGzNi6y7B4BKpnI) <rebolek (Boleslav B≈ôezovsk√Ω)>:
hiiamboris: cool! Where can I get this?

[8:12:38](#6J9fo66OmCdSUJ44M4RnjPCO4O6XpUiYxMySlSICoLQ) <hiiamboris>:
I'll upload once it is more stable

## 18-Oct-2023

[20:00:14](#8YcbT9384ER_Go82kvJ7Sq_q64JounWNQ2_WvAhrSuo) <gltewalt (The other Greg)>:
Fantastic, hiiamboris

## 22-Oct-2023

[16:48:49](#Vj9D0ejSc7SclSFJ55HKdQRuqH_8TLJ6AR2VXIzeV6g) <GiuseppeChillemi (GiuseppeChillemi)>:
A small experiment to have a list with multiple columns in VID

[16:49:01](#nZroZD1yXwVxnJQyxMLeGepIgw_AlxO1hFINWNVDBGc) <GiuseppeChillemi (GiuseppeChillemi)>:
```
Red [
	title: "Multi Text List"
]

l: ["a1" "b1" "c1" "a2" "b2" "c2" "a3" "b3" "c3" "a4" "b4" "c4"]

select-everywhere: func [
	"Select the same element on all lists"
	face [object!] "The current face"
	id [word! string!] "The id of the list"
	position [integer!] "The position to select"
] [
	foreach-face/with face/parent [face/selected: position] [attempt [face/extra/list-id = id]]
]


make-list-view: func [
	"Create a navigable list made of multiple text-lists"
	data [block! object!] "The table as flat"
	col-ln [integer!] "The lenght of columns"
	list-id [word! string!] "The name of the list"
	/local
	template
	row
	list-body
] [
	template: [
		style clist: text-list data "" on-change [select-everywhere face face/extra/list-id face/selected]
	]
	
	list-body: copy template

	row: [clist data "" with [extra: make object! [list-id: quote (list-id) data: l column: (col-num) original-data: data] data: extract/index l (col-ln) extra/column]] 


	repeat col-num col-ln [
		append list-body compose/deep copy row
		
	]

	
	list-body
]

view make-list-view l 3 'one
```

[16:50:15](#MufzG3QG-LukuCdbHJA3-KEVgF3HvcwvITTUSTRpTdg) <GiuseppeChillemi (GiuseppeChillemi)>:
![](https://gitter.ems.host/_matrix/media/v3/download/gitter.im/20171d857602d461c91946389d1b21855d1841521716134882909880320)

[16:50:33](#q9KZ1Fp2P8o1bvZ9Z6jbwHwiN4VfQNopMOXmqGxOpts) <hiiamboris>:
Problem will be to sync scrollers once they appear :)

[16:51:23](#QXfBbky-L2bEQFCKYBAe6sSfyQis_biO_AdwGd0nmpc) <GiuseppeChillemi (GiuseppeChillemi)>:
:DDDD The unexpected! Suggestion?

[16:52:44](#eUGpXPdsdvoez58AreMR9zNU_mAMBTgLDMouaYcBSdw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * :DDDD The unexpected! Suggestions?

[16:52:49](#8ia2IpNWW1YBQOKfA97e8u1f_dgoMyil6iT45nnd9hw) <hiiamboris>:
No idea. I plan to work on Spaces `grid-view` and add selection capability to it. Including *whole-row* selection (list-like), which I'll be needing for ParSEE as well. But not there yet.

[16:54:32](#wJiVInOYRkmtgbp4eYghS2mfnGPau6BmdQwhGeo7yeA) <GiuseppeChillemi (GiuseppeChillemi)>:
A complete grid is my most wanted object. I could change VID to SPACE with it (but TUI) once a GRID will be here.

[16:56:20](#q7ibUm8pky9sACpXdY9Y8CjqdsaEVJW_WxJise2aKiU) <hiiamboris>:
For TUI should be quite simple to write a grid style from scratch. You can manage.

[16:59:39](#thMwetlbQHxFPurzQtcA_KpsV-__2wvZn4YHegLg1jA) <GiuseppeChillemi (GiuseppeChillemi)>:
I (actually) don't need it in TUI I was referring to changing VID with SPACE. I could do with a full GRID but I would remain on VID for TUI

[17:00:52](#J-uoZQqsMA4CFLCoiTFijxIaD5wBLHj5GvVfUeteQ8o) <GiuseppeChillemi (GiuseppeChillemi)>:
About the problem with scrollers. I have made them appear. Once I select one they auto sync but only if the selected elementy is at the start or at the end. 

[17:01:10](#GcWj00m0AjUHU785GKSN1sDLJlelHDOEd-O7Zameerk) <GiuseppeChillemi (GiuseppeChillemi)>:
Otherwhise, the other moves but do not match the selected one.

[17:01:24](#rJhp9y_hlVzeAaDD1YUMYM-jJFknUvBtjVDDa_nOsGs) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Otherwhise, the others move but do not match the selected one.

[17:01:49](#3raWlwQ-lDJ-F6x9e2zpd45b6OK2voO4yStZhBtE6Xg) <hiiamboris>:
What if you select the topmost one and right after that the one you need to select?

[17:02:06](#T1IvGgd_EzqLCZzbDdvBUEdrLV-bE1NVFJpPj0G-7wg) <GiuseppeChillemi (GiuseppeChillemi)>:
I will let you see

[17:02:25](#XS58sTIEOaUIURnZj1p7aJPW5sDs8wFq_OPcrwk3fIU) <hiiamboris>:
No, I mean, programmatically do this to sync them.

[17:02:31](#ZF1Bu5CiJqd8Kc0YwCwdjb0OHf_tRzW4zYCLCqJuycE) <hiiamboris>:
* No, I mean, programmatically do this to sync the columns.

[17:02:53](#rrArlefJ3zmWUzPbg33C5AhMeOg891H0s7VZ9cv8NcQ) <GiuseppeChillemi (GiuseppeChillemi)>:
I have not undestood the question

[17:03:27](#B_eJsVT9yyMlc58-oKSQqt4Se9qsmAuiXIUJEQWNUIs) <hiiamboris>:
When you select row N in column 1, you select row N in columns 2 and 3, right?

[17:03:48](#25oKwjpxTdGq-Q-9Z7Dh0Ixikl2iSTZyHYkgKbs_N8Q) <GiuseppeChillemi (GiuseppeChillemi)>:
You mean: selecting the topmost ROW (number 1) or the topmost viewed (which could not be #R3:gitter.im 

[17:03:53](#ajnYWNFADxTKdPyVFy1BeUAjI5VJq5dSZhsPkZuzxvM) <hiiamboris>:
Try instead selecting row 1 in both, drawing them, and then selecting Nth row.

[17:04:00](#jFDMbokYz_9pHW0xgDxuk5Y5AZglKNkMLAgABMazlAc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You mean: selecting the topmost ROW (number 1) or the topmost viewed (which could not be number 1)

[17:04:45](#QsU3UK2Z2lhggFS_5FrrKgKZEdxneSiZMnSkyyJqXog) <GiuseppeChillemi (GiuseppeChillemi)>:
It should work, as they sync when I select the topmost

[17:05:48](#4CicjjyGehzIk9G0d2ETODqZPFJs2X4E38mS_5BcxF4) <hiiamboris>:
Hmm now that I think of it, you'll also need to do that with 1st column. So all three. That must sync them, but also kinda weird that what you click on jumps to the bottom of the view.

[17:07:25](#1_zNyemd0RGD3MiJ6axJE8LZwS44mIFWDLeyMET9ykg) <hiiamboris>:
If you could measure how many rows fit into single column's view, you could keep the 1st column as is and pan the other columns in sync with it.

[17:08:16](#6Jtu8sEyO67EjhxThf81xllAkfkAfY54DJObX4_9DLI) <GiuseppeChillemi (GiuseppeChillemi)>:
![https://gitter.ems.host/_matrix/media/v3/download/gitter.im/a19cd10d36365cdff013ff9f90ae0cc76a3ee8d81716139416856035328](https://gitter.ems.host/_matrix/media/v3/download/gitter.im/f15e0eb3de5a88e1228feebb505edeaf80727e711716139419104182272)

[17:08:53](#FyOIQnBOXc8V7mqXT4vI_eGfoxQanakbzT5cjPj-bwY) <GiuseppeChillemi (GiuseppeChillemi)>:
With about 30 rows, it is so fast you won't notice the jump

[17:10:08](#An2z-O3eg-uriOeGf057007kzMo_iC92Ugb5UkIMmuU) <GiuseppeChillemi (GiuseppeChillemi)>:
But it would be nice to have `on-scroll` and the coordinates that reflect the position of the list exposed

[17:10:24](#7UrGooKJaqD-UD0w0_jEf6e_3gqVBPXW03LL2DwEPLs) <hiiamboris>:
Yeah.

[17:10:50](#Da6ThiMrnnEk7eyZFNjQgU90RABX5rWgQJKgnxSTo80) <GiuseppeChillemi (GiuseppeChillemi)>:
Let's mention QTxie? 

[17:13:09](#Lx7DlqDpUdC53G-GhEzQhmCVxqQRthuDxs0C9mIrz5Q) <GiuseppeChillemi (GiuseppeChillemi)>:
Or I could I make a request on RED/REP

[17:14:12](#gZF5euWEpEa6o1pXBv9_65ZhhL61skjL9KiGbVGuyMA) <hiiamboris>:
Add a REP. I don't see anything similar, though it's an old wish.

[17:14:50](#cRBGAw_s0pEjrxnM0Bgy31_4Jc9Uz-5o6CiXDpeuMOs) <hiiamboris>:
There's only a request for area https://github.com/red/REP/issues/5

[17:19:19](#TkzWDrgnIw3cyr9VcHl59jZ7IkDpVyUcDR-_YdYrOS4) <hiiamboris>:
Literally, I did the same experiment with text-lists. And someone else did too IIRC. Either Gregg or Vladimir or both.

[17:21:56](#lNVqNPsghdW9ftkODEle4afVpFuPym2mNGRBCvvVrwg) <GiuseppeChillemi (GiuseppeChillemi)>:
They are a long time need. Hope this could be solved now

[17:36:11](#dzxnmqBt2XccmbYXSJmRYy2Btaj9OVqyjhTfvuw04Bg) <GiuseppeChillemi (GiuseppeChillemi)>:
Done

## 23-Oct-2023

[13:25:10](#wHWABu6ekwDjFLlGuDP4s2hfMrCHlj47qd8glp7A_VA) <GiuseppeChillemi (GiuseppeChillemi)>:
Here is another little experiment: `smart-compose` it use the paren in paths, so you have another reason to not remove support for them:

```
Red [
	title: "smart-compose"
	Description: "Compose only parens which start with a key"

]



smart-compose:  func [
	"Compose only parens which starts with a key as key/(code)"
	code [block!] "The code to reduce"
	key [word! path! block!] "The key to compose TBD: block to implement multiple keys"
	/local
	key-ln
	code-block
	code-result
] [
	case [
		path? key [
			key: to-block key
			key-ln: length? key
		]
		word? key [
			key: to-block key
			key-ln: 1
			
		]
	]
	forall code [
		if path? code/1 [
			decoded-path: to-block code/1
			if (copy/part decoded-path key-ln) = key [
				paren-code: at decoded-path key-ln + 1
				if all [paren-code paren? first paren-code] [
					paren-code: first paren-code
					code-result: do paren-code
					insert remove code code-result
					code: at code 2
				]
			]
		] 
	]
	code
]


```

```
probe smart-compose [
	a one/(1 + 1 1 + 2 [1 + 3]) 
	33 two/(4 "red" ["rose" "here"])  
	xx one/(4 + 5 [xyz]) 44
	xx one/(4 + 5 [zzz]) 999
] 'one
```

Result:

```
[
    a 1 + 3 
    33 two/(4 "red" ["rose" "here"]) 
    xx xyz 44 
    xx zzz 999
]
```


[13:29:44](#8yTMFwyXVMCN2whFXdw2PABJNPjAFeiEYWDHhyhj1DI) <hiiamboris>:
is there a reason to use paths?

[13:31:20](#a01JCk-OQBBfNABB3eLOR3UvQtFmrv_2WhdeJcPN2bs) <hiiamboris>:
otherwise, this wheel was there for years
```
>> probe reshape [
	a @(1 + 1 1 + 2 [1 + 3]) 
	a !(1 + 1 1 + 2 [1 + 3]) 
	33 two/(4 "red" ["rose" "here"])  
	xx @(4 + 5 [xyz]) 44
	xx @(4 + 5 [zzz]) 999
]
[
    a 1 + 3 
    a [1 + 3] 
    33 two/(4 "red" ["rose" "here"]) 
    xx xyz 44 
    xx zzz 999
]
```

[13:33:03](#8v2y4E-A50vUaFh2NBDUPRDKZXRYV9mNXhw7uHpszio) <hiiamboris>:
I suggest moving key into 1st argument at least

[13:40:38](#y_5montfKsyThXDM0ENxs_BYoVnsvi8WMLdjxlXDlP4) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> I suggest moving key into 1st argument at least

Yes, despite It is not Redbol standard, I prefer having Key on first argument too.

[14:08:00](#PqrLZ6VZfDOYcNiX7qnORtWtg93v31Z_Nz6v4QWmtCE) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> otherwise, this wheel was there for years
> ```
> >> probe reshape [
> 	a @(1 + 1 1 + 2 [1 + 3]) 
> 	a !(1 + 1 1 + 2 [1 + 3]) 
> 	33 two/(4 "red" ["rose" "here"])  
> 	xx @(4 + 5 [xyz]) 44
> 	xx @(4 + 5 [zzz]) 999
> ]
> [
>     a 1 + 3 
>     a [1 + 3] 
>     33 two/(4 "red" ["rose" "here"]) 
>     xx xyz 44 
>     xx zzz 999
> ]
> ```

Never used reshape, mine Is just an experiment.

[14:08:24](#NRzD9pu3q9YnhqomBor1Wukg--TTlFK48sJpvn97QU0) <hiiamboris>:
On paths, I don't think using a path instead of word prefix affects the chance of collision. Also the sigil/prefix must stand out visually.

[14:08:37](#b6Hfwuh0boqgp4Ne8Z_lRpWo1lZqf4_vsHUX4fdfHvY) <hiiamboris>:
* On paths, I don't think using a path instead of word prefix affects the chance of collision with normal code. Also the sigil/prefix must stand out visually.

[14:10:17](#KFfXui6abGUeXdv8JEY_Hd7Pe-7UHpt7ej8Uc9hQwl4) <GiuseppeChillemi (GiuseppeChillemi)>:
But how do you tell reshape which parens group to compose using a Key instead of ! @

[14:12:59](#09z1bJlEGi0w8-JryzPheoM-HjaA4On_mPOpcleRPEY) <hiiamboris>:
I didn't implement that. Providing your own prefix helps control what to evaluate and what not, which I have to otherwise work around with `/skip [..]` command in `reshape`. However there are only a few short visually standing out prefixes, and the more of them we'll use the more cryptic our code will look. Either cryptic or overly verbose, take your pick.

[14:16:00](#EiYFd8esUqcdwnI1WUeESl_OcPCegMuSOXL7__1Ixrk) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> I didn't implement that. Providing your own prefix helps control what to evaluate and what not, which I have to otherwise work around with `/skip [..]` command in `reshape`. However there are only a few short visually standing out prefixes, and the more of them we'll use the more cryptic our code will look. Either cryptic or overly verbose, take your pick.

I like your analysis of "prefix" that visual stands out. It Is a knowledge coders do not usually have. 

[14:18:12](#T1dNdHINlIVwWivKZqISev0rxqcSvKZIfjzAtEL_bqk) <hiiamboris>:
Perhaps I could do a smarter thing and detect inner `reshape` invocations and avoid them automatically. Instead of `/skip`.

[14:18:26](#i4pVZAppdWEdM8lOT8jo0c7ZsjlCufG0Yx8W3BAT6W4) <GiuseppeChillemi (GiuseppeChillemi)>:
I will take a deeper look on reshape.
My goal Is to make a compose/reduce able to work on code regions, levels and categorized code parens/block like in my smart-compose.

[14:20:44](#t4EzqVGHLlnpUOVr0cIQaxj58HhyIxIQN15n2VH6B2Y) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> Perhaps I could do a smarter thing and detect inner `reshape` invocations and avoid them automatically. Instead of `/skip`.

As said, I must read reshape doc to fully partecipate in this discussion but as I have written, my goal Is to restrict compose/reduce actions to regione, levels, keyed elements or a mix of all using a dialect.

[14:21:56](#BB_oRWyLxrKL5nh7oqVjnXBDIj2nBiLJezHdFaKoFOU) <hiiamboris>:
What is your use case?

[14:26:08](#zDhfjyib33XqFAZtyfLTq62pBd-pjcvI0HmIq-4wef8) <GiuseppeChillemi (GiuseppeChillemi)>:
VID blocks are the most important. When you dinamically create them, you often feel the need to compose only blocks below the top level, or in a particolar block marked with a keyword or code between start/stop markers. 

[14:30:17](#raQCXEslJR2-exnmLcISEIype4AZc4OBLV3NZoe7sGE) <GiuseppeChillemi (GiuseppeChillemi)>:
Aldo BIND would require such logic. I would like to bind only words on the first level or the opposite: on the inner ones but not on first level. This to avoid the problem which led you choose to have SPACE  keyword ending with =

[14:30:30](#oUmnEn7YuJ6DJbX69cVrXzA-LU6xnRVku4CobxiSZkY) <GiuseppeChillemi (GiuseppeChillemi)>:
* Aldo BIND would require such logic too. I would like to bind only words on the first level or the opposite: on the inner ones but not on first level. This to avoid the problem which led you choose to have SPACE  keyword ending with =

[14:38:09](#90nt0uqCkP8ONcpj2qcqYXwpb1k4RJLxbxENScnvz3Y) <hiiamboris>:
I'm not binding the VID/S blocks. `=` is to differentiate between a style name and facet name.

[14:56:34](#jeUOou4GOERNEK4mmQkhwqJmWKgaJkJYXeCxkqbVS1g) <GiuseppeChillemi (GiuseppeChillemi)>:
I want to bind without dangers, avoid partitioning the namespace end reusing common words:

Here `smart-bind` works only on level 2 words.


```
size: 100x100
table: ["a" "b" "c"]

ctx-actor: context [
	size: 900
	data: [one ["x" "y" "z"]]
	table: none

]

view smart-bind 2 ctx-actor [

	button "Print size" size [
		probe size	
	]
	text-list data table [
		table: salect data 'one
		face/data: table
	]
]
```



[15:02:20](#kLRB8ZKyItexxSPv2a4t8HcWqYdxFBq1XAezIgKvzfg) <hiiamboris>:
Why not use fully qualified names e.g. `actors/size`, `actors/data`, `actors/table`?

[15:02:35](#NzBDDEBhrA_Du6xwuBxPkfD9fecL61DJELE03kWj55Q) <hiiamboris>:
I don't think this solution will scale well.

[15:11:03](#QY4qyZPcv5iIchzvAOSmIa6I8DU__yh4oHtgL9eVg_0) <GiuseppeChillemi (GiuseppeChillemi)>:
I remember having had problems creating VID block reusing the same actor code with copy, or trying to bind after the code block is completed. It is a problem had in some experiments of the last year but I should deep search for the notes.
The ideas is simply to map the code block with levels, region markers, keyes. Then you can act on a specific region which could be very deep in the VID block but you do this once the whole block has been composed and it is ready.


[15:11:56](#UA9QQ4gH5XJb67_LM3Wo0pAThnPDmiB6ODuy3ivORQo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I remember having had problems creating VID block reusing the same actor code with copy, or trying to bind after the code block is completed. It is a problem had in some experiments of the last year but I should deep search for the notes.
The ideas is simply to map the code block with levels, region markers, keyes. Then you can act on a specific region which could be very deep in the VID block but you do this once the whole block has been composed and it is ready. I find it easier to debug than having multiple binds and creating contexts while assembling parts.


[15:13:58](#cXAZI6SG3IRXij2Oy7Mn53x4mg-bHlD86LGFnWxkzdE) <GiuseppeChillemi (GiuseppeChillemi)>:
Such markers can disappear once bind/compose/reduce is complete or stay there as neutral elements in the middle of the code like a `/keyword-here`. 

[15:18:03](#QYeFVSCXxw861gxJFK15tLycPp0D7cOw-ceDcAu9uTg) <GiuseppeChillemi (GiuseppeChillemi)>:
Another idea was to add commands for bind to modify its working while processing the block:

```
smart-bind ctx [a b c /bind-skip [a b c] a b c /end-skip a b c] 
```

[15:18:25](#gT0TEMBq511mNglAOGRs24JhD82T_oyjto-HGA-ZpJ4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Another idea was to add commands for bind to modify its working while processing the block:

```
ctx: context [a: 22 c: 33 d: 44]
smart-bind ctx [a b c /bind-skip [a b c] a b c /end-skip a b c] 
```

[15:22:41](#qSaRBYox_EVaVEp1CfaLcJ_Yqp_SDr3RGbUtFWNkiY4) <GiuseppeChillemi (GiuseppeChillemi)>:
All those ideas converge into a common dialect for instructing bind/compose/reduce where to act ad also commands where selective like logic could be applied.

[15:32:54](#Ne2K6M1yaFcd61ushTDpMDP13CU5V2smhguJXIlcrBI) <hiiamboris>:
With language support for slices, well be able to build generalized solution for all of that and more.

[15:33:02](#sxIeXZoFnErqVj4ZTR97DrZZRv7z-Xpdw0wnwpQPQNI) <hiiamboris>:
* With language support for slices, well be able to build a generalized solution for all of that and more.

[15:33:14](#3bfLXTFPPQQ4LwZYWo2sjWm5MwYEG3n9ZOFlT6O1Uus) <hiiamboris>:
For now, just adhoc kludges.

[15:50:07](#OlIIaujOV_GIwaYGKTI-hjaB7MVlv_GvlGBpUF4-fyo) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> Perhaps I could do a smarter thing and detect inner `reshape` invocations and avoid them automatically. Instead of `/skip`.

Why not adding the key after `!` or `@`

Like:

```
[a !one() !two() !one() z]
```

[16:10:45](#u-M-ggSecvBq5rMe-CTU_219cDPKyJES2VUv5pGFMA0) <hiiamboris>:
never really needed a key there, plus @one etc would be a valid ref, while @ is unlikely to be used literally

[17:02:34](#u65ILYqRoIf8VVdAXWqwBQXLeM2JFyf-INCsoh4jxzs) <GiuseppeChillemi (GiuseppeChillemi)>:
We have differenent use cases but sharing similar basic needings. It is really important to selectively `compose`  code in VID , and also Bind part of it after the block is complete and fully created.

[17:02:43](#aVtYMyiPfvAe-h8PDJ3MOa4Cu1co-6a0G699_MdXWuI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * We have differenent use cases but sharing similar basic needings. It is really important for me to selectively `compose`  code in VID , and also Bind part of it after the block is complete and fully created.

[17:20:12](#PHFrsoPeDsWV_iUgB3ZzJrBFWyjTHOBNFaemmwZUY_Q) <hiiamboris>:
Why are you not binding before composing?

[17:25:19](#VYR_93hTROPmYOUYpTihL8TnZ7mTM3Rg048c7bOusfU) <GiuseppeChillemi (GiuseppeChillemi)>:
1) Because it causes a lot of fragmentation in my coding, having continuous binding/composing/reducing.
2) Because I can create a full panel and then bind every section later

[17:25:35](#lJVt0c2ZQEetvk0Kb569J1FgRf333AMvhnq3FFMDyaM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * 1. Because it causes a lot of fragmentation in my coding, having continuous binding/composing/reducing.
2. Because I can create a full panel and then bind/compose every section later

[17:26:04](#oehtQtQBvQlTPsyLIfedx6PZ-CuKBH6kn7gO7GBelMo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * 1. Because it causes a lot of fragmentation in my coding, having continuous binding/composing/reducing.
2. Because I can create a full panel and then compose/bind every section later

[17:26:25](#BeCOQ6cTmld0F4gj3Zw_60lQthbVGRnnmoTJoX-QJ84) <GiuseppeChillemi (GiuseppeChillemi)>:
 * 1. Because it causes a lot of fragmentation in my coding, having continuous composing/reducing/binding
2. Because I can create a full panel and then compose/bind every section later

[18:32:57](#TaRu0c9QYHUKZJoBB-lW36MM59Gxvk6ahIJXATWfn2U) <GiuseppeChillemi (GiuseppeChillemi)>:
However, today is full of ideas:

What about:

```
mystring: "hello people, red is the best"
print mystring/13x29 

> "red is the best"

print mystring/13
> "hello people"
```



[18:33:02](#VGJqpedluYtUz76-uyxdrQW6ehuIbeCPouGwFy5j9-c) <GiuseppeChillemi (GiuseppeChillemi)>:
 * However, today is full of ideas:

What about:

```
mystring: "hello people, red is the best"
print mystring/13x29 

> "red is the best"

print mystring/13

> "hello people"
```

[18:34:42](#-zDZTQ2iwHSXEEdnVfOV87VyoWugIbSE33jzoi8wUTg) <hiiamboris>:
`copy` ?

[18:34:58](#R-rMwjl8lZwrtUAKbL9SQpLxhTVWcxZvgZ_bRTvb5ok) <GiuseppeChillemi (GiuseppeChillemi)>:
Just a shotcut using refinements

[18:35:20](#o_dJnj3fKlO71GQn-XKlulSz8GdR9RXwnjK3mB8uaoA) <GiuseppeChillemi (GiuseppeChillemi)>:
It is AT + copy

[18:35:33](#WCkuDW0KhzAQ8znDR3hjQ0errxhbNgk_1ZB0Hspz2gA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * It is `AT + copy`

[18:35:41](#Kxre1LK8Euf8g800Dy5McAmizcLpZvafrCbjXDJPvL0) <hiiamboris>:
no need for AT

[18:36:18](#zKIdc3h4f-TUjuvv8fsjihMSoOdNRdHrFa8IlFcGcGE) <hiiamboris>:
though copy/part has different semantic

[18:41:26](#9KatOZ_xrpTUhiV-sfrjQ3C4SWbLp6GbsgVkCkcoFSg) <hiiamboris>:
you reminded me of one funny trick:
```
>> /: make op! func [a b] [either series? :a [split/slices :a :b][divide :a :b]]
== make op! func [a b]
>> mystring /[14x29]
== ["red is the best"]
>> mystring /[12]
== ["hello people"]
```

[18:43:52](#zwUECgtvbx9bRNnIDDD2F0djBiWsyR0GYpDApE0Rwy4) <hiiamboris>:
* you reminded me of one funny trick:
```
>> /: make op! func [a b] [either series? :a [split/slices :a :b][divide :a :b]]
== make op! func [a b]
>> mystring /[14x29]
== ["red is the best"]
>> mystring /[12]
== ["hello people"]
>> mystring /[12 2x17]
== ["hello people" "red is the best"]
```

[18:46:42](#kEhccFJPEu7GRNE2hpBWredf5lOGRjZT_kxgAQyUtiU) <hiiamboris>:
* you reminded me of one funny trick:
```
>> /: make op! func [a b] [either series? :a [split/slices :a :b][divide :a :b]]
== make op! func [a b]
>> mystring / 14x29
== ["red is the best"]
>> mystring / 12
== ["hello people"]
>> mystring /[12 2x17]
== ["hello people" "red is the best"]
```

[18:47:15](#gcGzyxWcC1n5srswqFX6dPRzAN1njxJLjM1-Jbld-RU) <GiuseppeChillemi (GiuseppeChillemi)>:
Really funny!

[18:47:41](#NLyubxankv8MI94EwY6ELgNIP86C1Y38wr3q7Y5C6Xw) <GiuseppeChillemi (GiuseppeChillemi)>:
I see every of us when going deep with the language have similar ideas

[18:56:59](#5EFwrH7z91kDMvtWXcwXGf6Se5-Y-KC4Cy4GCFwq37g) <hiiamboris>:
* you reminded me of one funny trick:
```
>> /: make op! func [a b] [either series? :a [split/slices :a :b][divide :a :b]]
== make op! func [a b]
>> mystring / 14x29
== ["red is the best"]
>> mystring / 12
== ["hello people"]
>> mystring /[12 2x15]
== ["hello people" "red is the best"]
```

## 19-Nov-2023

[18:32:51](#l4lH5-eiO2H1cTAKUkZuWXZS2mf28ndAO4-cL2tzs6E) <hiiamboris>:
GiuseppeChillemi (GiuseppeChillemi) I've [simplified](https://codeberg.org/hiiamboris/red-common/src/branch/master/reshape.md#syntax) `reshape` by a big margin and that allowed me to add support for user-provided grammar, e.g.:
```
>> reshape/with ['INSERT 'IF] [if x = INSERT[1 + 2] [insert s x] IF true]
== [if x = 3 [insert s x]]
```
This also addresses Gregg's complaint that it was too bloated.

[18:42:06](#mfmjbda2QlHULgduuiD6EOKSsHTD5QBlxe6_HVPcY8c) <greggirwin (Gregg Irwin)>:
Can't wait to review! Ì†ΩÌ±çÔ∏è

[18:49:13](#tiduQQ-gXcGbQ0LKuvRmqLzrSVRU81ASy0h9rnuWDtY) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> GiuseppeChillemi (GiuseppeChillemi) I've [simplified](https://codeberg.org/hiiamboris/red-common/src/branch/master/reshape.md#syntax) `reshape` by a big margin and that allowed me to add support for user-provided grammar, e.g.:
> ```
> >> reshape/with ['INSERT 'IF] [if x = INSERT[1 + 2] [insert s x] IF true]
> == [if x = 3 [insert s x]]
> ```
> This also addresses Gregg's complaint that it was too bloated.

Looking at it, it seems a lot simpler. Are ['KEYWORD1 and 'KEYWORD2] positional? So the first element always replaces INSERT and the second always replaces IF?

[18:49:24](#fMazzqWahxLaFi6CrF7w6KUgAakUaXT8gzlq-jXU1gc) <hiiamboris>:
yes

[18:50:18](#sRjWL4qkkRWu5Qo9ZnHQk2MEEoK07wCacUxdVlr1ZRo) <hiiamboris>:
2nd can also be omitted to disable /if, but it doesn't give any benefits

[18:52:13](#hf65IuWNFM4vtKK5lRuxQyefCtvDzapofeWcH2e5Fws) <GiuseppeChillemi (GiuseppeChillemi)>:
Could I use a path as keyword?

[18:52:23](#x4Rh8pt-nYqQCsQgWJcFx56prin-iXEh5giAN5bM2-o) <hiiamboris>:
(I mean I could use a simpler rule in that case, speeding it up some more, but probably not worth it)

[18:52:52](#lNeBKdRgMEDENV_tlQ8RwfqLizUIAfnVxWX-5PW6P-I) <hiiamboris>:
> <@giuseppechillemi-59045d00d73408ce4f5bcd9d:gitter.im> Could I use a path as keyword?

anything parse can swallow, so probably yes, but have to try

[18:56:36](#2TKXSnrLtwW9MOOn6pvBgizxJnaYLsUO2TMP8P1K_X0) <GiuseppeChillemi (GiuseppeChillemi)>:
`reshape/with [CTX] [CTX[A/B]]`

So this is the line to use in place of my `REDUCE-WHERE` notation , isn't it?

[18:56:50](#-QTxdl5IUW2Zdrat3WXzoXA8VYOV6zgBfrIyp8yIcDk) <GiuseppeChillemi (GiuseppeChillemi)>:
 * `reshape/with ['CTX] [CTX[A/B]]`

So this is the line to use in place of my `REDUCE-WHERE` notation , isn't it?

[18:57:09](#9Vw85BBTRBs5h44HNx999sA_FQCdz5INYplBzUFxZ9A) <GiuseppeChillemi (GiuseppeChillemi)>:
 * `reshape/with ['CTX] [something CTX[A/B] something here to]`

So this is the line to use in place of my `REDUCE-WHERE` notation , isn't it?

[18:57:48](#qUFKE6vb7d81hp0A1jds0vrD7MH17YnnRB6nvd2wN3E) <hiiamboris>:
you'll have to remind me its syntax again :)

[18:59:02](#BJsAr39MMqPfPFh4r0nDWWgDZGfEG9Lcv4wffTfbygc) <GiuseppeChillemi (GiuseppeChillemi)>:
You reduce and insert only paths starting with a keyword like 
`CTX/A/B`

You can either reduce just `A/B` in version 1 or the whole `CTX/A/B`

[18:59:23](#eMXjhMuCq3FLA0Ok4t7M_FCSgdCsqgFE21rcTJQUvTY) <GiuseppeChillemi (GiuseppeChillemi)>:
Or just a word

[19:00:00](#9rKKrYAEPbX4DYbaxFatbOK17QYJBtzPUtEJ3uOtLmI) <GiuseppeChillemi (GiuseppeChillemi)>:
It is a one element version of you RESHAPE

[19:00:20](#23OqdGVD52kw5vXgCvhTBcPMMUVHddjAKCudZa9A10Y) <hiiamboris>:
seems like it, yes

[19:00:36](#bFsJi8wtM9G6aCl5zI0N8uzSpwba30qOqohT-97GQ5o) <GiuseppeChillemi (GiuseppeChillemi)>:
Request....

[19:02:52](#5lEO76CQpmmJjzUp9AQ1NNvV2GYxrb0NfypUHUP59f4) <GiuseppeChillemi (GiuseppeChillemi)>:
`RESHAPE/BIND CTX [CODE]`

So that each occurrence is bound to the context before reduction
 

[19:05:09](#PDtnHt4vWxs7yjHQqt6TAfs3IagMPlfKg177nvA8Tmg) <GiuseppeChillemi (GiuseppeChillemi)>:
A more flexible version:

`RESHAPE/DO :FUNC [CODE]`

Where function is an arity 1 function

[19:05:58](#uf0ZR-CmJDlQJfhSYXRqbBCfNzqOvnv4audoWqeSYRg) <GiuseppeChillemi (GiuseppeChillemi)>:
So at each occurrence you pass the code to a function. It should not clutter reshape

[19:06:27](#xwi5LBx8L0J3QqzBcOkukVBdwYtzMJFxmUQkiAaVW3w) <GiuseppeChillemi (GiuseppeChillemi)>:
Probably it is bettere ARITY 2, so you can pass an argument

[19:06:40](#_S42ieMZKYAvESENWCQ7hUjeHRYV-XKr3dy8SaQKvBw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Probably it is better ARITY 2, so you can pass an argument

[19:07:53](#m2uzIgGuBaJnUTuppkV5lqI63EyNmKM4tMioYs9zKmw) <hiiamboris>:
you can embed that argument in a arity-1 func

[19:08:05](#oklpjpxgnn4K1C_Oga5RxdGD__Qd_9smWwS9MO6lZQw) <hiiamboris>:
* you can embed that argument in an arity-1 func

[19:08:18](#TmLQI8XOoO2Jhd_fySQG_oa1iafYOdoqaTEjSUq-dKk) <GiuseppeChillemi (GiuseppeChillemi)>:
I think so

[19:08:38](#zDhmDUj95Kwr0Tv60yfkj98NNqcHXpj5CFxPJ0n8W64) <GiuseppeChillemi (GiuseppeChillemi)>:
But the first argument is the code block

[19:09:41](#eBF01Qb7Q3UQlYrjihEkL61hfz0EZnDwA8bSfFuY2LE) <GiuseppeChillemi (GiuseppeChillemi)>:
In this case would you pass the code block inside another with contains the arguments from second element onward?

[19:09:47](#GAmZajgV1aAm7JP-rSx-muDctO0PUSOkYStLcEN31HM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * In this case would you pass the code block inside another wich contains the arguments from second element onward?

[19:16:58](#X1dd2_IB-0_eHITFQGHsQ-C2jDgG2PN8BVhVcoxXGfI) <hiiamboris>:
```
>> c: context [a: 1 b: 2]
>> reshape/with/sub ['CTX] [something CTX[a + b] something else] func [expr] [do bind expr c]
== [something 3 something else]
```

[19:17:00](#XfSRkEqm8U0pC3z9uyjHvP51RoJDc5MYiNDXMNgkTUg) <hiiamboris>:
pushed it

[19:21:01](#S5YnyWLdxvKh-WsCGUdYMG8qEXmn8kzJwl5D2PXlHBU) <hiiamboris>:
```
>> resomething: func [name input] [reshape/with/sub reduce [to lit-word! name] input func [expr] compose [do bind expr (name)]]
>> resomething 'C [something C[a + b] something else]
== [something 3 something else]
```

[19:31:22](#y8rSOmhLSFQfx8XQeRInamUuUMSyxuSqo4f6P8Z2Zb4) <hiiamboris>:
or this will be even faster if that matters
```
resomething: func [name input] [reshape/with/sub reduce [to lit-word! name] input :mybind] mybind: func [expr] bind [do bind expr get name] :resomething
```

[19:32:16](#0cChBiaVmk39suCjHGFJxA293u1hy8hlFD-yEBktB9E) <hiiamboris>:
* or this will be even faster if that matters
```
resomething: function [name input] [ctx: get name reshape/with/sub reduce [to lit-word! name] input :mybind] mybind: func [expr] bind [do bind expr :ctx] :resomething
```

[19:32:43](#Bcg4eYP4PDItipeIM5EK_hOuBKotBIDNqR8DgF969NA) <hiiamboris>:
* or this will be even faster if that matters
```
mybind: func [expr] bind [do bind expr :ctx] resomething: function [name input] [ctx: get name reshape/with/sub reduce [to lit-word! name] input :mybind]
```

[19:33:07](#TMrZqDVvvZuEzpeuNI6hTF-XYEZGDm03Jc-lnu0Wvy4) <hiiamboris>:
* or this will be even faster if that matters
```
resomething: function [name input] [ctx: get name reshape/with/sub reduce [to lit-word! name] input :mybind]
mybind: func [expr] bind [do bind expr :ctx] :resomething
```

[19:56:58](#yPKS6oGKn3SQ4tU6SdmRviWxRgKuuuYhSwuhtp2ODF0) <GiuseppeChillemi (GiuseppeChillemi)>:
* or this will be even faster if that matters
```
resomething: function [name input] [ctx: get name reshape/with/sub reduce [to lit-word! name] input :mybind]
mybind: func [expr] bind [do bind expr :ctx] :resomething
```

[19:58:10](#N4hBhIZUutpHntbvygcFIE7zfLKB52UnZQJMAKYp61s) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> ```
> >> resomething: func [name input] [reshape/with/sub reduce [to lit-word! name] input func [expr] compose [do bind expr (name)]]
> >> resomething 'C [something C[a + b] something else]
> == [something 3 something else]
> ```

Great work hiiamboris, my function have been retired without having been used but a couple of times.

[20:03:10](#OEbkPZSZR9o8sdEwmz4DmXh-M9LpuLlSsAE5EKTP3T4) <GiuseppeChillemi (GiuseppeChillemi)>:
Change It's name to RECOPLACE because it is a mix of REduce COmpose and rePLACE but selective Ì†æÌ¥£

[20:03:21](#jUhpRb4dAWjhLyp-_YF3woltpNPRCOwpPZ16UNYI8ds) <GiuseppeChillemi (GiuseppeChillemi)>:
* Change Its name to RECOPLACE because it is a mix of REduce COmpose and rePLACE but selective Ì†æÌ¥£

[20:36:58](#oJu0iuJz9tg5TY7IVu2ESrHRQalmrBi5dSdl3t7jJoE) <GiuseppeChillemi (GiuseppeChillemi)>:
Maybe I have another simple improvement. I need to some time to thing about It.

[20:37:22](#8OaVCxo9RI_8DsuxcFyh4K31geyxa96gZVR8dimQ2k8) <GiuseppeChillemi (GiuseppeChillemi)>:
* Maybe I have another simple improvement. I need some time to thing about It.

[21:08:19](#VAufbK3V0F43RTv-902Wd24zf5AJc7wi9kOkRIqGMOw) <GiuseppeChillemi (GiuseppeChillemi)>:
Here they are:

Improvement 1: with should accept :func in the block. You pass the current processed block element to the function and if It returns true, the operation is performed

[21:11:37](#12RAxPD35t5u2tuIDxYTsfe0RpnYUED2bvNzIsQDy48) <GiuseppeChillemi (GiuseppeChillemi)>:
Improvement 2: 
/Where 
Inside the block you put a block of elements for each custom grammar. If one of element of found or returns true, that actions Is performed

[21:13:00](#1dAS6rTlxpwgW-fCFyeasBQnqKazy4Il-ZKmKxuQ-UM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Improvement 2: 
/WHERE or /ANY
Inside the block you put a block of elements for each custom grammar. If one of element of found or returns true, that actions Is performed

[21:13:32](#uxKDlV8iaC5Ko03MfaoaDV_KtuEiHP6P6WdTzNhHFTA) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here they are:

Improvement 1: /WITH should accept :FUNC in the block. You pass the current processed block element to the function and if It returns true, the operation is performed

[21:14:30](#C7jERLE0X2_wPz1VfwW-FuMEPXpEaHLixleGDWByQG0) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here they are:

Improvement 1: /WITH should accept :FUNC in the block. You pass the block at current position to the function and if It returns true, the operation is performed

[21:17:53](#HxW0LGm_M3mcOfBU7vVLE7tETazaub9DZgmUTIrSJ5Y) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here they are:

Improvement 1: /WITH should accept :FUNC in the block. You pass the block at current position to the function and if It returns true, the operation is performed
Note: It would be good if you could return the block at the position of the element to be processed or NONE for no action.

[21:18:40](#1d-9xO_pFeicl1WxnOZLrabtm6zqRO_GSAYntGHhyRw) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here they are:

Improvement 1: /WITH should accept :FUNC in the block. You pass the block at current position to the function and if It returns true, the operation is performed
Note: It would be good if you could return the block at the position of the element to be processed or NONE/FALSE for no action.

[21:19:11](#8jr_GK_UTJmNUQtQUrULlW8WWBXRAHmTmleEj6G7dik) <GiuseppeChillemi (GiuseppeChillemi)>:
* Improvement 2: 
/WHERE or /ANY
Inside the block you put a block of elements for each custom grammar. If one of element of found or returns true or the block, that actions Is performed

[21:19:44](#Q5J6XUW_19TOUym-XJGVxBm0cbPdGbVIhb1y2-1e99A) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here they are:

Improvement 1: /WITH should accept :FUNC in the block. You pass the block at current position to the function and if It returns true, the operation is performed
Note: It would be good if you could return the block at the position of the element to be processed or NONE/FALSE for no action.

[21:40:29](#CHt-vxO6f2CQ9kJbauxeKfI0WkpEsPC7gYWLBXdeAMI) <GiuseppeChillemi (GiuseppeChillemi)>:
* Improvement 2: 
/WHERE or /ANY
Inside the block you put a block of elements for each custom grammar. If one of element if found or returns true or the block, that actions Is performed

[21:43:09](#taR1sWXXDNniyxLfmlySZ7CipHkaPVpVIsoc429kbDk) <hiiamboris>:
seems even less useful than the bloat I just removed :)

[21:47:21](#WbbJbG3f7HEDlDdo-i3ytDSkzhcljAgoDqSoE4HrUEs) <GiuseppeChillemi (GiuseppeChillemi)>:
I hade in mind some uses... One above all was pattern matching. You pass me the block and if I match the IDENTIFIER I do Its respective action. 


[21:47:29](#o4mbKdgYmrC70vF8VujeYtst2yDrVYvBlxEJ2Po30cs) <GiuseppeChillemi (GiuseppeChillemi)>:
* I had in mind some uses... One above all was pattern matching. You pass me the block and if I match the IDENTIFIER I do Its respective action. 


[21:48:58](#MZ2zPX69c3ZZr5XZ9eSiH1Gby6mPiCh8PCDlydUo0IY) <GiuseppeChillemi (GiuseppeChillemi)>:
You could avoid ANY Just let me use a function that identifies if id matches 

[21:49:13](#EilH1xgIV85inN3f7nXzILLuMV-aQSxXZYYWGKgZZlU) <GiuseppeChillemi (GiuseppeChillemi)>:
* You could avoid ANY Just let me use a function that identifies if it matches 

[21:51:08](#OW0csETTwaawqGu3qrpVzdgkQoSll0irwyxInu9JuQk) <hiiamboris>:
your description is extermely vague as well, so better give an example of input and output

[22:01:33](#qjMBAfWfgQXKOC3tOaL8Yxl8GCeC9dI0WYC02ezP7K4) <GiuseppeChillemi (GiuseppeChillemi)>:
Ok, tomorrow I'll do. 

[23:31:16](#3QES50aJSb9In7ftNR6JY6kMtlzbLtve0Ps63l_qBZs) <GiuseppeChillemi (GiuseppeChillemi)>:
```
X: func [block] [if all [word? block/1 find to-string block/1 "KEY1"] [block/2]]
reshape/with reduce [:X] [something NOTHERE[1 + 5] THIS-IS-KEY[1 + 2] something2]
```
Result:
```
[something NOTHERE[1 + 5] [3] something2]
```


[23:32:21](#AqKcPzFhsDzsgIJqy7aCfKgig4aMfRas_v4lNALp_LU) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
X: func [block] [if all [word? block/1 find to-string block/1 "KEY1"] [block/2]]
reshape/with reduce [:X] [something NOTHERE[1 + 5] THIS-IS-KEY1[1 + 2] something2]
```

Result:

```
[something NOTHERE[1 + 5] [3] something2]
```

[23:32:49](#S3hUxiv6u_g5v70yN5FlVWnONn9Cxy9qGB7h7apRbTo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
X: func [block] [if all [word? block/1 find to-string block/1 "KEY1"] block/2]
reshape/with reduce [:X] [something NOTHERE[1 + 5] THIS-IS-KEY1[1 + 2] something2]
```

Result:

```
[something NOTHERE[1 + 5] [3] something2]
```

[23:33:43](#JN6Q1l2j-6031A9UVUFSht61h8kUQH4g4b8s7SjxOiI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
X: func [block] [if all [word? block/1 find to-string block/1 "KEY1"] block/2]
reshape/with reduce [:X] [something NOTHERE[1 + 5] THIS-IS-KEY1[1 + 2] something2]
```

Result:

```
[something NOTHERE[1 + 5] [3] something2]
```
Reshape deletes the KEY at block position when passed as argument

[23:34:15](#4c6NnHW56_1M4yd4gcsYHmqvdovlup2ZYjGcWuzXdoQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here an example to implement FIND

```
X: func [block] [if all [word? block/1 find to-string block/1 "KEY1"] block/2]
reshape/with reduce [:X] [something NOTHERE[1 + 5] THIS-IS-KEY1[1 + 2] something2]
```

Result:

```
[something NOTHERE[1 + 5] [3] something2]
```

Reshape deletes the KEY at block position when passed as argument

[23:34:32](#0pxMFshEFvGQvoQrVEsn6KZW0JkjGJZ9t9lRJcMrNL4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here an example to implement FIND

```
X: func [block] [if all [word? block/1 find to-string block/1 "KEY1"] at block 2]
reshape/with reduce [:X] [something NOTHERE[1 + 5] THIS-IS-KEY1[1 + 2] something2]
```

Result:

```
[something NOTHERE[1 + 5] [3] something2]
```

Reshape deletes the KEY at block position when passed as argument

[23:36:05](#NWOJ5izLvK4N1qgfIdJZLVhP_QKcM8cgIw001U0uIvI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here an example to implement FIND

```
myfind: func [block] [if all [word? block/1 find to-string block/1 "KEY1"] at block 2]
reshape/with reduce [:myfind] [something NOTHERE[1 + 5] THIS-IS-KEY1[1 + 2] something2]
```

Result:

```
[something NOTHERE[1 + 5] [3] something2]
```

Reshape deletes the KEY at block position when passed as argument

[23:52:04](#QHcXFLidwetddwtvrBo2tlZhaqX9OfZFhK33JMGFm0M) <GiuseppeChillemi (GiuseppeChillemi)>:
(note, AT BLOCK 2 should be [AT BLOCK 2])

## 20-Nov-2023

[8:59:07](#eiB8IyBpYR15KizhDE1bdd3D7BET7BtrHMOPvRp7tJo) <hiiamboris>:
insomniac Giuseppe :)

[9:01:29](#8PTLDSpggcRtWYLKTvVxkD6wSdh96ooDCas7b95Uu_k) <hiiamboris>:
you should already be able to do this unwise thing, by providing some rule e.g. `reshape/with [[set x skip if (find form x "KEY1")]]`

## 20-Jan-2024

[19:40:52](#6uiSTeOGVftKnHdBKeGbJ5JqCQ8n2uzafZnMc2qDsY8) <hiiamboris>:
![https://tchncs.de/_matrix/media/v3/download/tchncs.de/0366526497daa809b4a9b4535051cd0573380184](https://tchncs.de/_matrix/media/v3/download/tchncs.de/2e23cdbb8dcfff274dd51e1b17493939e0ed5e1a)

[19:41:03](#Y2DEzBBxRwaZnA1Y_AXdb5UC6IOK4HYg2uin7DYygZA) <hiiamboris>:
testing draw clipping speed...

[19:52:36](#mxzq_vHUekXv0-U_qt-IzmiR_gpmI4NdH57Z2sDR2E8) <hiiamboris>:
my client can't even render it lol

[19:52:37](#aEwSb49dZnH0MEVLa-QJmm2PSVV7WhyERH0Ruo8vUSk) <hiiamboris>:
if it glitches for you too, the gif is [here](https://link.storjshare.io/raw/jwtiabvp6myahg3zzf3q5zoii7la/gif/GIF%2020-Jan-24%2022-38-21.gif)

[20:01:19](#oTmPV8BepKBhrSWm0_M9VlauCgVkKaea920cmICWc1w) <greggirwin (Gregg Irwin)>:
That's a very cool dissolve effect. :^)

[20:07:34](#fNsqHnoJAzAc9aMWik02UKMUMqThXEOJzuFaACiT50Q) <hiiamboris>:
had to turn text into image, otherwise text itself is too slow :)

[21:04:05](#nMMlKW-atwLXY7gWmramCuZDVuRYj8B7Vgv-0HVh71U) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> had to turn text into image, otherwise text itself is too slow :)

Use Vulkan or OpenGL

[21:04:12](#uPM8hC9JX-58YlVMJIDk8PSwNnTU5ius-U7eAsq3hZc) <GiuseppeChillemi (GiuseppeChillemi)>:
Ì†ΩÌ∏Å

[21:38:54](#9P5GEb6rJTXgXVJVvpH7crDJJnSBz72frW691NpKPes) <hiiamboris>:
well, it's D2D :)

## 21-Jan-2024

[22:02:14](#62AFi6SDtX54nIw_7LevBhLiIBpti7MVKN78WLkSwdE) <GiuseppeChillemi (GiuseppeChillemi)>:
well, it's D2D :)

[22:02:43](#QSPfJ9JP3qrzHnHpchSF2hBYtiRUER5ziY18yPaIZsI) <GiuseppeChillemi (GiuseppeChillemi)>:
well, it's D2D :)

[23:01:04](#VVtoY6VDWzJfQ12OQLgAcuj6ffBY7ZC86WrPyacOHLk) <GiuseppeChillemi (GiuseppeChillemi)>:
Could please check this For-Skip implementation? It is called [For-Record](https://gist.github.com/GiuseppeChillemi/2d9f3339eb2e96b1847e90d0ab0f1a98)

[23:01:45](#Pl4cl93Oo1YCKieTQLc0vO0Wl-rgnxhfYYUKOR0pvHM) <GiuseppeChillemi (GiuseppeChillemi)>:
Here  is a little test:
```
n: [1 2 3 4 5 6 7 8 9 10 11 12 13] 
angel/for-record n 3 [
	probe first n
]
1
4
7
10
13
```

[23:02:06](#SHqRly7aBJZBiYzv-yp3c3R1-R0xvQ5pPwRSLVJWEWQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Could please test this `For-Skip` implementation? It is called [For-Record](https://gist.github.com/GiuseppeChillemi/2d9f3339eb2e96b1847e90d0ab0f1a98)

[23:02:14](#kaeL6D8lMYbV82BCZb-rTr1ujIKzKNwVvbkNNOVzJiI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here  is a little test:

```
n: [1 2 3 4 5 6 7 8 9 10 11 12 13] 
for-record n 3 [
	probe first n
]
1
4
7
10
13
```

[23:02:21](#mpAW84sXyqiiLG9fdOkbA00_t-5i95w4ARC2Epryvyk) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here  is a little test:

```
n: [1 2 3 4 5 6 7 8 9 10 11 12 13] 
for-record n 3 [
	probe first n
]

1
4
7
10
13
```

[23:50:55](#_SmzAHT1Z0v4FskjIqHTKRA8j7Ohu1TyKUhcYkQPI3U) <GiuseppeChillemi (GiuseppeChillemi)>:
Made a little modification, please reload

## 22-Jan-2024

[0:13:37](#zFYLlYUzZh7xXJB7KTg1PU_IjUwlpeUfV717xnqHvwM) <GiuseppeChillemi (GiuseppeChillemi)>:
2 words are available: `return-value val` and `break-here`. the first forces the function to return a series or NONE. (Maybe I wll extend to all the other datatypes), the latter breaks the upper loop and the function returns the series at current position.

[0:15:08](#Y5ponGHYA4PvIc0O_rzNVpqvJCefuGSlBsVBSavZM9U) <GiuseppeChillemi (GiuseppeChillemi)>:
There is a little bug either in my code or in Red. I set the word passed bound to the original context but at the exit of the function it is at the starting position. When I will fix it, `BREAK-HERE` could set it at the current series position

[0:15:57](#rBiQkCZM9K0XNVLm9pcw4TXaAuoXD0U_y75BHik0lv8) <GiuseppeChillemi (GiuseppeChillemi)>:
 * 2 words are available: `return-value val` and `break-here`. the first forces the function to return a series or `NONE`. (Maybe I wll extend to all the other datatypes), the latter breaks the upper loop and the function returns the series at current position.

[0:16:30](#pik0ArRs0B73tcy7IVvY22ujKQIkzq-ZT3zU_BLGA9Q) <GiuseppeChillemi (GiuseppeChillemi)>:
 * 2 words are available: `return-value val` and `break-here`. the first forces the function to return a series or `NONE`. (Maybe I wll extend to all the other datatypes), the latter breaks the upper loop and the function returns the series at current position.
You will find demo code at the end

[0:51:16](#yAoSvf9RQzm3cTpmGyYmtOs-3d13rTYaFB0xA17TPR4) <GiuseppeChillemi (GiuseppeChillemi)>:
* Could you please test this 
For-Skip implementation? It is called For-Record

[0:53:53](#AFdN6F5_ZIaQg-_vPktdif8mpwdbJ3_7aU5H9FfPDwo) <GiuseppeChillemi (GiuseppeChillemi)>:
* There is a little bug either in my code or in Red. I set the word passed bound to the original context but at the exit of the function it is at the starting position. When I will fix it, 
BREAK-HERE could set the series word at the current BREAK position instead of returning as result of the function 

[2:15:27](#xrn3SkpI53DvTQOBulHG_fDfokMQn4LSkben2W7huG8) <greggirwin (Gregg Irwin)>:
I don't see any code to test.

[2:35:53](#RmisBQgfkyhQd5Mm47yr2nRy2bOS-LOpUCHVUHdu3zA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Could you please test [this For-Skip implementation](https://gist.github.com/GiuseppeChillemi/2d9f3339eb2e96b1847e90d0ab0f1a98)? It is called For-Record

[2:36:11](#R9AzFQh_9Pf00sw0fWUbcQ-vYhk0wx6eHwtHXpGymH0) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> I don't see any code to test.

Added the link, I forgot to insert it

[3:06:43](#3M4U8ZMOU79YN8TojOj55nQt8oB0JS4Jqz4oe5-hZfk) <GiuseppeChillemi (GiuseppeChillemi)>:
note: During the coding of the `ENCONTEXT` I felt the necessity of a `/safe` `reduce`  refinament so that words set to functions are not active and also paths  ointing to functions`. Unless there is a already command to reduce without activating function.

[3:07:00](#VpRKW6qhnwz98RyeAWh9dNbwg0pnMA6c43EMJAFQcxQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * note: During the coding of the `ENCONTEXT` I felt the necessity of a `/safe` `reduce`  refinament so that words set to functions are not active and also paths  ointing to functions\`. Unless there is a already command to reduce without activating function. Is there any?

[3:07:40](#qY0EsIVTGu_UeyT9hc5DQxe9gaFr7BxcTY0EvGrxWLw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * note: During the coding of the `ENCONTEXT` I felt the necessity of a `/safe` `reduce`  refinament so that words set to functions are not active and also paths  ointing to functions\`. Unless there is a already command to reduce without activating function. I can do this with some code but it would be slow. Is there any?

[8:25:55](#fJEWSHbyNKHKqlkD02MiGyLlQjaVB2WLVEoQ763Ovqs) <hiiamboris>:
`do-what-I-want` routine :)

[9:56:21](#EJq8Kp_OHqNUod6NYeJ11_-RW2HjNCiZX6wUzn6vveE) <GiuseppeChillemi (GiuseppeChillemi)>:
* note: During the coding of the 
ENCONTEXT I felt the necessity of a /safe reduce  refinament so that words set to functions are not active and also paths pointing to functions`. Unless there is a already command to reduce without activating function. I can do this with some code but it would be slow. Is there any?

[12:53:35](#fZKnsvTsu5CIjkV_QNhRxP7t_sfueojIyVp4Ruucceo) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> `do-what-I-want` routine :)

I ad already fixed that problem... when you code at 4:00AM these things may happen

[12:53:42](#rMc8L8ungr0thOkM9bMm5e1GBnhvajeUCWhYIWSHFqg) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> `do-what-I-want` routine :)

 * I had already fixed that problem... when you code at 4:00AM these things may happen

[18:16:23](#4Yv2IlZHl2B7EeqIWOpImkIkioXZoYchji1aPazMgC8) <greggirwin (Gregg Irwin)>:
> <@giuseppechillemi-59045d00d73408ce4f5bcd9d:gitter.im> Could you please test [this For-Skip implementation](https://gist.github.com/GiuseppeChillemi/2d9f3339eb2e96b1847e90d0ab0f1a98)? It is called For-Record

You may recall that R2's `forall/forskip` are mezzanines, so you can look at those. They're much simpler You do a lot with context and binding which, from the outside, seems like it makes for a lot more work. It may be necessary for what you want to achieve, so it's not a criticism. One thing I noted in a quick test of yours is that it doesn't support `break/return`. No result from that.

[20:17:31](#HXr6HbhhqTqX85-bvWeu2pWBMPu5NlIgjoByScI2Ofw) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> You may recall that R2's `forall/forskip` are mezzanines, so you can look at those. They're much simpler You do a lot with context and binding which, from the outside, seems like it makes for a lot more work. It may be necessary for what you want to achieve, so it's not a criticism. One thing I noted in a quick test of yours is that it doesn't support `break/return`. No result from that.

They are called `return-value` and `break-here` because I need to undrstand the implications of breaking inside another loop. What will break? LOOP or the WHOLE function? Is there a way to catch that call?

[20:19:06](#KL0Zbl_bcTU0TBCb2q4lCSRaC7Ce6VwVcN4lw09GjaQ) <GiuseppeChillemi (GiuseppeChillemi)>:
About contexts, I simply create 2 contexts, one with my custom functions, another with just the word with the series. Why? Because I don't have a function that selectively √πbinds just one word (or more)

[20:19:14](#boKkOCsyFM0Y7fKY8J56guSvyMXgMXOcmWK1QS_enFY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * About contexts, I simply create 2 contexts, one with my custom functions, another with just the word with the series. Why? Because I don't have a function that selectively binds just one word (or more)

[20:32:12](#Pvnqu0XZdnsS4gEw6GzWGgDavqlluOk7fIlHGinONYY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * About contexts, I simply create 2 contexts, one with my custom functions, another with just the passed word with the series. Why? Because I don't have a function that selectively binds just one word (or more)

[21:04:56](#Az02qbfMypWeEZcm393bUu70jVrEbV08ua8GiMuk5IE) <hiiamboris>:
https://codeberg.org/hiiamboris/red-common/src/bind-only.red
https://codeberg.org/hiiamboris/red-common/src/branch/master/selective-catch.red

[21:05:20](#BAtFryBtmtuHZgd2wf6qATs9bB51iT8pkp-RyF-isek) <hiiamboris>:
* https://codeberg.org/hiiamboris/red-common/src/branch/master/bind-only.red
https://codeberg.org/hiiamboris/red-common/src/branch/master/selective-catch.red

## 7-Feb-2024

[23:37:17](#GWv0LE7iDQmVT4wcqqR0Yif_kKY-wXR7bPZCcn72XZg) <GiuseppeChillemi (GiuseppeChillemi)>:
This is a function to insert into a panel some faces which VID should position relative to the panel size, after the gui has been created.

```
insert-into-panel: func [
	the-panel [object!] 
	elements [block!]
	/local
	size
	p
	l
] [
	[STATUS: TESTED]
	l: layout compose/deep [
		p: panel (get-panel-size the-panel) [ 
			(elements)
		]
	]
	append the-panel/pane p/pane 
]

view [
	lab: text "Size: " txt: text 50x20 "" return
	
	button "Fill panel" 150x50 [
		txt/text: to-string get-panel-size dest
		
		insert-into-panel dest [
			Text "Hello!" return
			Button "Hey, hit me!" [probe "Thank you"] return
			Button "Don't hit me!" [probe "Why you did this??"] return
		]
		
		
	]
	dest: panel 150x130 [
		
	] return
	
	
]
```


[23:37:51](#RJG-vYaNvYoLcUrgTEfPaxUPGSwvBErSlaBOnMm0yWk) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is a function to insert into a panel some faces which VID should be positioned relative to the panel size, after the gui has been created.

```
insert-into-panel: func [
	the-panel [object!] 
	elements [block!]
	/local
	size
	p
	l
] [
	[STATUS: TESTED]
	l: layout compose/deep [
		p: panel (get-panel-size the-panel) [ 
			(elements)
		]
	]
	append the-panel/pane p/pane 
]

view [
	lab: text "Size: " txt: text 50x20 "" return
	
	button "Fill panel" 150x50 [
		txt/text: to-string get-panel-size dest
		
		insert-into-panel dest [
			Text "Hello!" return
			Button "Hey, hit me!" [probe "Thank you"] return
			Button "Don't hit me!" [probe "Why you did this??"] return
		]
		
		
	]
	dest: panel 150x130 [
		
	] return
	
	
]
```

[23:41:13](#SUgOYZybEK0ELJin_0XxdvZYGOU7X9R8LHCGc9dRhdQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is a function to insert into a panel some faces which VID should be positioned relative to the panel size, after the gui has been created.

```
get-panel-size: func [
	panel [object!]
] [
	if face? panel [
		if panel/type = 'panel [
			panel/size
		]
	]
]
insert-into-panel: func [
	the-panel [object!] 
	elements [block!]
	/local
	size
	p
	l
] [
	[STATUS: TESTED]
	l: layout compose/deep [
		p: panel (get-panel-size the-panel) [ 
			(elements)
		]
	]
	append the-panel/pane p/pane 
]

view [
	lab: text "Size: " txt: text 50x20 "" return
	
	button "Fill panel" 150x50 [
		txt/text: to-string get-panel-size dest
		
		insert-into-panel dest [
			Text "Hello!" return
			Button "Hey, hit me!" [probe "Thank you"] return
			Button "Don't hit me!" [probe "Why you did this??"] return
		]
		
		
	]
	dest: panel 150x130 [
		
	] return
	
	
]
```

[23:42:01](#waHGWhvVPV5H74pYk1NM4h172Zfdzvg06XBI34OEOd4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is a function to insert into a panel some faces which VID should be positioned relative to the panel size, after the gui has been created.

```
get-panel-size: func [
	panel [object!]
] [
	[STATUS: TESTED]
	if face? panel [
		if panel/type = 'panel [
			panel/size
		]
	]
]
insert-into-panel: func [
	the-panel [object!] 
	elements [block!]
	/local
	size
	p
	l
] [
	[STATUS: TESTED]
	l: layout compose/deep [
		p: panel (get-panel-size the-panel) [ 
			(elements)
		]
	]
	append the-panel/pane p/pane 
]

view [
	lab: text "Size: " txt: text 50x20 "" return
	
	button "Fill panel" 150x50 [
		txt/text: to-string get-panel-size dest
		
		insert-into-panel dest [
			Text "Hello!" return
			Button "Hey, hit me!" [probe "Thank you"] return
			Button "Don't hit me!" [probe "Why you did this??"] return
		]
		
		
	]
	dest: panel 150x130 [
		
	] return
	
	
]
```

[23:57:17](#WgLQe_Dbyf7KueoMdyxoGjjyKrCF4FaJ3a72lSWLwws) <greggirwin (Gregg Irwin)>:
:^) "Why did you do this?" I like when running examples is fun.

## 8-Feb-2024

[1:04:47](#vJSASVXFeamTWFBa4axg7fLmfoI3bIjKA_gADtn-v6A) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is a function to insert into a panel some faces which VID should position relative to the panel size, after the gui has been created.

```
get-panel-size: func [
	panel [object!]
] [
	[STATUS: TESTED]
	if face? panel [
		if panel/type = 'panel [
			panel/size
		]
	]
]
insert-into-panel: func [
	the-panel [object!] 
	elements [block!]
	/local
	size
	p
	l
] [
	[STATUS: TESTED]
	l: layout compose/deep [
		p: panel (get-panel-size the-panel) [ 
			(elements)
		]
	]
	append the-panel/pane p/pane 
]

view [
	lab: text "Size: " txt: text 50x20 "" return
	
	button "Fill panel" 150x50 [
		txt/text: to-string get-panel-size dest
		
		insert-into-panel dest [
			Text "Hello!" return
			Button "Hey, hit me!" [probe "Thank you"] return
			Button "Don't hit me!" [probe "Why you did this??"] return
		]
		
		
	]
	dest: panel 150x130 [
		
	] return
	
	
]
```

## 12-Feb-2024

[19:26:02](#lhDfzGbkyJaYxobXuqdvF2KfBGoGE4Eax9pmVJqnKak) <GiuseppeChillemi (GiuseppeChillemi)>:

Again, parse seen in a different way, as a powerful navigation tool:

```
nav: func [
	"Navigate using parse and set the return position at RETURN-HERE word"
	data [series!]
	navigation [block!]
	/local
	ctx
] [
	ctx: context [return-here: none]
	parse data bind navigation ctx 
	ctx/return-here
]
```

```
probe nav [a b c [x y ["Nice to see you here!"] z] f] [to block! into [to block! return-here:]]
```
Result:
```

```
[["Nice to see you here!"] z]
```


[19:26:39](#6PoOOaHc8wRstAmExGcOfIGP7lyTyhchcf8JFNk8Yq4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Again, parse seen in a different way, as a powerful navigation tool:

```
nav: func [
	"Navigate using parse and set the return position at RETURN-HERE word"
	data [series!]
	navigation [block!]
	/local
	ctx
] [
	ctx: context [return-here: none]
	parse data bind navigation ctx 
	ctx/return-here
]
```

```
probe nav [a b c [x y ["Nice to see you here!"] z] f] [to block! into [to block! return-here:]]
```

Result:

```
[["Nice to see you here!"] z]
```


## 5-Oct-2024

[2:30:52](#vR7Id_OArfreUCAf5qUVUlrmLcOXvV4Q8mb8VlV6GXE) <GiuseppeChillemi (GiuseppeChillemi)>:
What you think about this?
It is a function to run code with all locals but also avoiding the constant reconversion to function in case of loop (you save 10x  time)


```
isolating: func [
	code [block!] "Code to run in double braces"
] [
	case [
		block? :code/1 [code/1: function [] :code/1]
		not function? :code/1 [do make error! "code block does not contain function or block!"]
	]
	code/1
]
```

To run a code, simply put it on double braces:

```
a: 0 b: 0 c: 0
isolating [[loop 10000 [a: 1 b: 1 c: a + b]]]
Print ["a: " a " b: " b "c: " c ]
```
Result:
```
a:  0  b:  0 c:  0
```

Do you see a better way for this purpose?

[4:34:55](#JIlobpFcTAvRkbUuzwjmAltLNWjMj2d4VnAxYO_NIG8) <greggirwin (Gregg Irwin)>:
That's a nice solution.

[9:53:45](#EnZal_wejREzDohBueNiVL7LzaUTBtVVjfcvQk13pw4) <GiuseppeChillemi (GiuseppeChillemi)>:
I have used this tecnique for functions which are defined inside other function, to avoid the recreation at each run.

[9:59:51](#6zBzMbdqzX8aNv-sinXACP0YYCS9R3_EZpx2g0pJ1SE) <GiuseppeChillemi (GiuseppeChillemi)>:
It is also the base for loop optimization, where you change it with another without init and conditional checking of it.

[10:00:28](#DUJn5ZeQUJmcAnvH4FT6ydo3Ltnl1U7CDYl6173d46E) <GiuseppeChillemi (GiuseppeChillemi)>:
* It is also the base for loop optimization, where you change it with another without init and conditional checking of it, or any check that could change at runtime.

[12:12:33](#6gH9uRvYeNMbZoFoQxxccMRgpbP7i2bzu_NKkViBcuM) <GiuseppeChillemi (GiuseppeChillemi)>:
Just as curiosity, I have tested how much costs looping a code or looping the same code passing from a function, here is the result:

```
f1: [loop 1000000 [a: 1 b: 1 c: a + b]]
f2: compose/deep [loop 1000000 [(func [] [a: 1 b: 1 c: a + b])]]

recycle/off
clock f1
clock f2
```
Results
```
356 ms	[loop 1000000 [a: 1 b: 1 c: a + b]]
518 ms	[loop 1000000 [func [][a: 1 b: 1 c: a + b]]]
```

[12:16:04](#3zauGDrBrhpb-MIBryO4Z2sQXIqwIiGBrdA_4mS3z6U) <hiiamboris>:
> Do you see a better way for this purpose? 

https://codeberg.org/hiiamboris/red-common/src/branch/master/hide-macro.red

[12:20:44](#WK8enY9fH64ZMks0-EXh79QRs4gU4c0W35Vx1ONfnuA) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> > Do you see a better way for this purpose? 
> 
> https://codeberg.org/hiiamboris/red-common/src/branch/master/hide-macro.red

I will study it later

[12:20:48](#5Q9PIgjEeIGhNlreg_zFIT_VIgLuts9N1wkI36tWGIY) <GiuseppeChillemi (GiuseppeChillemi)>:
Thank you

[12:21:23](#XkVf451IZ4VAFasWjj_GHRLdQdw0ZD9LDwXeGVMhJMw) <GiuseppeChillemi (GiuseppeChillemi)>:
I have tested my code with Rebol3, using `DT` instead of clock. Here are the results

[12:21:57](#bFgPpPt9WrzXeY-mlrNl2BjNOgfk0-tJxT4WJ2fhCwM) <GiuseppeChillemi (GiuseppeChillemi)>:
```
f1 -> 0:00:00.135844
f2-> 0:00:00.144832
```

[12:22:04](#d6W2Qw4mPcSJRyuZFT7mCB6Grbhc5uUuZp4o9eHO7Uk) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
f1 -> 0:00:00.135844
f2 -> 0:00:00.144832
```

[12:22:13](#EtBDp51OVo4dSdwAw-Hps5HOYHjhck5pjV6S2yQ0ucQ) <GiuseppeChillemi (GiuseppeChillemi)>:
About 3 time faster

[14:19:49](#p_BjEih3St73R-jb-rkXeGq35xyXZix1vFAgCrWNneU) <hiiamboris>:
I don't recall ever needing this outside of global or `context` space. So not optimized for your case. Speaking of which, what is the use case?

[14:22:16](#b8wHGlsS3HTMXraF2uLZ-yIlMRnwm7wEuRf1CYQpY_U) <hiiamboris>:
Something I did along the lines of your idea was:
```
;; how to inline function or hash right into the function, though with a little slowdown
embed: func [expr [block!]] [
	either single? expr [:expr/1][first head clear change/only expr do expr]
]
```
Though decided it's not worth it, and I'd rather `reshape` the function body at construction time.

[14:26:16](#rIjvTLcGa8eEpLnFVbJ9idL5GhsFL1aUTcAr8gZtvYA) <hiiamboris>:
* Something I did along the lines of your idea was:
```
;; how to inline function or hash right into the function, though with a little slowdown
embed: func [expr [block!]] [
	either single? expr [:expr/1][first head clear change/only expr do expr]
]
```
It evaluates the block on the first run, then always just fetches the result.

Though decided it's not worth it, and I'd rather `reshape` the function body at construction time.

[17:41:01](#7XQcFItCrgUESEi-JBN4SAur5KbdWUuKtxXfnEnb760) <greggirwin (Gregg Irwin)>:
This was also why `use` existed in Rebol.

[17:43:16](#6fUKbyuxGodJSH1VeCRMaHzzJpNET31dTpKrw7FTdb0) <hiiamboris>:
Explicitness of words is not the brightest part of `use` though.

[17:43:16](#RHBbInFasctvRsrppNXdBn2eRFI2z1W9zL-9_ISWxN0) <hiiamboris>:
* Explicitness of words is not the brightest part of `use` design though.

[17:55:31](#WPujFVl0Lz-U7C6sZCDTwl-50kWcFLsbGCyH9gUeaJ0) <hiiamboris>:
Or spelling...

[17:58:12](#lGO-J-HwXoQmRDi_i5FsPL5Chhvn_i7AtksmoKpHrp0) <hiiamboris>:
I realized once that I'm using `batch space [code-that-refers-to-space]` pattern waaaay more than initially expected, so I looked for words that may replace the vague `batch`. `use` or `using` were finalists, but no matter how I liked that `use` is only 3 letters, `using space [code]` read so much better that I decided on `using` word.

[19:43:11](#wMGh7XCmnqugA02KvCdiBnTUAC3JQUU4r9E2fjZMG8A) <GiuseppeChillemi (GiuseppeChillemi)>:
I need it when developing VID panels. I often need words and don't want to pollute the main context of the layout or risk leaking words

[19:50:28](#EKBmA00MUiUyZrZeQYUXl6sBPSV0UuYhHfo-2fBsDKY) <hiiamboris>:
You mean for actors?

[19:50:48](#dwm2W4bebTjtC21Yk66WmHv7w04Iwmo4-vmc-cDEtJw) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes

[19:53:02](#ksF84x7xeE2disHWlCIXlG9g4mbZwKIBUFqYyMt5E-Q) <GiuseppeChillemi (GiuseppeChillemi)>:
Also, sometime ideas suddenly appears, then I create and isolated zone, develop there and when I end, I create functions, move words to contexts and clean the area.

[19:55:42](#zRSpz0XsVJzDG3t1Mu0Y3Jwfq2k68QuUHoGSwZh7a78) <GiuseppeChillemi (GiuseppeChillemi)>:
I will add an OFF refinement to not run the section. It is needed to create multiple prototypes of code on place and test each one. 

[19:57:18](#eqDtss1FbPe6wEyMQSOV6FvzZm6F3zxmMORqDiVJQlU) <GiuseppeChillemi (GiuseppeChillemi)>:
You may think it is strange but if I move away from the area I had the idea into, the idea vanishes. So I need to create an isolated area just there.

[20:01:03](#5LDiXOJLPG3VZep9vKvmA1Bp-xnVFE9uoTkYxL00HR8) <greggirwin (Gregg Irwin)>:
Naming is always hard. `Scope`? But GiuseppeChillemi (GiuseppeChillemi) 's approach, to collect set words removes the naming problem entirely. Not perfect, of course, given `set` use, but covers a lot of ground. Could be combined as well. Something like `env` has a similar meaning, but needs larger design thinking, as that also applies, for me, in creating and merging environments.

## 6-Oct-2024

[16:44:19](#gNEXm9RUiSLNBJSnHCS3RoUJbC2JKJCXTMYt1MVDnuI) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> > Do you see a better way for this purpose? 
> 
> https://codeberg.org/hiiamboris/red-common/src/branch/master/hide-macro.red

 Reading it just now, I see we all face the same problems, sooner or later.

## 8-Oct-2024

[1:56:58](#1EBH4GGRl6wmLkA7-32n1I4Zrwx1loq2sdMRLFkRFV4) <GiuseppeChillemi (GiuseppeChillemi)>:
I prefeer grouping the functions I create and use in multiple single files per category. I face the problem that the more they are, the more I risk polluting the `system/words` context with unused functions and eventually leaking words. To solve this problem, this night I have spent 20 minutes to create an `include-function` which can load one or more functions from a single file. Inside you can find an `copy-function` you can use with `compose` to load a function in an object

[1:57:17](#6BTZsVzt4-oTbqobrUsQMBddRxhZkpgRcbYae7CGKDA) <GiuseppeChillemi (GiuseppeChillemi)>:
Opinions are welcome: https://gist.github.com/GiuseppeChillemi/afa67bf2b87e64dcf383100cdc45c357

[1:58:13](#reu1iK9swNT04iDORENHK9WsliHAl5DOObAe5nYif8U) <GiuseppeChillemi (GiuseppeChillemi)>:
It is still the first version and does not cover `make function! []` 

[2:00:27](#1KC-J-EkwPDCCmz7DEttCylKFI_n8M6BiJ48MBNyrrc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I prefeer grouping the functions I create and put them in multiple single files per category. I face the problem that the more they are, the more I risk polluting the `system/words` context when `LOAD`ing, with unused functions and eventually leaking words. To solve this problem, this night I have spent 20 minutes to create an `include-function` which can load one or more functions from a single file. Inside you can find an `copy-function` you can use with `compose` to load a function in an object

[2:00:43](#-nhGosG332TtjLN6Q5yrLYDAyKRTAkagbMtqka5rHuE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I prefeer grouping the functions I create and put them in multiple single files per category. I face the problem that the more they are, the more I risk polluting the `system/words` context when `LOAD`ing, with unused functions and eventually leaking words. To solve this problem, this night I have spent some time to create an `include-function` which can load one or more functions from a single file. Inside you can find an `copy-function` you can use with `compose` to load a function in an object

[2:10:07](#ej0622BppqlCOqt2HON43-DuLQs1H3l08k6ofa5cHkg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I prefeer grouping the functions I create and put them in multiple single files per category. I face the problem that the more they are, the more I risk polluting the `system/words` context when `LOAD`ing, with unused functions and eventually leaking words. To solve this problem, this night I have spent some time to create an `include-function` which can load one or more functions from a single file. Inside you can find an `copy-function` you can use with `compose` to load a function in an object as `context compose [myfunction: (copy-function load %library quote myfunction:)]`

[7:14:29](#FiQxnHa8hhPBY-7eugEAVaNm5Olc-lL8-zec3u5dkxY) <hiiamboris>:
If you're `load`ing it, you're polluting `system/words` anyway

[8:02:38](#aWvhmbSvWkbKsLvvErUI1_hEZkS8k1dTzhhyIrV2s_Y) <GiuseppeChillemi (GiuseppeChillemi)>:
You are right, Red has no unbound block of words, while R3 can load a block without adding the words.

[8:03:58](#FsdrHrObW0SSu0GXlIdVZtEg0KiO1FVM9eleHh5FhwU) <GiuseppeChillemi (GiuseppeChillemi)>:
However, in this case they should be UNSET.

[8:05:45](#gEYzhCrf5iTt5A1MSREwH-klvNgiUOhtsY0sw4chH9k) <GiuseppeChillemi (GiuseppeChillemi)>:
To you have a suggestion how to implement without loading the block and manually parsing the string?

[8:06:00](#17KpnRJVn011mKl232sr1XOT1Dr1Of3JHug-lnoYvFM) <GiuseppeChillemi (GiuseppeChillemi)>:
* To you have a suggestion how to implement without loading the file and manually parsing the string?

[8:06:12](#cMT37r2mN_O3iP_jQpdkpAPv66v2kc7g0B2Z0HdFjwQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* To you have a suggestion how to implement it without loading the file and manually parsing the string?

[8:10:59](#Fs1TXNjw73iuhWbfdOVGwwcqrPY1j8aNIdLJLE7BYUg) <GiuseppeChillemi (GiuseppeChillemi)>:
* Do you have a suggestion how to implement it without loading the file and manually parsing the string?

[8:13:19](#qJay7o8PpqYXDFte3oVj7howAfumevEBRWFOCuWwbCM) <hiiamboris>:
Why even bother? This sounds like *purely theoretical issue*

[8:15:16](#y6QqgxS0BXPQZtSSgHasCLUCP18DZMBGHg8W8dNyJhQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Just for the pleasure to implement it

[8:16:02](#OjMjnB7YUzviluteWFeYe9KKysgoXHJOrG2EskgofY8) <hiiamboris>:
OK, then have the pleasure of pioneering it ;)

[8:50:10](#CmKb1L970i82wWYMrE8hauFU9dVXT5NuYFktroOwFXA) <GiuseppeChillemi (GiuseppeChillemi)>:
Pre-lexer? Otherwhise I see only a parse solution to match opening and closing brackets, stringa, comments...

## 21-Oct-2024

[0:49:03](#HG59fYTHQOKeL3Dwd-zgcBw6pzaEyFhpa0dB4b8vTTY) <GiuseppeChillemi (GiuseppeChillemi)>:
This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks
	;TBD: levels

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 

]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

 `CMP = COMPOSE`
 `CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explainig




[0:49:31](#mlD6leYOMg52josX84IhBCoa7q3-kXCpSpE0BtjQO8U) <GiuseppeChillemi (GiuseppeChillemi)>:
Here an example:

[0:53:01](#szNGUgBBvYYsjglr_I_4Gc4HVmFi83PSRm_ukvTnpbQ) <GiuseppeChillemi (GiuseppeChillemi)>:
```
button-actor: [Print "I exists"]

panel: [
	
	style Bt2: Button 10x10
	
	CMP/FACE/('Bt2) "Hello" CMPO/ACTORS/(button-actor) with [size: CMP/IN/(150x20)]
]
```
First filter:
```
compose-where/group panel 'FACE
probe panel

;result:

[
    style Bt2: Button 10x10 Bt2 "Hello" CMPO/ACTORS/(button-actor) with [size: CMP/IN/(150x20)]
]
```
Second Filter
```
compose-where/group panel 'ACTORS
probe panel

;Result:

[
    style Bt2: Button 10x10 Bt2 "Hello" [Print "I exists"] with [size: CMP/IN/(150x20)]
]

```

Third filter, using DEEP

```
compose-where/group/deep panel 'IN
probe panel

;Result and final panel

[
    style Bt2: Button 10x10 Bt2 "Hello" [Print "I exists"] with [size: 150x20]
]
```





[0:56:23](#uNWsvz3RFoib5BkUM-LiOFs6qm96aXtadH34FlzAUoI) <GiuseppeChillemi (GiuseppeChillemi)>:
This is the preliminary version as it will add LEVELS, BLOCK flagging and BLOCK names

[0:57:27](#57iUid_sGPfY_Ky5Ao8NV5ZPaW0ljMB6yGLnZZeUzcw) <GiuseppeChillemi (GiuseppeChillemi)>:
(Note, I do not now why `parse` `CHANGE` removes the `LF` suggestions are welcome to avoid it)

[0:57:49](#PuZfe9fx-1VtK4-dkvzoyOlT3D4aCf6YgyWZInDoMBs) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is the preliminary version as it will add LEVELS, BLOCK flagging and BLOCK names and `UNSET!` results

[0:58:33](#H7vi5rYTF-7HQ2Zx9L17h3-1lNZdL8CAGJeIkxX-RH0) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 

]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explainig

[0:59:52](#qGhDMe6hyouXjRyI17MinkZAxkn8RCk3sB0xH7_ICow) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
button-actor: [Print "I exists"]

panel: [
	
	style Bt2: Button 10x10
	
	CMP/FACE/('Bt2) "Hello" CMPO/ACTORS/(button-actor) with [size: CMP/IN/(150x20)]
]
```

First filter:

```
compose-where/group panel 'FACE
probe panel

;result:

[
	style Bt2: Button 10x10 
	Bt2 "Hello" CMPO/ACTORS/(button-actor) with [size: CMP/IN/(150x20)]
]
```

Second Filter

```
compose-where/group panel 'ACTORS
probe panel

;Result:

[
	style Bt2: Button 10x10 
	Bt2 "Hello" [Print "I exists"] with [size: CMP/IN/(150x20)]
]

```

Third filter, using DEEP

```
compose-where/group/deep panel 'IN
probe panel

;Result and final panel

[
	style Bt2: Button 10x10 
	Bt2 "Hello" [Print "I exists"] with [size: 150x20]
]
```

[1:00:17](#iyvsJw6DAY1PieUtJS2J7pycLvudNmXicaL_e8gzdJs) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
button-actor: [Print "I exists"]

panel: [
	
	style Bt2: Button 10x10
	
	CMP/FACE/('Bt2) "Hello" CMPO/ACTORS/(button-actor) with [size: CMP/IN/(150x20)]
]
```

First filter:

```
compose-where/group panel 'FACE
probe panel

;result:

[
	style Bt2: Button 10x10 

	Bt2 "Hello" CMPO/ACTORS/(button-actor) with [size: CMP/IN/(150x20)]
]
```

Second Filter

```
compose-where/group panel 'ACTORS
probe panel

;Result:

[
	style Bt2: Button 10x10 

	Bt2 "Hello" [Print "I exists"] with [size: CMP/IN/(150x20)]
]

```

Third filter, using DEEP

```
compose-where/group/deep panel 'IN
probe panel

;Result and final panel

[
	style Bt2: Button 10x10 
	Bt2 "Hello" [Print "I exists"] with [size: 150x20]
]
```

[1:00:44](#vSe1QoZYYPP1GoeeLToDJgyoBodD748fbJOa43vyVnQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * (Note, I do not now why `parse` `CHANGE` removes the `LF` inside the block (see it in consolle output) suggestions are welcome to avoid it)

[1:03:56](#Y74uSzxhVsnW8NWcx6tyTmm-SJIuC8J_uQu8VTgbgqY) <GiuseppeChillemi (GiuseppeChillemi)>:
I think it will solve a lot of composing problems as you can fine tune what and when to compose, even at deep levels.

[1:05:30](#mo1qsfGKzMArIPQF3lbRgsJqFI3CrmJCdHr3Yvtgq_c) <GiuseppeChillemi (GiuseppeChillemi)>:
If you have a value at 10th level in the tree simply shield it with a group and when it will be the time to compose it, `COMPOSE-WHERE` with its name. You will skip all the parens and it will be the only element composed over thousand of panels.

[1:05:39](#1kVFYO7iD1bsBFcpZQVRWcmhjlQmhPScaqeheLQkVuI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * If you have a value at 10th level in the tree simply shield it with a group and when it will be the time to compose it, `COMPOSE-WHERE` with its name. You will skip all the parens and it will be the only element composed over thousand of others.

[1:07:15](#okhoFeDOti6AFY5-0Z37H34C-WGW_b10h4YBuJR7SpA) <GiuseppeChillemi (GiuseppeChillemi)>:
BLOCK names will let you have additional filtering giving a name to a panel as `[[NAME: "MYNAME"] remaining part of block here]`

[1:08:26](#xGBqU-sm3zpeYDqdtKsWPTBoVsqIjLgXuO2_W0GHCVs) <GiuseppeChillemi (GiuseppeChillemi)>:
I admit I would like to have `NAME/[Block here]` notation in path without having to use parens around square parens. 

[1:08:52](#kFpf4Di7tFNnrHUk0Qh6yrQPHqOS96Kni48cqROnWoY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I admit I would like to have `NAME/[Block here]` notation in path without having to use parens around square parens as `NAME/([Block here])`

[1:09:32](#7T1NOioZ9qxMVNRs2F4qFrP3nx8oM1TgNasjzPsyx0k) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 

]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explainig

[1:10:17](#PrXBTNpJhgv8Xpo0MoAnzYr0jocUQOyVwbeA0ScM1ow) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only "Compose writing only one value as a block"
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 

]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explainig

[1:10:57](#342N6YPQSuFD2I7wkIM3WgZtKI-DFJ-PgfDfTYGlKnQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only "Compose writing only one value as a block"
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 

]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explainatory

[1:11:08](#U45oCKVi4V5q5KeaJJeFMOTzdOziYNXB6iX4KBoh9Dw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only "Compose writing only one value as a block"
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 

]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explanatory

[1:11:24](#nDW6C1JxejyUa2NYK6VCu4MyEyaHmI18a8c0yvSpqaI) <GiuseppeChillemi (GiuseppeChillemi)>:
Do you like it? Any suggestion?

[1:17:43](#Adc5pf_THa6ZXteTkMlKoMP7QsXmQSK47Urc9__RtWI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only "Compose writing only one value as a block"
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 
	series
]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explanatory

[1:24:07](#8Rgoow8Pzo1TFjuqMshVIWgu2tZ-Px78OWVKpzf-soE) <GiuseppeChillemi (GiuseppeChillemi)>:
@dockimbel Do you like this concept of selective composing? 

[1:43:52](#KpBvBwSSfwirCQ8RhY0LAeOBdAfsPC0NUAaJxJoT2u4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * If you have a value at 10th level of the tree, simply shield it with a group and when it will be the time to compose it, `COMPOSE-WHERE` with its name. You will skip all the parens and it will be the only element composed over thousand of others.

[1:44:01](#Si5S0oSKwiCfN8gBvGIbVne6uleWMRk7Zy_L2Br_1UI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * If you have a value at 10th level of the tree, simply shield it with a group and when it will be the time to compose it, `COMPOSE-WHERE/DEEP` with its name. You will skip all the parens and it will be the only element composed over thousand of others.

[1:54:10](#48KDocddlIjFbVCtJhBoiaCV_q4Ut79B_9OHNphGEoM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only "Compose writing only one value as a block"
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 
	series
]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explanatory

------- EXAMPLE --------------------------------------------

[2:38:08](#tBZ6HHI0sS42_ObcEscuQjrnqdDTOFeNXOlZ_fnP5NI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I admit I would like to have `NAME/[Block here]` notation in path without having to use parens around square BRACKETS as `NAME/([Block here])`

[2:38:19](#Yv1-CGcDleVSZDZtkwLMM87X_9ilmn367kIpacUqG2o) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I admit I would like to have `NAME/[Block here]` notation in path without having to use parens around square brackets as `NAME/([Block here])`

[2:38:48](#UeK33JusLRsrGIiL4Cm_7X4vPFAYxmwnJBDKOGwhNLA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Do you like `compose-where`? Any suggestion?

[18:19:23](#Z54jzWpOS3ef9LF81LUJKkr5L4DcMOdk9ISRL88OZA0) <greggirwin (Gregg Irwin)>:
Will try to make time to look at it in the next day or two.

[18:31:14](#ffwRu9KZ4LNOc_YOFL3o4lRbSz_QzDwJCvHCVy-6miU) <gurzgri>:
GiuseppeChillemi (GiuseppeChillemi)  `new-line` marker states:
```
block: new-line/all [one 2] on
== [
    one
    2
]
>> head change next copy block [two]
== [
    one two
]
>> head change next copy block new-line [two] new-line? block
== [
    one
    two
]
```


[18:31:56](#7M6ReVa8iS7wvg5zHbGqApwyi5j7EWmbNN0rwRVYz7I) <gurzgri>:
 * GiuseppeChillemi (GiuseppeChillemi)  `new-line` marker states:

```
>> block: new-line/all [one 2] on
== [
    one
    2
]
>> head change next copy block [two]
== [
    one two
]
>> head change next copy block new-line [two] new-line? next block
== [
    one
    two
]
```

[18:37:29](#gZ-fBKqWTBSnU_PYLUQ8FSshd-IvDHX-7a51RjeveIs) <gurzgri>:
https://github.com/red/red/blob/1840ac70bbe3ed7b431b6147f743a4c9526d7384/runtime/definitions.reds#L46

[18:39:56](#ugjRtz3d85cdqr5ib0_IE6cpPXiEyza8G729xfgmHoY) <gurzgri>:
These `new-line` markers aren't values of themselves but are mere flags to a value. In particular, they aren't `LF` values.

[18:45:36](#pz8HX47ZHEeejcXglkL-D0NK1VmDJxnz3vLJY6ULZF0) <gurzgri>:
One cannot flag a *value* to be preceeded by a new-line, only a *position* in a series can be flagged to be preceeded by a new-line. That's why the above example changes to `[two]`, not to `'two`.

[20:39:47](#VmTiQzevnVlWPkMko7WPkdhF3ok2J7h0D477rZw_Hdg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only "Compose writing only one value as a block"
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flahs
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where/:deep/:only subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 
	series
]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explanatory

------- EXAMPLE --------------------------------------------

[20:43:48](#3afzp-p2Hw6STC8cuVAG_vwgqm9_5BGn6h-8sC_mmus) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> Will try to make time to look at it in the next day or two.

Ok, I have fixed a little bug adding the refinement to the function calling itself recursively, to preserve them at each sub call.

[21:44:00](#tRXO54hIuZvcyNn1QRsheMa9QWc7TSKtID-Uj_sLk9k) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is my baby, my swiss army knife I will use for composing code:

```
compose-where: func [
	"Compose where groups match"
	series [block!] "The block to compose"
	/group "Specify a group to compose"
	grp [word! block!] "The group(s) to compose"
	/deep
	;/level LV
	/only "Compose writing only one value as a block"
	/local
	code
	mode
	subseries
	group-found
	groups
] [
	;TBD: block locks/flags
	;TBD: levels
	;TBD: block names	

	groups: append copy [] grp
	
	parse series [
		any [
			
			ahead path! change into [
				['CMP (mode: 'CMP) | 'CMPO (mode: 'CMPO)] 
				set group-found word! 
				if (either group [find groups group-found] [true] ) 
					set code paren! end
			] (
				case [
					MODE = 'CMP [
						compose reduce [code]
					] 
					MODE = 'CMPO [
						compose/only reduce [code]]
				]
			)  
		| 
			ahead block! if (deep) set subseries block! (compose-where/:deep/:only subseries)  		
		|	
			any-type! 
		| 		
			skip
		] 
		
		end 			
	] 
	series
]
```

You can choose what to compose using path notation:

`CMP/GROUP-NAME/(CODE)`

First element:

`CMP = COMPOSE`
`CMPO = COMPOSE/only`

Second element:

`GROUP-NAME` is a keyword that will be used to match what to filter

Third element:

`(CODE)`

Is self explanatory

------- EXAMPLE --------------------------------------------

## 22-Oct-2024

[0:57:33](#gaw32gTZQeHYRIybgoN9-y4hOUOKjZOvuX1YkGT-V_4) <GiuseppeChillemi (GiuseppeChillemi)>:
Here I have another selective function:
`bind-where`

[0:57:54](#5wHLqEftrZOauLVbwQXW0cLgk65D1uyuVsxT-wz_q3c) <GiuseppeChillemi (GiuseppeChillemi)>:
```
bind-where: func [
	"Bind a series selectively"
	b [block! paren! path!] "The series to bind"
	t [word! block!] "Word or group of words to bind" ;TBB: Function
	ctx [object!] "The context to bind to"
	/local
	ctx-word
	type
	bindable
	series
	sub
	combo
	element
	checker
] [
	;TBD: other rules
	;TBD: Rules as function and work CTX

	t: append copy [] t
	ctx-words: words-of ctx
	type: none
	bindable: [word! | set-word! | refinement!]
	series: [block! | paren! | path!]
	sub: [ahead set element series into [any combo]] 
	checker: [if (type: type? element element: to-word element all [find t element find ctx-words element])]
	combo: [
			ahead set element bindable 
			checker change bindable (element: in ctx to type element)  
		|  
			sub  
		| 
			skip
	] 

	parse b [

		any combo end

	]

	b
]
```

[0:58:05](#4H02Tv47d5tpYFkIV7eNq6m1ffzViYGjdxPoEBfj8d8) <GiuseppeChillemi (GiuseppeChillemi)>:
This is a test:

[0:58:47](#EqDEa4WVD0od9v28j93fBRLnq_3JFuugSW0md3eRLmo) <GiuseppeChillemi (GiuseppeChillemi)>:
```
a: 11
o: "Main CTX"
ctx: make object! [a: 22 c: [hello] o: "you should not se me"]
b: [a b: c /c d/a/f  [c g a i] j k (l a) a o]
	

bind-where b [a c] ctx

probe b
probe reduce first b
probe reduce third b
probe reduce first first at b 6
probe reduce third first at b 6
probe reduce first back tail b
```

[0:58:54](#Ixq-3dYgXPxff9JMGYgWhaD7cAtzAkKZH7AQyO8Pj-I) <GiuseppeChillemi (GiuseppeChillemi)>:
And the result

[1:00:37](#_ZXgwRyfjxHg2Cp9CL_oGltXncR_9sLt1PChLZdEVGA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
a: 11
o: "Main CTX"
ctx: make object! [a: 22 c: [hello] o: "you should not se me"]
b: [a b: c /c d/a/f  [c g a i] j k (l a) a o]
	

bind-where b [a c] ctx

probe b
probe reduce first b
probe reduce third b
probe reduce second fifth b ;The path
probe reduce first first at b 6 ;The first block
probe reduce third first at b 6 ;The first block
probe reduce first back tail b ;The last value
```

[1:01:14](#djAhpZPPVGlGe6D_VElNyiMGSbrLzA0dBKfMYIUGmHc) <GiuseppeChillemi (GiuseppeChillemi)>:
```
[a b: c c d/a/f [c g a i] j k (l a) a o]
22
[hello]
22
[hello]
22
"Main CTX"
(halted)
```

[1:02:08](#pWCb8ExDsQq7xUpk0t-Q7i_LUM2vK82z4E0PAgHFYGg) <GiuseppeChillemi (GiuseppeChillemi)>:
In the future it will accept a function and patters as checker.

[1:02:57](#MiIflsst3wZyTWrQHo01e5CTzvgo7tFLpI4H6ZYozEI) <GiuseppeChillemi (GiuseppeChillemi)>:
If I remember correctly `refinement!` have no context anymore

[1:02:59](#CnSZoKI358_mMYrv-95ZHAX_KHmY2Sj11nkIy6n9Zhg) <GiuseppeChillemi (GiuseppeChillemi)>:
Your test or comments are welcome

[1:06:12](#dyUuTgHEpB9_Qmjm9XPCQOAysDPmrJCV6g_dWW_QrY8) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
bind-where: func [
	"Bind a series selectively"
	b [block! paren! path!] "The series to bind"
	t [word! block!] "Word or group of words to bind" ;TBB: Function
	ctx [object!] "The context to bind to"
	/local
	ctx-word
	type
	bindable
	series
	sub
	combo
	element
	checker
] [
	;TBD: other rules
	;TBD: Rules as function and work CTX

	t: append copy [] t
	ctx-words: words-of ctx
	type: none
	bindable: [word! | set-word! | get-word! | lit-word!]
	series: [block! | paren! | path!]
	sub: [ahead set element series into [any combo]] 
	checker: [if (type: type? element element: to-word element all [find t element find ctx-words element])]
	combo: [
			ahead set element bindable 
			checker change bindable (element: in ctx to type element)  
		|  
			sub  
		| 
			skip
	] 

	parse b [

		any combo end

	]

	b
]
```

[1:58:39](#Du0-eU8Od18QWSwrAX8rvkdjI1xCownbwguxsc6QE1U) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
bind-where: func [
	"Bind a series selectively"
	b [block! paren! path!] "The series to bind"
	t [word! block!] "Word or group of words to bind" ;TBB: Function
	ctx [object!] "The context to bind to"
	/precise "Binds only the same datatype"
	/local
	ctx-word
	type
	bindable
	series
	sub
	combo
	element
	checker
] [


	t: append copy [] t
	ctx-words: words-of ctx
	type: none
	bindable: [word! | set-word! | get-word! | lit-word!]
	series: [block! | paren! | path!]
	sub: [ahead set element series into [any combo]] 
	checker: [if (type: type? element (if not precise [element: to-word element]) all [find t element find ctx-words element])]
	combo: [
			ahead set element bindable 
			checker change bindable (element: in ctx to type element)  
		|  
			sub  
		| 
			skip
	] 

	parse b [

		any combo end

	]

	b
]
```

[16:35:04](#QMHTLlo3S4OeR2VKpTDntK7ctfioKBAG8IPFoPefs4w) <GiuseppeChillemi (GiuseppeChillemi)>:
* If I remember correctly 
refinement! has no context anymore

## 24-Oct-2024

[22:08:50](#mvBCdVS0_KHmy2nYRxQTyb3_wrBEazMhk03BH3llCcQ) <GiuseppeChillemi (GiuseppeChillemi)>:
I have a new `compose-where` with a automatic repeated composition. You do not need to write `compose-where` in results of composing.

[22:09:15](#h9n4FDaxm0detoBHTtHMAvrQB_uQ0kvbhjvkZyZmH8A) <GiuseppeChillemi (GiuseppeChillemi)>:
[Compose-where 1.0](https://gist.github.com/GiuseppeChillemi/20cba6bf2bcf6dc06e8e84410fd3f89e)


[22:10:26](#kToOgWPIjK3pFm2jcYcfc4C4cXkbth2J_4cTiQnM6FI) <GiuseppeChillemi (GiuseppeChillemi)>:
Here is the test code:


```
vid-block: [
	CMP/A/(b1-proto)   
	CMP/A/(b2-proto) 
]

b1-proto: [b1: button 100x40 "B1 TEXT" CMP/A/(compo-block-b1)]
b2-proto: [b2: Button 100x40 "B2 TEXT" CMP/A/(compo-block-b2)]
with-b1: [extra: 'b2]
with-b2: [extra: 'b1 CMP/C/([text: "B2 Other Text"])] 
compo-block-b1: [on-click [print select get (face/extra) 'text] with CMPO/B/(with-b1)]
compo-block-b2: [on-click [Print select get (face/extra) 'text] with CMPO/A/(with-b2) ]


probe vid-block
vid-block: compose-where/repeat/group vid-block 'A
new-line find vid-block quote b1: on
new-line find vid-block quote b2: on 
probe vid-block
probe vid-block: compose-where/deep/group vid-block 'B
probe vid-block: compose-where/deep/group vid-block 'C
view vid-block
```

----- Result:

```
[
    CMP/A/(b1-proto) 
    CMP/A/(b2-proto)
]
[
    b1: button 100x40 "B1 TEXT" on-click [print select get (face/extra) 'text] with CMPO/B/(with-b1) 
    b2: Button 100x40 "B2 TEXT" on-click [Print select get (face/extra) 'text] with [extra: 'b1 CMP/C/([text: "B2 Other Text"])]
]
[
    b1: button 100x40 "B1 TEXT" on-click [print select get (face/extra) 'text] with [extra: 'b2] 
    b2: Button 100x40 "B2 TEXT" on-click [Print select get (face/extra) 'text] with [extra: 'b1 CMP/C/([text: "B2 Other Text"])]
]
[
    b1: button 100x40 "B1 TEXT" on-click [print select get (face/extra) 'text] with [extra: 'b2] 
    b2: Button 100x40 "B2 TEXT" on-click [Print select get (face/extra) 'text] with [extra: 'b1 text: "B2 Other Text"]
]
```

[22:11:37](#Bo0X5YGsjGWzbssx1kRnhwHKITM34yYh7bC56XRsEKU) <GiuseppeChillemi (GiuseppeChillemi)>:
what it is useful for?

[22:13:49](#kMnBw4B9AxQySkKhVjbmB5rJgcI5qHCN2jjMHRxYui0) <GiuseppeChillemi (GiuseppeChillemi)>:
With this command you can build panels like parse blocks, using a context and nesting results, also selectively. I will show some in the next days.

[22:28:54](#WL52pIpfH7VcScXUZwoFNMc_C0WfafndejICGvHUifk) <GiuseppeChillemi (GiuseppeChillemi)>:
No, I am still here and I can show you now:


[22:29:57](#FCgs4UuEQM3aY_4R3lQHL72RHL8lWKQWD_crlXSm8M8) <GiuseppeChillemi (GiuseppeChillemi)>:
This is a the same panel but with parts inside an object:

```
ctx-panel: make object! [
	b1-proto: [b1: button 100x40 "B1 TEXT" CMP/A/(compo-block-b1)]
	b2-proto: [b2: Button 100x40 "B2 TEXT" CMP/A/(compo-block-b2)]
	with-b1: [extra: 'b2]
	with-b2: [extra: 'b1 CMP/C/([text: "B2 Other Text"])] 
	compo-block-b1: [on-click [print select get (face/extra) 'text] with CMPO/B/(with-b1)]
	compo-block-b2: [on-click [Print select get (face/extra) 'text] with CMPO/A/(with-b2)]
]

vid-block: [
	CMP/A/(b1-proto)   
	CMP/A/(b2-proto) 
]

bind vid-block ctx-panel
```

And here is how you build it:

```
vid-block: compose-where/repeat/group vid-block 'A
new-line find vid-block quote b1: on
new-line find vid-block quote b2: on 
probe vid-block
probe vid-block: compose-where/deep/group vid-block 'B
probe vid-block: compose-where/deep/group vid-block 'C
```


[22:43:18](#V5WuJXmVbEWbAHErTnkB5y2wCmnSx_TvYGK72ODfkEg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * This is a the same panel but with parts inside an object:

```
ctx-panel: make object! [
	b1-proto: [b1: button 100x40 "B1 TEXT" CMP/A/(compo-block-b1)]
	b2-proto: [b2: Button 100x40 "B2 TEXT" CMP/A/(compo-block-b2)]
	with-b1: [extra: 'b2]
	with-b2: [extra: 'b1 CMP/C/([text: "B2 Other Text"])] 
	compo-block-b1: [on-click [print select get (face/extra) 'text] with CMPO/B/(with-b1)]
	compo-block-b2: [on-click [Print select get (face/extra) 'text] with CMPO/A/(with-b2)]
]

vid-block: [
	CMP/A/(b1-proto)   
	CMP/A/(b2-proto) 
]

bind vid-block ctx-panel
```

And here is how you build it:

```
vid-block: compose-where/repeat/group vid-block 'A
vid-block: compose-where/deep/group vid-block 'B
vid-block: compose-where/deep/group vid-block 'C
new-line find vid-block quote b1: on
new-line find vid-block quote b2: on 
probe vid-block
```

[22:44:55](#BhDIIofeyVtpz-6kvalYtixmE6D1erlDc7yefa7u8dU) <GiuseppeChillemi (GiuseppeChillemi)>:
Without groups, a simple `compose-where/deeep/repeat` with compose nested parens and also paren deep in blocks.

[22:46:02](#n03rs-nJsGrraDc3EQikvNdBfd9oSs0SUi5b-66hrbQ) <GiuseppeChillemi (GiuseppeChillemi)>:
No need to `compose compose compose (code)` or `compose` commands inside block

[22:46:38](#DmzD4k9M8ajWMazfiQ0oils8H5LRPdmupcVMeNOPkyM) <greggirwin (Gregg Irwin)>:
And now I'm further behind. :^)

[22:47:08](#wIAe9_0L442cRxlQjthwDt2WRenPA9WfMhPsAaVi-hk) <GiuseppeChillemi (GiuseppeChillemi)>:
You have avoided a couple of bugs :-)

[22:47:52](#ryikq79lbPWNzemJc-A3ojTcG7tP3uP_E7vyqNZ4uow) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Without groups, a simple `compose-where/deeep/repeat` will compose nested parens and also paren deep in blocks.

[22:48:12](#GcY1FKQC5uDh8NlyZQ3yrU5QgNaTfdYnYfgaKGVTtZA) <greggirwin (Gregg Irwin)>:
Patience is often rewarded.

## 25-Oct-2024

[0:39:41](#PxunxHVx8mkY1yQMwIzt2epQ0y_vRvBeMtohIDxEuv8) <GiuseppeChillemi (GiuseppeChillemi)>:
They are very prolific night, thanks to hiiamboris  which shared the problem with `text: text text text` in panels. He triggered these ideas and many others. I am inside a tunnel full of wonderful thoughts. 

[6:47:41](#to1y8Id2NoZVNX7BgfMBvg_ZY8YxOH7eiZWwF9vmY_M) <hiiamboris>:
Hope you see the light at the end of it ‚òª

[7:36:55](#4pgGL_v04OiBYOij6Nl2_c7dqYcvb8FUNNohZcWyrvQ) <GiuseppeChillemi (GiuseppeChillemi)>:
I have seen it and it is a train! 

## 27-Oct-2024

[20:25:49](#5UX20M783ysJffFkzkY-5mYkml3HtMgTy2tAAtJDZA0) <GiuseppeChillemi (GiuseppeChillemi)>:
11K words in my notes to develop this idea which is not easy as I tought.

## 28-Oct-2024

[4:15:08](#j_BwQ9u4Y_sl0gouI4yt1vWroIyvnMcbyr1ncjUlYvY) <GiuseppeChillemi (GiuseppeChillemi)>:
Ok, at 14K words now I have a good global picture

[6:57:04](#xgvk-0rjoT0z_0d9ZnYIeOafBe58oFKuulY7uvCP3vg) <hiiamboris>:
poem or prose? :)

[12:27:41](#Me0uk3Fj6sedQV8BFn5D5hTvwYaJmhUmKDKVjYJXDT8) <GiuseppeChillemi (GiuseppeChillemi)>:
Markdown

[17:25:05](#fN7lpYW4NDePFrE-A3ysFWmF597LtNcBGnHBZ8I8p5w) <greggirwin (Gregg Irwin)>:
:^)

[22:02:48](#F3157G6W7VgAOaen3EBqhoszbsgfs_vF5zrxtUr4t9M) <GiuseppeChillemi (GiuseppeChillemi)>:
The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.


The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts. 

```
 view compose [b: c: button "Hit Me"]
```

[22:09:02](#uM4xuQg4fNRSdc-l-6PhXUUimCEV2jQRuI-0qBwQjuQ) <GiuseppeChillemi (GiuseppeChillemi)>:
The second improvement, which would help a lot too, is having face as object in the description block. So if you create a panel with `layout bind [panel:  [f: Button "Hit Me!"]] make object! [panel: f: none]`, once you make create the layout, `set-word`s do not interfere anymore, the context is created and word bound to it. So including in another face description is totally safe and it is like being shadowed from a word, in this case from the face object. 

[22:10:13](#XVY_8Jv_OTAyFOTwDyE3-QBaaYWO1ImmJfdnNPHlHvQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The second improvement, which would help a lot too, is having face as object in the description block. So if you create a panel with `layout bind [panel:  [f: Button "Hit Me!"]] make object! [panel: f: none]`. Once you have made layout, `set-word`s do not interfere anymore, the context is created and words bound to it. So including the face object in another face description is totally safe and it is like being shadowed from a unreduced word, in this case from the face object.

[22:10:42](#65k-wXsc0jRqddeg1s5V6OGW8-OozaMM720YDX3HH_Y) <GiuseppeChillemi (GiuseppeChillemi)>:
```
  view compose [b: c: button "Hit Me"] panel: (make-face parameters)
```

[22:10:51](#YfDKkMrGVBSVbp0WConqQyaSqi40rNx53LS62yTDnEs) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
  view compose [b: c: button "Hit Me" panel: (make-face parameters)]
```

[22:12:20](#_lUZuYNKO_V93i8xLaVGZ_yUXa-T4iue2jYTrPj4q3E) <GiuseppeChillemi (GiuseppeChillemi)>:
The VID dialect could take just the `XxY` parameters from IT and what other in is needed for the face to be included in the previous face

[22:12:43](#j64WqkC65jVjUr0_SbItTVG4tvCxsOZgJc-KC_xkQHU) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The VID dialect could take just the `XxY` parameters from IT and what other in is needed for the `face` to be included in the container one

[22:22:12](#RCs6u1gHRZrLFqFGIn3M9KLRNee6LN8wsqWuizcxOx4) <GiuseppeChillemi (GiuseppeChillemi)>:
Another example:


```
sub-panel: bind [
  f: field 
  c: Button "Hit me" [txt/text: "Hello"]
  txt: "" 
] [f: c: txt: none]


View compose/deep bind [
   txt: Text "Hi, this is the root one and txt: b: already exists in another context"
      b: Button "Hit Mee!" [txt/text: "This would not work"]
      panel: [(sub-panel)]
] make object [txt: b: none]
```


[22:23:01](#K2qZBx9RO1G-VAU99o5TF5SYRqiLd5yLurwGpFvBq1o) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Another example:

```
sub-panel: bind [
  f: field 
  c: Button "Hit me" [txt/text: "Hello"]
  txt: "" 
] [f: c: txt: none]


View compose/deep bind [
   txt: Text "Hi, this is the root one and txt: b: already exists in another context"
      b: Button "Hit Mee!" [txt/text: "This would not work"]
      panel: [(sub-panel)];<------------ Using LAYOUT here would shield the panel
] make object [txt: b: none]
```

[22:24:11](#hZhuGJ7lpjQpO8R3Ew4KNRFBUhqfRyXKkdS22Dql7DI) <GiuseppeChillemi (GiuseppeChillemi)>:
I have marked the point where accepting `face` objects inside VID blocks would make it simple including panels. 

[22:26:17](#hFSMIeeRd66Tfe0L5F28CBH2nZm9xKitplLYMOUlThw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Another example:

```
sub-panel: bind [
  f: field 
  c: Button "Hit me" [txt/text: "Hello"]
  txt: "" 
] [f: c: txt: none]


View bind 4compose/deep [
   txt: Text "Hi, this is the root one and txt: b: already exists in another context"
      b: Button "Hit Mee!" [txt/text: "This would not work"]
      panel: [(sub-panel)];<------------ Using LAYOUT here would shield the panel
] make object [txt: b: none]
```

[22:26:23](#PAz1BafVbAKC82BSDD6SsuCg8f5zistuQnJWGSGUGIs) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Another example:

```
sub-panel: bind [
  f: field 
  c: Button "Hit me" [txt/text: "Hello"]
  txt: "" 
] [f: c: txt: none]


View bind compose/deep [
   txt: Text "Hi, this is the root one and txt: b: already exists in another context"
      b: Button "Hit Mee!" [txt/text: "This would not work"]
      panel: [(sub-panel)];<------------ Using LAYOUT here would shield the panel
] make object [txt: b: none]
```

[22:31:02](#CbA_ptVwYW4DsEgqCTaZSZ5s6RX6OAXVkKFFoH1WHeQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Here a face in object form would shield the face, the actors and logic from the upper binding, preserving the creation logic that could be included and the code in actors. So the face already completed before composing and the face VID description is included in the VID code you are included with composing, making it independet from the upper block 

[22:31:23](#4mRMPRfb531UbWc_dU7UhHVQMiJiqPBtX08RuhdARAg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here, a face description converted in object form would shield the face, the actors and logic from the upper binding, preserving the creation logic that could be included and the code in actors. So the face already completed before composing and the face VID description is included in the VID code you are included with composing, making it independet from the upper block 

[22:32:38](#nB7TV2UZR-gZ5FWlXZdOwgpA10h7jc9xotgSs6PTMGc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here, a face description converted in object form would shield the face, the actors and logic from the upper binding, preserving the creation logic that could be included and the code in actors. So the face is already completed before composing and the face VID description is included in `sub-panel` instead of the upper one.

[22:33:03](#WMxFngG5_nnzIX60upoq-BlWKOKt_NaJFqVEttp55ZU) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here, a face description converted in object form would shield the face, the actors and logic from the upper binding, preserving the creation logic that could be included and the code in actors. So the face is already completed before composing and the face VID description is included in `sub-panel` instead of the upper one, making it indepedent and reusable.

[22:36:09](#5LPvsAuU1-3JoAV9HwX8-pfaA8GxKSpGLaHMepM2y6Y) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here, a face description converted in object form would shield the included face, so the actors and logic are safe from the upper binding. The result is preserving the creation logic that may be included included in the sub-panel (think about a function to pre-process the included sub-panel) and the code in actors. In this way, the face is already completed before composing; the face VID description  is included in `sub-panel` instead of the upper one, and the final result is having it indepedent and reusable.

[22:36:36](#7Gcl4w0ve3gOl4GpRbzk7NxWKvSXCvXdTvsS9oe2Efc) <GiuseppeChillemi (GiuseppeChillemi)>:
hiiamboris: You opinion is higly welcome

[22:36:45](#kyXxmNPMLKGHsnarM-c5VU1oyHxsnG1kWDUqv7yCSgg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * hiiamboris: You opinion is highly welcome

[22:40:57](#h6r5J5Yn59twIjwg0NMcF9xLrN85JRgIatxmc431apM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
sub-panel: bind [c: button "Hit Me" b: button "Change the first one" [c/text: "You have hit me"]] make object! [c: b: none]

 view compose/deep [b: panel [(sub-panel)]]
```

The two `B` would be connected to the face but in different contexts


[22:41:27](#bgJEw6s4H9_70iEqLq253jzsG7Iy7kOI8Lv3gY3nhYI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
sub-panel: bind [
   c: button "Hit Me" 
   b: button "Change the first one" [
      c/text: "You have hit me"]
] make object! [c: b: none]

 view compose/deep [b: panel [(sub-panel)]]
```

The two `B` would be connected to the face but in different contexts

[22:42:29](#p01nA7_I9SWYHZddNSNgSaEjw-Z7Tp30e7VM7321n9w) <GiuseppeChillemi (GiuseppeChillemi)>:
Oldes: I have changed the first example

[22:42:55](#KgB44kF_f2RQ2MWo2cin8YDjNlTkUbOG0rg0OI960g0) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
sub-panel: bind [
   c: button "Hit Me" 
   b: button "Change the first one" [
      c/text: "You have hit me"
   ]
] make object! [c: b: none]

 view compose/deep [b: panel [(sub-panel)]]
```

The two `B` would be connected to the face but in different contexts

[22:44:06](#tps3y3WtI-FF6F-cMYCTJIycXrpEKhTdriAavU41_RA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
sub-panel: bind [
   c: button "Hit Me" 
   b: button "Change the first one" [
      c/text: "You have hit me"
   ]
] make object! [c: b: none]

 view bind compose/deep [b: panel [(sub-panel)]] ctx-panel: make object! [b:  none]
```

The two `B` would be connected to the face but in different contexts

[22:47:12](#4aIcPlLmjr-nJ1yBQlca1OPPxNTPkosx1Q60KYnA2ds) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
sub-panel: bind [
   c: button "Hit Me" 
   b: button "Change the first one" [
      c/text: "You have hit me"
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: panel [(sub-panel) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

The two `B` would be connected to the face but in different contexts.


[22:47:48](#7za8TEwy-4fWunRg6XkoVWel5CzoL-t3aNGSFltkYOs) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
sub-panel: bind [
   c: button "Hit Me" 
   b: button "Change the first one" [
      c/text: "You have hit me"
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: panel [(sub-panel) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

The two `B` and `C` would be connected to the face but in different contexts.

[22:51:54](#Nf7TvwOxT32wEn2MGJkERVZUxLT_EOu31kjeiK7_CnM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts. 

```
sub-panel: bind [
   c: button "Hit Me" 
   b: button "Change the first one" [
      c/text: "You have hit me"
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: panel [(sub-panel) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

The two `B` and `C` would be connected to the face but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[22:53:26](#TkikETomJNDOqUWxao_sDYrtLCia8ing5-OP1A1c42w) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The second improvement, which would help a lot too, is having face as object in the description block. So if you create a panel with `layout bind [[f: Button "Hit Me!"]] make object! [panel: f: none]`. Once you have made layout, `set-word`s do not interfere anymore, the context is created and words bound to it. So including the face object in another face description is totally safe and it is like being shadowed from a unreduced word, in this case from the face object.

[22:53:51](#N6ho2ib4AYZxujZdH_Q-gY4DTMQ-URH7kS_Y8hW2GpI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The second improvement, which would help a lot too, is having face as object in the description block. So if you create a panel with 
```
layout bind [[f: Button "Hit Me!"]] make object! [panel: f: none]
```
 Once you have made layout, `set-word`s do not interfere anymore, the context is created and words bound to it. So including the face object in another face description is totally safe and it is like being shadowed from a unreduced word, in this case from the face object.

[22:54:57](#DEJKlzruSiKb5WtEizj5RmAUNtb6TNOD8I13BqBu1sc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
  view compose [b: c: button "Hit Me" (lay)]
```

[22:55:04](#QXb_7RaVkFLSsWDcl32gAH8wFywwsIvd7H-CNi9WCzw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The second improvement, which would help a lot too, is having face as object in the description block. So if you create a panel with

```
lay: layout bind [[f: Button "Hit Me!"]] make object! [panel: f: none]
```

Once you have made layout, `set-word`s do not interfere anymore, the context is created and words bound to it. So including the face object in another face description is totally safe and it is like being shadowed from a unreduced word, in this case from the face object.

[22:55:26](#-qHwLxlawoiopCTP_A29rVGCy7C2qA9UNVDIFMwJelQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
  view compose [b: f: button "Hit Me" (lay)]
```

[22:55:44](#ObQiMYt1Or41CF5ERg2BvE9eDaUYtSP6DM_rU085kco) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
  view compose [f: button "Hit Me" (lay)]
```

[22:56:04](#fHYaldOl4b8kuwDD_oShgcDeucreQ2hE0mTrEDgU4bY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Oldes: I have changed the first example and also the others

[23:02:40](#jaq-S-wf0ecYTyJP-s-9zrErm528C_5aVyEChvgQzEk) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

The two `B` and `C` would be connected to the face but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:07:13](#cht6edA8AKuMvEWmpm0OBFoxNkv_pkWpMy7H3hLFSuA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```
Result:
```
[
    c: Text 30x15 
    b: b: button "Change the first one" [
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:07:48](#ZUTq4ctEE3AYSJNHy4pBokB--uXXidiK6KGUZw7KIX4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:08:21](#DLy8GmdQLcAN7cvudXFuyNVSC-b3c6EHUNmCWlcTueI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:08:39](#W5p2ikFl9w_VvbXP-3Qj9DGdM_igUM_tMT2RFwzsfCw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a panels of code, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:11:03](#PDTHofi5Sq2xsOfWDvcgQ3sd-Lt6F4C2k9XLou4wb6k) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of face descriptios, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them hadding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:11:15](#BnvGoLPqpYcKA30I7oYmXizx-2parJQheAaaJ1ZFbXY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of face descriptios, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them adding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exosing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:11:46](#vU5RBd8jVKNTU_q_qB2p0oZgh3-_vPl0tICi0pObbXc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of face descriptios, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them adding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exposing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have strudied and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:12:09](#mgs6TiCas96Qu1qwbfHyVjURDkG1uX2qtWimsf3hP8A) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of face descriptios, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them adding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exposing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have analyzed and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:13:26](#KrENghPn2X9SKHepJ1PuPJnUWSfBhR1vYvNzQ0A8F2A) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The second improvement, which would help a lot too, is having already created `faces` as `object!` in the description block. So if you create a panel with

```
lay: layout bind [[f: Button "Hit Me!"]] make object! [panel: f: none]
```

Once you have made layout, `set-word`s do not interfere anymore, the context is created and words bound to it. So including the face object in another face description is totally safe and it is like being shadowed from a unreduced word, in this case from the face object.

[23:13:59](#cwDG76ikzBE7MC0s82ZF5jeGHqB-j1q3jkHVZ-p6c6I) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of code segments, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them adding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exposing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have analyzed and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep` of you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:14:42](#9FRiEzm14qb9W_msGXXEl7yOtJtUYJ_fH6d-APVT83g) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of code segments, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them adding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exposing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have analyzed and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep`, if you imagine more complex scenarios with deep nested composing and multiple contexts having the same words the advantage is evident. But more on this with the next idea.

[23:14:57](#1s4NlHnrmo5ypOKnHf4SPcoqEFtZijCFCeqfNZ1Hhlg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of code segments, are all related to the Red rought Binding which has totally not boundaries. I have circunvented them adding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exposing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have analyzed and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep`, if you imagine more complex scenarios with deep nested composing and multiple contexts having the same words, the advantage is evident. But more on this with the next idea.

[23:20:37](#2dbQbdpf57iXyhZ4eZ_K3AWwaz0DrvjaGzIdy-QRprI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Another example:

```
sub-panel: bind [
  f: field 
  b: Button "Hit me" [txt/text: "Hello"]
  txt: "" 
] [f: b: txt: none]


View bind compose/deep [
   txt: Text "Hi, this is the root one and txt: b: already exists in another context"
      b: Button "Hit Mee!" [txt/text: "This would not work"]
      panel: [(sub-panel)];<------------ Using LAYOUT here would shield the panel
] make object [txt: b: none]
```

## 29-Oct-2024

[3:24:42](#DV5Tkn-Pqr8qI4NtZJdsHfFy34n1G_eNbqYpWdpjXrM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The problems in my experiments composing face descriptions from a library of code segments, are all related to the Red rought Binding which has totally no boundaries. I have circunvented them adding limits, groups and precise (word) binding. Also, another group of problems is the sharing of operative contexts between panels and exposing group of words. They are also solveable but 2 improvements in VID would help a lot in the state as it is, without implementing what I have analyzed and partially created.

The first improvement is the possibility to have multiple `set-words` before a face definition like `b: b:button "text here"`. When including a panel, some words could be bound to a context and some others to another context. Also in regulare use, an object could be in multiple contexts.

```
other-parts: bind [
   b: button "Change the first one" [
      c/text: "You have hit me"
   c: button "Hit Me" 
   ]
] make object! [c: b: none]

 view bind compose/deep [
   c: Text 30x15 b: (other-parts) on-over [c/text: "Hovering" ]
] ctx-panel: make object! [c: b:  none]
```

Result:

```
[
    c: Text 30x15 
    b: b: button "Change the first one" [;<--- The first and second B are in different contexts
        c/text: "You have hit me" 
        c: button "Hit Me"
    ] on-over [c/text: "Hovering"]
]
```

The two `B` and `C` would be connected to the faces but in different contexts.
While such results could be archived moving `BIND` after `compose/deep`, if you imagine more complex scenarios with deep nested composing and multiple contexts having the same words, the advantage is evident. But more on this with the next idea.

[8:08:59](#V2caC_LhQ7B_1H3fa2jbKxhnNvtCAtaaWzxHbdNxY0g) <hiiamboris>:
It's really hard to advise anything without seeing a realistic outcome of all this, only from synthetic examples which to me personally look quite esoteric.

[8:15:07](#G-dtG2YAKMlq8BtndhGK9EpwD7fKUHkC8a7eEaIPNmk) <hiiamboris>:
Thoughts that popped in my mind were:
- why can't you use `layout/only` and then assign the `pane` of the panel?
- why can't you use `reshape` with different markers for this multi-composition?
- if you want multiple set-words for a face, it will be much less esoteric to use set-paths (and you can even add your own dialect over VID that transforms set-paths into properly bound set-words)

[8:15:30](#WwcxyIr6-C9bmLHAtvqJtLlN-kz7AiKZ5RVlRUVugdc) <hiiamboris>:
But I probably didn't understand the half of it even...

[13:09:49](#hCh2ADAf52ISz6CKZKLJ2CqLp7fyjxnK4O4IrpmFt8E) <GiuseppeChillemi (GiuseppeChillemi)>:
The final goal is having composable code segments that could work either alone or together.  

[13:18:04](#fHrBP9pXj1sVxdh2zN6LveOvxcZWr6mnpyk5hheo6vk) <GiuseppeChillemi (GiuseppeChillemi)>:
And yes, set-path is an option
Could you make an example of using reshape with a marker? 

[13:21:56](#E8JNIok_ClqZQO9_U1HSB7PD0s2bXDyIDVVHQXrt6MQ) <hiiamboris>:
```
>> reshape/with ['X] probe reshape/with ['Y] [X[1 + 2] Y[2 + 3]]
[X [1 + 2] 5]
== [3 5]
```

[13:36:55](#9hH579bcyvOSGaH5mO_xhfIg5X3k0UoxWgOOn2zW-dg) <GiuseppeChillemi (GiuseppeChillemi)>:
Well, now suppose you have 4 nested code segments, they describe 4 faces. You need to set a context for the lower one, the deepest one.     The face 4 is included and composed by face 3 and you have no control over it.  If you bind the context for face 4, there are 2 options:  setting it when the nested composition ends and the face is now visible, or setting before being composed. In the first scenario, you may partition the namespace of the segments giving words an unique name but if you include that code 2 times, a bind would set the words for both. If you bind before composing, binding the fourth level means passing the context to bind to the fourth compose and let it do the work. 

[13:37:32](#sZPap8CM0u9plZQuthGdSpH73EAprI98WEX46uRUD34) <GiuseppeChillemi (GiuseppeChillemi)>:
* Well, now suppose you have 4 nested code segments, they describe 4 faces. You need to set a context for the lower one, the deepest one.     The face 4 is included and composed by face 3 and you have no control over it.  If you want to bind the context for face 4, there are 2 options:  setting it when the nested composition ends and the face is now visible, or setting before being composed. In the first scenario, you may partition the namespace of the segments giving words an unique name but if you include that code 2 times, a bind would set the words for both. If you bind before composing, binding the fourth level means passing the context to bind to the fourth compose and let it do the work. 

[13:38:09](#uIDNju-7NlHZj0nfZ8k7_QmsIugpCJzSI6m21lRy4k0) <GiuseppeChillemi (GiuseppeChillemi)>:
* Well, now suppose you have 4 nested code segments, they describe 4 faces. You need to set a context for the lower one, the deepest one.     The face 4 is included and composed by face 3 and you have no control over it.  If you want to bind the context for face 4, there are 2 options:  binding it when the nested composition ends and the face is now visible, or setting before being composed. In the first scenario, you may partition the namespace of the segments giving words an unique name but if you include that code 2 times, a bind would set the words for both. If you bind before composing, binding the fourth level means passing the context to bind to the fourth compose and let it do the work. 

[13:38:45](#ttFPmp8FXKqqgHxev7U9MOc4on6d9mnPTZVJ40dzHNk) <GiuseppeChillemi (GiuseppeChillemi)>:
* Well, now suppose you have 4 nested code segments, they describe 4 faces. You need to set a context for the lower one, the deepest one.     The face 4 is included and composed by face 3 and you have no control over it.  If you want to bind the context for face 4, there are 2 options:  binding it when the nested composition ends and the face is now visible, or binding it before being composed. In the first scenario, you may partition the namespace of the segments giving words an unique name but if you include that code 2 times, a bind would set the words for both. If you bind before composing, binding the fourth level means passing the context to bind to the fourth compose and let it do the work. 

[13:39:17](#C9efly08yuQvQIyywrLNelhPODMu58xjYrIeKmytri8) <GiuseppeChillemi (GiuseppeChillemi)>:
How do you solve this?

[13:39:29](#PTPxvU3lref5SlBxIosBOpGisAPjEjyihGgnI9AmUjw) <GiuseppeChillemi (GiuseppeChillemi)>:
This it what I working onto.

[13:39:37](#vRReRmbgeN1JU4Z3kmFxKrNJWaV6YungBvnJ4MzXdak) <GiuseppeChillemi (GiuseppeChillemi)>:
* This it what I am working onto.

[13:41:29](#es9WXP-g-vq0143J_axInmWUFMd1iIejngcTbS6XKs0) <hiiamboris>:
why not bind *during* composing?

[13:46:25](#W0qTH7srxdJGpfd3zlVTZZt2-wXEiLEFQDhxhK-eoHE) <GiuseppeChillemi (GiuseppeChillemi)>:
This is the second option but you have no control on how the third compose works, it is includind the forth code out of your control. It may come from another author library. What you will have is just a context to set up and bind, and binding is done at level one, the only you have control onto.

[13:50:06](#1wb78Fb_p9mcW38xd0UUb_KAC6Adbd9GHH0o_qQpWg0) <hiiamboris>:
If you don't have control over level 4, how can you know what words does it have? Or what do you need to do with its context?

[14:01:14](#qufT9Y_Oxl1imfybWL1C_antoTyyl_nnAJLaImZ0Bxo) <GiuseppeChillemi (GiuseppeChillemi)>:
The documentation of its context will tell which words has it. But you won't know it is level 4 or 6, you will have a context to set, and the mechanism will bind it to the level it belongs to. It may contain sizes, a field face word to set. The documentation of the panel will just give you the context description and the mechanism (to create) will set it where it belongs. 

[14:04:05](#Jwom8G_T1T-x-jrPp8jutmbAt5YqBuggtVhzWi_X3Hc) <hiiamboris>:
Again, a small realistic example would help to explain

[14:04:29](#j_p5gMFcr8T2YKmYMNJdJlMoEKyrVdsstOTEkkBogkM) <GiuseppeChillemi (GiuseppeChillemi)>:
Think the included panel exposes a ctx-my-context-type1 word. If the subpanels include it 3 times, 2 at level 4 and one at level 6. How do you bind it just in one without binding to all the ctx-my-context-type1 in every level it is.

[14:04:35](#xElmn4HPG4cvS4hvu6tPKgTRGqJypyqWaJS9SJevijU) <GiuseppeChillemi (GiuseppeChillemi)>:
ok

[14:08:45](#dbx56r5lrvzOO0x5cwacsTlJwaTCNPaZB31QoIbmPYU) <GiuseppeChillemi (GiuseppeChillemi)>:
I am on mobile, soon I will be in front of my PC and I will write it

[20:56:23](#6pITojr1MJdo1DaLjV-DJhBCI19Ln2dCbxdYoV3_To0) <GiuseppeChillemi (GiuseppeChillemi)>:
This is a [prototype](https://gist.github.com/GiuseppeChillemi/b6a232a383ff70776f0cb80f23765d58)



[20:57:26](#WYuKjw4ZVNesMmdOQoP1U36ZoBz2ojQqPiBZ7plk_6w) <GiuseppeChillemi (GiuseppeChillemi)>:
Using my `compose-where` all that `compose/bind` are not necessary as it goes deep binding.  

[20:58:09](#KLsGoPXkqZcP1ZYdYraMca3wySIFIOQWLC0Ut0VP89I) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Using my `compose-where` all that `compose/bind` are not necessary as it does deep composing

[20:59:41](#xSIvz8qUEusqA0m07rXErT5Gfmws1j98BJ-73MW3Rrc) <GiuseppeChillemi (GiuseppeChillemi)>:
.The `P1` segment has the following context: `[pa: b: t: none panel-text: "xx"]`

[21:02:57](#jJNzZWZhn1O02Up7Lse4yEVs0hhy-taa4i5FtNe98yw) <GiuseppeChillemi (GiuseppeChillemi)>:
As I may not know how all code is nested, I just want to create the previous context at the topmost `GUI` level and pass down to the first P1 composed code. And only to it. 

[21:03:54](#knl0CRF549gaSRJqIruHmay0TtiDYfYgF1sIY4fZyic) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Using my `compose-where` all that `compose/bind` are not necessary as it does deep composing

This is the result:

[
    p: panel 600x300 [
        pa: 
        panel 600x40 [
            b: button "Hit me!" [
                insert clear head t/text "Hit me but not so strong!!!"
            ] 
            t: Text "" 250x15 with [text: copy panel-text]
        ] 
        return 
        pb: 
        panel 600x40 [
            b: button "Hit me!" [
                insert clear head t/text "Hit me but not so strong!!!"
            ] 
            t: Text "" 250x15 with [text: copy panel-text]
        ] 
        return 
        pa: panel 600x200 [
            b: Button "Change text" [t/text: "UPPERCASE"] 
            t: h3 "This is a banner!" 250x60 
            return 
            b2: Button "Change P1" [
                code-to-be-written-to-set-p1 
                t2: text "p2" 250x15 with [text: copy panel-text]
            ]
        ]
    ]
]

[21:04:18](#8S2BFPUvPtCGGzI8t494eqVzITPd-JGbTFhcGwnl2bQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Using my `compose-where` all that `compose/bind` are not necessary as it does deep composing

This is the result:

```
[
    p: panel 600x300 [
        pa: 
        panel 600x40 [
            b: button "Hit me!" [
                insert clear head t/text "Hit me but not so strong!!!"
            ] 
            t: Text "" 250x15 with [text: copy panel-text]
        ] 
        return 
        pb: 
        panel 600x40 [
            b: button "Hit me!" [
                insert clear head t/text "Hit me but not so strong!!!"
            ] 
            t: Text "" 250x15 with [text: copy panel-text]
        ] 
        return 
        pa: panel 600x200 [
            b: Button "Change text" [t/text: "UPPERCASE"] 
            t: h3 "This is a banner!" 250x60 
            return 
            b2: Button "Change P1" [
                code-to-be-written-to-set-p1 
                t2: text "p2" 250x15 with [text: copy panel-text]
            ]
        ]
    ]
]
```

[21:06:17](#rwrVZCv_aWp2a6OMLw2fTpCaj4muwA4mg_zBRNCzwI8) <GiuseppeChillemi (GiuseppeChillemi)>:
 * As I may not know how all code is nested, I just want to create the previous context at the topmost `GUI` level and pass down to the first P1 composed code. and bind only to it.

[21:06:24](#LCMa7NLEDxBOaR2mLZ0DaweoX-5VgBwwnfR_QYVP6_M) <GiuseppeChillemi (GiuseppeChillemi)>:
```
        pa: 
        panel 600x40 [
            b: button "Hit me!" [
                insert clear head t/text "Hit me but not so strong!!!"
            ] 
            t: Text "" 250x15 with [text: copy panel-text]
        ] 
```

[21:06:41](#tu7GvzPdeAVPV7jh_nlKCpVnJQUb-lt68uKUiA5l1P0) <GiuseppeChillemi (GiuseppeChillemi)>:
This is the segment I am referring to

[21:08:29](#V2RpEaWaeKeWlYhsJ6_rj52Auar3XHasH9iR9gfyTmI) <GiuseppeChillemi (GiuseppeChillemi)>:
Any attempt to do it when on the whole panel, would destroy all other bindings as they have the same words

[21:12:22](#JuSKgxsquHwlhvJh9QPR-c2PZ3TlCupK_gxvlzguRV0) <GiuseppeChillemi (GiuseppeChillemi)>:
So I want to pass down the context to bind at `compose-where` use `compose-where/bind panel ctx` at panel creation, where the `ctx` passed comes from the topmost level.

## 30-Oct-2024

[1:12:03](#qAAiAgGCf-1dj_PkPGW2hPjgrYdeaA6yoN7tS9CHRrc) <GiuseppeChillemi (GiuseppeChillemi)>:
Again on the topic, maybe it is better in this way.

[1:12:31](#esC9Gx2Ou305wDikwC3-wlG9bgRUB6v-s3ydpmvunb0) <GiuseppeChillemi (GiuseppeChillemi)>:
If you express the panel config in this way:

[1:12:41](#Cb1Jm4070IO5Jgxt5HIDLr4YJGMdc6mHjuOUkUv0rbo) <GiuseppeChillemi (GiuseppeChillemi)>:
```
;--- This is a panels library with just one panel
specs: [
	p1 [
 	[actor: [probe b/text] b: none] ;--- The context of the panel (May be more than one)
 	[b: button "Print me" 50x20 (:actor)] ;--- The panel itself
 ]
]
```

[1:13:40](#Cq1G_8ap1aT2XBHvbkIxQpycLGpkqa7wiXoGQhyLTDM) <GiuseppeChillemi (GiuseppeChillemi)>:
You may use specially buit function to embedd the panel and its contexts specifications without binding a single word.

[1:13:51](#DW1szZvQ1SGSKbKyeYRdE0dpAPwLtDdsWCVyLcn0bIo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You may use specially build a function to embedd the panel and its contexts specifications without binding a single word.

[1:14:18](#dC8LhrPzjMxbV4JbKnjOqOQZhdmSfetzI14OlnmDNBE) <GiuseppeChillemi (GiuseppeChillemi)>:
```

;--- This function is the panel creator
;-- running it you get the panel built and bound to its contexts
;-- /ctx-proto reutrns the context specs 
;-- /panel-proto returns the proto of the panel
;-- /specs-of "You get the full panel specification"
;-- /full returns the context and the panel build and bound in a block

p1:  func [
	"This is a panel"
	/ctx-proto "Returns the context proto"
	/panel-proto "You get the panel proto"
	/specs-of "The full ctx and panel proto are returned"
	/full "Creates and returns the CTX and the Panel"
	/local
	specs
	ctx
	panel
] [
	
	;---
	specs: first body-of system/words/context? 'local
	ctx: make object! specs/1
	panel: bind copy/deep specs/2 ctx
	case [
		ctx-proto [specs/1]
		panel-proto [specs/2]
		specs-of [specs]
		full [reduce [ctx compose/only panel]]
		true [compose/only panel]
	]
] 
```

[1:14:38](#s1uQM5RC6VCW9S9W3v1SJRGpNIF_i0PQjkroaw7H_Tc) <GiuseppeChillemi (GiuseppeChillemi)>:
Once you create it, use this code:

[1:14:59](#MJ7glBqQYvabmQ8YhcworoXOGXy-aF36lwA83EKkyPo) <GiuseppeChillemi (GiuseppeChillemi)>:
```
;--- Here we insert the specs in the panel creator after
;---- the function has been created, so we don't bind the content to it

insert/only head body-of :p1 specs/p1 
```

[1:15:18](#lDOLo5ulTvKyUlZHvNwFlWVNP3h_t78bEztJ_Uzo3XI) <GiuseppeChillemi (GiuseppeChillemi)>:
Now the panel creator is complete and you can simpy:

[1:17:27](#0zw9TpJNBqYvvyyAIQd50eda_Fi5I2jyM_TZqnjNRJg) <GiuseppeChillemi (GiuseppeChillemi)>:
```
;--- Running the function we get the panel build and with its context bound
;
view probe f

[b: button "Print me" 50x20 [probe b/text]]
```

To have a working button



[1:18:33](#r1tRrhnn0RaqnvCuHtpZiiFve3rgtwbbwfvLshqzoiQ) <GiuseppeChillemi (GiuseppeChillemi)>:
But if you want to include the button inside a panel, you may need to have its context together with the panel bound 

[1:19:12](#JY7lqoRI9-UHPIcNp6yEQpOJ2GZYacfR1rMjXV3eH2A) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
;--- Running the function we get the panel build and with its context bound
;
view probe p1

[b: button "Print me" 50x20 [probe b/text]]
```

To have a working button

[1:19:33](#idUdZEC3pKUlBPc2W9Bvu8YTBCbUKl0TN-AEyIq75QU) <GiuseppeChillemi (GiuseppeChillemi)>:
```
;--- With this command we have returned the context and the panel in one block
;
probe p1/full

[make object! [
    actor: [probe b/text]
    b: none
] [b: button "Print me" 50x20 [probe b/text]]]

```

[1:21:39](#04zMy4c4LRA9HLIRdwbUGbBzMLTzX5GewxZIza1LXkQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Also `p1/ctx-proto` and `p1/panel-proto` and `p1/specs-of` are available, to have the proto of the context, of the panel of the full specification block.

[1:22:27](#0ipJmPeijJKwmLR_j-xkA_v24z0lBJh0ps4luvLdahQ) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
;--- This is a panels library with just one panel
specs: [
    p1 [
 	[actor: [probe b/text] b: none] ;--- The context of the panel (May be more than one)
 	[b: button "Print me" 50x20 (:actor)] ;--- The panel itself
 ]
]
```

[1:22:33](#Fz7ltaxnLnA7JjVOlCgAcJ6ym3FbX7edrkOiL3t5qJY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
;--- This is a panels library with just one panel
specs: [
   p1 [
 	[actor: [probe b/text] b: none] ;--- The context of the panel (May be more than one)
 	[b: button "Print me" 50x20 (:actor)] ;--- The panel itself
 ]
]
```

[1:25:41](#K_UjQiDzhBQ4IcIR_Duqht2NokicvQcCLfpNfBcDTDQ) <GiuseppeChillemi (GiuseppeChillemi)>:
To include this subpanel, simply

```
view compose [Text "Try this panel" return (p1)]
```


[1:27:36](#NbmNPXL0iBoC-18TffDPYGBT6BPYNu1mrT5LIB6uYlI) <GiuseppeChillemi (GiuseppeChillemi)>:
Well, now the final part of the work is to pass arguments to the panel, as size, text, build a panel creator and propagate the arguments down to where the panel ihas been included. 

[1:28:04](#EEtAZApw-iS08th3ZrgPFFT-U1N416j8QkYD89DFpOI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Well, now the final part of the work is to pass arguments to the panel, as size, text, build a panel creator and propagate the arguments down to where the panel has been included, and the context up where the `compose` has started

[1:29:34](#RXt8bteQQayWC9ESlIXCPeuOH7NJ4Z1ENhOg4tvx-QY) <GiuseppeChillemi (GiuseppeChillemi)>:
Maybe I will include the active contexts for the panel in a block as first element, so you have always them with it.

[1:30:27](#7KhI5N0bXIq-N5ZwkUJXpUtnD01FIq470ciA83PIkNg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Maybe I will include the active contexts for the panel in a block as first element, so you have always them with it. Red will skip them but you can access them upen creation or with `face/actors/actor-name/1`

[1:32:04](#t6d5sFNgjidyOOVRjQQFsJpEsP_F1FtAlFH4JAVrtGo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Now the panel creator is complete and you can simply:

[1:32:26](#UJkRvibem-ZqNm2LVJ_UYhDetzxoVIsZ6v3lCXKDqZ4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
;--- Running the function we get the panel build and with its context bound
;
view probe p1

[b: button "Print me" 50x20 [probe b/text]]
```

To have a working button included in the GUI specs

[1:32:46](#yqUCzv5Ov79i60F7WLxecdGqL_x8wnd61J7FxF1Ueas) <GiuseppeChillemi (GiuseppeChillemi)>:
 * But if you want to include the button inside a panel, you may need its context together with the panel bound 

[1:32:58](#cBEt0FCElWWEKFyOesvFp3VTHAReE8TC7oHIaKEEV8U) <GiuseppeChillemi (GiuseppeChillemi)>:
 * But if you want to include the button inside a panel, you may need its context together with the bound panel

[1:36:35](#klF2za5Vd--OCNy2v2Ijr8uvPxW_7Z9kAPROlR0PuTc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```

;--- This function is the panel creator
;-- running it you get the panel built and bound to its contexts
;-- /ctx-proto reutrns the context specs 
;-- /panel-proto returns the proto of the panel
;-- /specs-of "You get the full panel specification"
;-- /full returns the context and the panel build and bound in a block

p1:  func [
	"This is a panel"
	/ctx-proto "Returns the context proto"
	/panel-proto "You get the panel proto"
	/specs-of "The full ctx and panel proto are returned"
	/full "Creates and returns the CTX and the Panel"
	/local
	specs
	ctx
	panel
] [
	;<--- At first position of the specs body we will insert the panel specs
	;---
	specs: first body-of system/words/context? 'local   ;-- accessing it in this way
	ctx: make object! specs/1   ;--- we create the context of the function
	panel: bind copy/deep specs/2 ctx   ;--- Here we bind the panel
        ;--- As default, the following code returns the panel bound
	case [
		ctx-proto [specs/1]
		panel-proto [specs/2]
		specs-of [specs]
		full [reduce [ctx compose/only panel]]
		true [compose/only panel]
	]
] 
```

[5:24:49](#HbPkY7l2cOTP4caV2G8k1KBDUMvVze-FXKtW_7elLts) <hiiamboris>:
it seems VID has slipped into the button `b2` code somehow ‚òª

[5:25:45](#Qw-VcXVIpMlB7nGljJcH4pwvZJwy3841GEieW7wp1Tw) <hiiamboris>:
I don't see `P1` in the code above

[5:29:49](#ebjJfHiM3fZlA4_bwlmRXr7ZIbRicmpsDOPqvGP_49Q) <hiiamboris>:
referring to - where?

[5:30:29](#TXJrn_zjCcq3C8yZ57tmLEbfJGaNS2QfgHLX15fDaNs) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> referring to - where?

Forget it and look at the last work.

[5:38:32](#cR2GmC1GVi2UmtdFbSYiUbpq-nLEzpwpGDLqYD4xCc4) <hiiamboris>:
okay, so you mean `compose` is now enough for all this to work?

[6:04:10](#kwH3QUs1nbhSVjUhYFQhUF5c8008F62Q8CcZS-TvduY) <GiuseppeChillemi (GiuseppeChillemi)>:
I need to che complete it. We need some context to pass down to the lower levels and another to fill with the returned ones. I am om the way.

[6:07:27](#m-2ReE36Ksl7ssiFcU4Dhn-sLEmfGNy4xnxKs0mHw_8) <GiuseppeChillemi (GiuseppeChillemi)>:
* I need to complete it. We need some context to pass down to the lower levels and another to fill with the returned ones. I am om the way.

[6:12:50](#5-SzXSKVr5qhhrtTZPbYTVt02Cwv1V6MaWzp69SOaTs) <GiuseppeChillemi (GiuseppeChillemi)>:
by now we can use compose to have a panel with Independent context built from a library which has only the context proto and the panel proto. A panel whose words are bound only to the passed ctx and no words from the container function. This let you avoid a CREATE-PANEL PANEL-NAME one and use just the PANEL-NAME and pass the arguments you need to the function (soon)

[6:27:44](#-stU1ejMhEIggr5MDQoLacVTxp32fdgIxeNhxWz8JXE) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> okay, so you mean `compose` is now enough for all this to work?

With just one word: yes

## 1-Nov-2024

[15:21:43](#e_Bi2jtrSxVbhAh5DFwtwfwP33_6VvK1ALvj3d-XOII) <GiuseppeChillemi (GiuseppeChillemi)>:
About this experiment of composing multiple panels with embedded creation and context code, now I manage it enough. But there is a new layer of complexity that must be addressed if you want to see them as an unique entity...

[15:26:55](#TejYqR30Mwg4tspTp_ePwpbwQm3tOm2poCB68x9mYf8) <GiuseppeChillemi (GiuseppeChillemi)>:
... Imagine an event happening at level 4, like hitting Enter on a field. Now think you want to set a a word in a context at level 3, 2 and 1 and each one should execute some code. 

[15:29:23](#zZFTG4CmyLGzUgM9s1j1uc4ojSJm37ntUHGI9Q1NDS4) <GiuseppeChillemi (GiuseppeChillemi)>:
You may rewrite the actor at level 4 to do this, but if you want to have a ON-SET like event, or a reaction,  included in the code and trasparent to your upper face, now things really become complicated.

[15:30:02](#UUx3YzhlCdoFfBaNkvXF4RrK6JzJM668Xslsfrew9mQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* You may rewrite the actor at level 4 to do this, but if you want to have a ON-SET like event, or a reaction,  included in the code of each level and trasparent to your upper face (the one which os incoudind the others) now things really become complicated.

[15:30:22](#cN1ny6t-LLsspiN0_1Z_T9AuwjzJYLrK_IyGnkzonqM) <GiuseppeChillemi (GiuseppeChillemi)>:
* You may rewrite the actor at level 4 to do this, but if you want to have a ON-SET like event, or a reaction,  included in the code of each level and trasparent to your upper face (the one which os includind the others) now things really become complicated.

[15:31:37](#6XLB_PfWdS-bMk6uTHpbndfpr1F85_CC24EFcJayF8M) <hiiamboris>:
welcome to design :)

[15:36:24](#mu5AMUQQoHTLOnNYzRo6PXg2At-pka9lnKTb76cXpOs) <GiuseppeChillemi (GiuseppeChillemi)>:
I also would like to have some kind of read-only context words, words exported to the upper level and others invisible and internal. So the whole panel has a visible interface and also internal contexts, events and words.

[15:36:47](#Do1LbASC99i45a-u9B2Lp1MxMpe0d--DY6P0ZtQifaQ) <GiuseppeChillemi (GiuseppeChillemi)>:
I think I'd better go crazy before

## 8-Nov-2024

[14:55:55](#ZadOvhT7ZqhYvNgZCT-LpMThm2MP7PC3CMzekbBD-Dc) <GiuseppeChillemi (GiuseppeChillemi)>:
I am playing with reactivity. Here is an object with validation in his fields

[14:56:05](#vxe-Oi2TPNnddx-xSFSbRKWPOuPoaITvoQpyx81CzS8) <GiuseppeChillemi (GiuseppeChillemi)>:
```
ctx-test: make reactor! [a: none b: none]
relate (to-set-word in ctx-test 'a) [if all [:ctx-test/a :ctx-test/a > 2] [do make error! "A is over 2!"]]

ctx-test/a: 1
Print "Set a to 1"
ctx-test/a: 2
Print "Set a to 2"
ctx-test/a: 3
```

[14:56:25](#BAVF1IIG3Aio3d7-pboWBHhwTJW-juznCerkS88Ek3E) <GiuseppeChillemi (GiuseppeChillemi)>:
Result:

[14:56:31](#5jRES0noVn_wr2w1BB_qzm3YCOegm0UPK-olQCefV5k) <GiuseppeChillemi (GiuseppeChillemi)>:
```
*** User Error: A is over 2!
*** Where: do
*** Near : do make error! "A is over 2!"
*** Stack: do-file check 
*** Near: [if all [:ctx-test/a :ctx-test/a > 2] [do make error! "A is over 2!"]]
```

[14:57:01](#n4t8SbXCN49DSEzX3jOVfj_KtTtGuKboLV2Z4x2-xGY) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
Set a to 1
Set a to 2
*** User Error: A is over 2!
*** Where: do
*** Near : do make error! "A is over 2!"
*** Stack: do-file check 
*** Near: [if all [:ctx-test/a :ctx-test/a > 2] [do make error! "A is over 2!"]]
```

[15:00:46](#ZOfonVSVL8_y292FNt61ukfNaXXqMATa_29JojBPU1I) <GiuseppeChillemi (GiuseppeChillemi)>:
hiiamboris: This is why I want to manually connect the ctx field to a block, so I am not forced to express the code with paths and have `A` as a bound word

[15:01:02](#C9JOHA2JRXBy8pZTN33gr8CZljGw5cg5_PrMUy_qBxw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * hiiamboris: This is why I want to manually connect the `ctx` field to a block, so I am not forced to express the code with paths and have `A` as a bound word

[15:03:05](#eCeByVWkfbfqUeEmsdT2ISui-6RWaZJ3MMp-meHQI8Q) <GiuseppeChillemi (GiuseppeChillemi)>:
I have also created another function, pardon the multiple error checks inside but I used it as a testbed for a new way of documenting errors too.

[15:03:58](#R1MRVvaaPG1wMR2ddvBVLSBbCUhb3bjPyDBXCUzpsIE) <GiuseppeChillemi (GiuseppeChillemi)>:
```
reflect: func [
	"Propagates the value to all the words of the relations block"
	relations [block!] "[ctx word ... ...] to propagate the value to"
	/local
	base-ctx 
	word ;block!
	ln
	err
] [
		
	;TBD: potresti linkare solo alla prima, a meno che la seconda non sia trasformata
	;Come fare tutti i controllo qui dentro in parse?
	;TBD: testo con path come CTX pointers, oppure con parentesi tonde.. magar implementare DO
	; questa ultima cosa serve per SET IN
	
	if all [
		err: "Length < 2" 
		(ln: length? relations) >= 2 
		
		err: "Length not even"
		even? ln
	] [
		err: none ;Clearing the error
		
		set [base-ctx word] relations
		relations: skip relations 2
	]
	
	if parse relations [some [word! word!]] [

		foreach [ctx word] relations [
			case/all [
				not word? :ctx [err: rejoin ["CTX of relation is not a word! but: " type? :ctx]] 
				not object? get :ctx [err: rejoin ["ctx word: " ctx " does not contain an object but: " type? get :ctx]]
				not word? word [err: rejoin ["In relations an element is not a word"]] 
				none? in get :ctx word [err: rejoin ["Word: " word " does not exists in ctx: " ctx]]
				true [relate (to-set-word in get :ctx probe word) compose copy/deep [(to-get-path reduce [base-ctx word])]] 			
			]			
		]
	]
	if err [do make error! err]
	
]
```

[15:05:32](#quVTK9PPQmSQmOr6aDBx7BVhdTxW9vPc51NfLOJel7k) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
reflect: func [
	"Propagates the value to all the words of the relations block"
	relations [block!] "[ctx word ... ...] to propagate the value to"
	/local
	base-ctx 
	word ;block!
	ln
	err
] [
		
	;TBD: potresti linkare solo alla prima, a meno che la seconda non sia trasformata
	;Come fare tutti i controllo qui dentro in parse?
	;TBD: testo con path come CTX pointers, oppure con parentesi tonde.. magar implementare DO
	; questa ultima cosa serve per SET IN
	
	if all [
		err: "Length < 2" 
		(ln: length? relations) >= 2 
		
		err: "Length not even"
		even? ln
	] [
		err: none ;Clearing the error
		
		set [base-ctx word] relations
		relations: skip relations 2
	]
	
	if parse relations [some [word! word!]] [

		foreach [ctx word] relations [
			case/all [
				not word? :ctx [err: rejoin ["CTX of relation is not a word! but: " type? :ctx]] 
				not object? get :ctx [err: rejoin ["ctx word: " ctx " does not contain an object but: " type? get :ctx]]
				not word? word [err: rejoin ["In relations an element is not a word"]] 
				none? in get :ctx word [err: rejoin ["Word: " word " does not exists in ctx: " ctx]]
				true [relate (to-set-word in get :ctx word) compose copy/deep [(to-get-path reduce [base-ctx word])]] 			
			]			
		]
	]
	if err [do make error! err]
	
]
```

[15:05:38](#ZQDakolKhL345CPylTasaUC9GTZet0wHoDMwEhXcRwM) <GiuseppeChillemi (GiuseppeChillemi)>:
Here is a test code:

[15:05:46](#m4Z0sEeumLOylIo9xwm7vSpD8iUdlWGK-Ou1jhsYKrw) <GiuseppeChillemi (GiuseppeChillemi)>:
```
exposed-ctx: reactor [text: none]
level1-ctx: context [text: none]
gui-ctx: context [text: none]

connections: [
	exposed-ctx text 
	level1-ctx text 
	gui-ctx text
]


reflect connections

exposed-ctx/text: "Hi" ()
probe exposed-ctx
probe gui-ctx
probe level1-ctx
```

[15:05:50](#TaPxZRw0sEWyMar86_bDFukinEnA7pdpM3rNF1vjt9Y) <GiuseppeChillemi (GiuseppeChillemi)>:
And the result:

[15:06:19](#MaUHWAQlJClXbfKiIWr70K09pgqpRj8lHE3qWsVkbns) <GiuseppeChillemi (GiuseppeChillemi)>:
```
make object! [
    text: "Hi"
]
make object! [
    text: "Hi"
]
make object! [
    text: "Hi"
]
```

[15:07:18](#14otCWu30XeCj3u1JR646CSg0xHWj3PyskkHRBSeJGI) <GiuseppeChillemi (GiuseppeChillemi)>:
This an idea to propagate the lower panel context words upwards to the exposed context

[15:07:44](#Ya6oYWRgzvnKODAr0-gtyZXZ-DuhPAyESkvM-gisM30) <hiiamboris>:
Note that `reflect` is a native you override

[15:07:52](#0RCGLeI5TRWQhQ6lD3gOSO2eYvqMYLhSQ56AHxdZF2g) <GiuseppeChillemi (GiuseppeChillemi)>:
Thank you

[15:08:05](#mFewCT5xoEu-nTKrK3RMzn-SpRSKG-jvbDkM9iSXK4k) <GiuseppeChillemi (GiuseppeChillemi)>:
I will use `mirror`

[15:09:52](#ZNJSnj3IkgWk8ONVthuvnguVZzIoDambnqqkv98FlfU) <GiuseppeChillemi (GiuseppeChillemi)>:
If the upper level context is also a `reactor` I think I could set back any changes to the lower level field using `quietly` or `set-quite` if the field in the exposed context is `read/write`

[15:12:03](#XMxMcZJygDVDDp8_1NJ9bwyy1T9ANovkn_ErqgVqZpQ) <GiuseppeChillemi (GiuseppeChillemi)>:
This exposed context should have `relate`d code to write to the origing without triggering the reaction annd being circular. 

[16:54:20](#gyUBkd2JtvS2mwQsHSg6a2yZQYBfQWnGRNCB2fe71n8) <hiiamboris>:
react/link seems just the thing you need imo

[17:07:10](#qz_wzBQ8S3B8Wfksle7feWxDquxQA3JkST8Mo3EWYb8) <GiuseppeChillemi (GiuseppeChillemi)>:
you are the master here, it is just 2 days I am using reactions.

[17:21:19](#brtKug7MMHwKwb7eITnZpFXmDU1r45YPmXnafKIthMA) <gurzgri>:
Not sure if reactivity is the right tool for the particular job of object property validation. Relations are all about synchronizing changes from one object to another. What you are doing here is using (abusing?) reactivity between one object and itself just to implement what in other languages would be a setter method.

You could just as well "simply" just do

``` 
>> foo: context [bar: you: none on-change*: func [word old new] [switch word [bar you [if new > 2 [set-quiet word old  cause-error 'script 'out-of-range [new]]]]]] ()
>> foo/bar: 2
>> foo/bar: 3    ;*** Script Error: value out of range: 3
>> foo/bar       ;2    
>> baz: make foo [] ()
>> baz/you: 3   ;*** Script Error: value out of range: 3
```
with the added benefit of being able to make more objects from a proto object.

You won't be able to do this with reactifity without setting up new reactions for each and every new object and their proerties.

[17:22:26](#XQRZnsrw5qKJIuhzyL_5cSqxsVspMnBT2yvjQznKfoQ) <gurzgri>:
 * Not sure if reactivity is the right tool for the particular job of object property validation. Relations are all about dataflow between different objects. What you are doing here is using (abusing?) reactivity between one object and itself just to implement what in other languages would be a setter method.

You could just as well "simply" just do

```
>> foo: context [bar: you: none on-change*: func [word old new] [switch word [bar you [if new > 2 [set-quiet word old  cause-error 'script 'out-of-range [new]]]]]] ()
>> foo/bar: 2
>> foo/bar: 3    ;*** Script Error: value out of range: 3
>> foo/bar       ;2    
>> baz: make foo [] ()
>> baz/you: 3   ;*** Script Error: value out of range: 3
```

with the added benefit of being able to make more objects from a proto object.

You won't be able to do this with reactifity without setting up new reactions for each and every new object and their proerties.

[17:23:06](#Aq-Pl81x7no7cYR2sZaVuirUXp1ySuQoF_tGniaGEKI) <gurzgri>:
 * Not sure if reactivity is the right tool for the particular job of object property validation. Relations are all about dataflow between different objects. What you are doing here is using (abusing?) reactivity between one object and itself just to implement what in other languages would be a setter method.

You could just as well "simply" just do

```
>> foo: context [bar: you: none on-change*: func [word old new] [switch word [bar you [if new > 2 [set-quiet word old  cause-error 'script 'out-of-range [new]]]]]] ()
>> foo/bar: 2
>> foo/bar: 3    ;*** Script Error: value out of range: 3
>> foo/bar       ;2    
>> baz: make foo [] ()
>> baz/you: 3    ;*** Script Error: value out of range: 3
```

with the added benefit of being able to make more objects from a proto object.

You won't be able to do this with reactifity without setting up new reactions for each and every new object and their proerties.

[18:40:04](#Ur1v3hOyOjlWKmxtgduVtm2uXzLJvgJrx7mHpbDn8-8) <hiiamboris>:
I'll just remind that [classy-object](https://codeberg.org/hiiamboris/red-common/src/branch/master/classy-object.red) already does all that

[19:17:35](#br3GgI1UYhA0Nmdz8t_c3Hv9bY2e5_1TvGyWHroE46U) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@gurzgri-56c25b3ae610378809c19713:gitter.im> Not sure if reactivity is the right tool for the particular job of object property validation. Relations are all about dataflow between different objects. What you are doing here is using (abusing?) reactivity between one object and itself just to implement what in other languages would be a setter method.
> 
> You could just as well "simply" just do
> 
> ```
> >> foo: context [bar: you: none on-change*: func [word old new] [switch word [bar you [if new > 2 [set-quiet word old  cause-error 'script 'out-of-range [new]]]]]] ()
> >> foo/bar: 2
> >> foo/bar: 3    ;*** Script Error: value out of range: 3
> >> foo/bar       ;2    
> >> baz: make foo [] ()
> >> baz/you: 3    ;*** Script Error: value out of range: 3
> ```
> 
> with the added benefit of being able to make more objects from a proto object.
> 
> You won't be able to do this with reactifity without setting up new reactions for each and every new object and their proerties.

Thanks, I didn't remember about on-change*. Reactivity is my new toy and I am learning. And yes, I was "abusing" it to create a validation method.

[19:18:13](#TmjcPWqFIvK7hKWgN7HL0p14hQVg6VwSA2NuoZyVxOo) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> I'll just remind that [classy-object](https://codeberg.org/hiiamboris/red-common/src/branch/master/classy-object.red) already does all that

In the cave of the master there are a lot of hidden gems

## 10-Nov-2024

[20:44:16](#UvNZ0UhvBSLOeQODH9X5sosRAYo9twHozLpU6QrfQPg) <GiuseppeChillemi (GiuseppeChillemi)>:
I have completed my field mirroring function on anonymous contexts using a map. Here is the link: https://gist.github.com/GiuseppeChillemi/99e77fa72f8a417b82d3e7502068c1a8




[20:47:10](#RCDoMQeV8rBPCwOIPvpH3d2OKuIEGUVq_JIbbZ7i5yQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Here are 2 test:


```
;----- Test 1
o1: make reactor! [a: none]
o2: make reactor! [b: none]
o3: make reactor! [c: none]

mirror [o1 o2] [a b]
mirror [o2 o3] [b c]

o1/a: "Hello"

probe o3
```

The result:
```
;--- Result
;
make object! [
    c: "Hello"
]
```

Second test, using a function that modifies the values:
```
;----- Test 2
o1: make reactor! [a: none]
o2: make reactor! [b: none]
o3: make reactor! [c: none]

mirror/code [o1 o2] [a b [rejoin [start/a start/a]]]
mirror/code [o2 o3] [b c [rejoin [start/b start/b]]]

o1/a: "Hello"

probe o3
```
Here is the result
```
;--- Result
;
make object! [
    c: "HelloHelloHelloHello"
]
```

[20:51:20](#aKbyLUJQCrBI-_5jVBUwEnRJ5b8s6Vc6w7Xz1Jmcd4s) <GiuseppeChillemi (GiuseppeChillemi)>:
Opinions are welcome and suggestions. I have documented a lot the code because it is very tecnical. Let me know if this kind of documenting style is clear or I need to change it.

[21:12:12](#8yHZNbz0CIvFcSl1xJCmWiWRjMDG7G6kz__OmhE_UXg) <GiuseppeChillemi (GiuseppeChillemi)>:
Removed a small error, the context was not created a function composing but a runtime, exposing the content to the paths gatering

[21:15:41](#KGt3G6oRyEqei7IUCX2mXMHUyiixjk0yWl4nOzfV4xw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Removed a small error, the context which shielded you rocde was not created at function composing but a runtime, exposing the content to the paths gatering

[23:31:07](#sZJUB2ybWwzcJIk_XaAKMqewOtqheSOkHz_80WSbKZA) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Removed a small error, the context which shielded your code was not created at function composing but a runtime, exposing the content to the paths gatering

[23:31:35](#OUjPNL37HBZX06q1Q9vtPoT2tI2Uumnv2-nTfDrY7bE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Removed a small error, the context which shielded your code was not created at function composing but a runtime, exposing the content to the paths collection

## 11-Nov-2024

[5:39:40](#NX3sBYWRXPtItf98-SbS4XtDiOtEljljjly2yNJhqW8) <hiiamboris>:
> <@giuseppechillemi-59045d00d73408ce4f5bcd9d:gitter.im> Opinions are welcome and suggestions. I have documented a lot the code because it is very tecnical. Let me know if this kind of documenting style is clear or I need to change it.

you've beaten even Gregg ;)

[11:12:20](#cyehhC629UoLyZA-V0WdJLygikLKYF8SclCgBokcKm8) <GiuseppeChillemi (GiuseppeChillemi)>:
I confess, it is also for me, because the building is enough complicated that in a month from now I would need someone explaining me how it works.

## 17-Nov-2024

[23:38:51](#TQcyzM9WWmv4xZdIcLDVCyNKAaCmSXR-h7sZNXWO7kQ) <GiuseppeChillemi (GiuseppeChillemi)>:
I have completed my work on field value propagation dialect. 
It is very simple:

```
ctx/a ctx2/z

```

So each time you write in `a`, then it is mirrored in `z`

But you can also express as

```
[a z]
or
[ctx/a z]
```

This is an example of a possible mapping:

```
[
a z


[23:40:25](#YEzqJGNNye50Cjp6jsYqF4ScGfDyO6lHskn7th7TAO0) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I have completed my work on field value propagation dialect.
It is very simple:

```
ctx/a ctx2/z

```

So each time you write in `a`, then it is mirrored in `z`

But you can also express as

```
[a z]
or
[ctx/a z]
```

This is an example of a possible mapping:

```
[
a ctx/z
b ctx/y
ctx/y ctx2/sss  <- Note, it propagates the previous step 
]
```

[23:42:59](#s8UGDGrlNDHDSzZEWlFy_WNOWrV7hNLAnM_uU5EqRfg) <GiuseppeChillemi (GiuseppeChillemi)>:
You may also provide a transformation code:

```
[
  a z  [nxt/z: to-string start/a] 
  b ctx/y
]
```

[23:43:42](#2oR1uOqoGvCWosDOU6Y9ENzMIGidHzarWeZx16X5q10) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You may also provide a transformation code, as you have `START` and `NXT` as available words in the code block

```
[
  a z  [nxt/z: to-string start/a] 
  b ctx/y
]
```

[23:44:19](#3hSgM4VqkZquPYpkVtuShnwd4M9FABwQ0Jh5u8tG_hg) <GiuseppeChillemi (GiuseppeChillemi)>:
And also provide multiple destinations:

[23:44:50](#7zOfXSTb0-Kpnj6T8HgRX-_4PjwQDKGl3bzMMGtqZFM) <GiuseppeChillemi (GiuseppeChillemi)>:
```
  a [z y w x] 
  b ctx/y
]
```

[23:45:20](#w6sELxG5cVNacFWhUo83liqTcOvDkaBq1-VJmmvY29E) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
  a [ctx/z ctx/y ctx/w ctx/x] 
  b ctx/y
]
```

[23:45:35](#pTQsAIcJrabnWefPSZoXOvcuGDMoWA2_veIsvf39lyc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You may also provide a transformation code, as you have `START` and `NXT` as available words in the code block

```
[
  a ctx/z  [nxt/z: to-string start/a] 
  b ctx/y
]
```

[23:46:12](#A__PCeE-zjKnYBMED2NnYoprYfUCTvhin8MMd-LXl5E) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You may also provide a transformation code, as you have `START` and `NXT` as available words in the code block

```
[
  ctx/a ctx2/z  [nxt/z: to-string start/a] 
  ctx/b ctx2/y
]
```

[23:46:38](#lFEKVmaLI9WobFAmouvwz2kZm2iSqJehh-oOM9bauXg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
  a [ctx2/z ctx2/y ctx2/w ctx2/x] 
  b ctx2/s
]
```

[23:47:10](#P0rUH10xf-KHljS2Tv77QQSDWXCNuImDnig1y2suzBQ) <GiuseppeChillemi (GiuseppeChillemi)>:
With tranformation code:


[23:48:04](#QO4dgQVCux5NogITZFU2f88Uk0bcuk_5mnFzNKhJr-M) <greggirwin (Gregg Irwin)>:
Sounds interesting, and flexible. So it's like a reactive system across objects?

[23:48:13](#XfTJspylSUtv91SX4UeZtu1qZqTe2WpzqXFHkGNPbFU) <GiuseppeChillemi (GiuseppeChillemi)>:
Sounds interesting, and flexible. So it's like a reactive system across objects?

[23:48:32](#B_vqc57N4Vv3VGZ1JzI18YLaP4KqJILZ5Wd0w4KNDsk) <GiuseppeChillemi (GiuseppeChillemi)>:
 * With tranformation code:
```
  ctx/a [ctx2/z [nxt/h: to-string start/a] ]  ctx2/y ctx2/w ctx2/x] 
  ctx/b ctx2/s
]
```

[23:49:03](#VCBmq3w1_gmnmmsbq09WLgZy6BHRei68zErLUsEt0Po) <GiuseppeChillemi (GiuseppeChillemi)>:
I have added the last part, you have writtem before its completition

[23:49:22](#fQKg6KayX6kOJR4JTjD8rz0pj_1i_s13fnDSvNnyGco) <greggirwin (Gregg Irwin)>:
:^)

[23:53:34](#Uc5k4XGjLLRP-CWQ_qxwcfrh-fzNM6hJ8IIUQU4rFF0) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> Sounds interesting, and flexible. So it's like a reactive system across objects?

Yes, it uses the reactivity to propagate a field to one or multiple destinations on each line. You may also add transformation code and there you can do anything with the source and destination context. You can modify the value to write ot anything else.

[23:53:51](#mb9mI_m2P0vtl3BcOgDhRuCLcBnQEZ5ALppBTrEkNCY) <greggirwin (Gregg Irwin)>:
Very cool.

## 18-Nov-2024

[0:47:58](#Vvk7JviVzmwmmJNNB6iFSYhiDC-nzUB_8Al3WE7BAmU) <GiuseppeChillemi (GiuseppeChillemi)>:
Here it is the [propagation dialect](https://gist.github.com/GiuseppeChillemi/c329ea80c320eb0d696468c26dd060ad), you need my other function [mirror](https://gist.github.com/GiuseppeChillemi/99e77fa72f8a417b82d3e7502068c1a8)



[0:56:15](#MNxC3SAW7lDLSyMb4y1fOfaxFkhM1txynVNWw5fB2A4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Here it is: the [propagation dialect](https://gist.github.com/GiuseppeChillemi/c329ea80c320eb0d696468c26dd060ad)!, you need my other function [mirror](https://gist.github.com/GiuseppeChillemi/99e77fa72f8a417b82d3e7502068c1a8)

[0:57:26](#oQRbkduyh2kSj4auZ8ocI2DnNDUTxJsYEl8d-y1ZcQo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I have completed my work on a field value propagation dialect.
It is very simple:

```
ctx/a ctx2/z

```

So each time you write in `a`, then it is mirrored in `z`

But you can also express as

```
[a z]
or
[ctx/a z]
```

This is an example of a possible mapping:

```
[
a ctx/z
b ctx/y
ctx/y ctx2/sss  <- Note, it propagates the previous step 
]
```

[0:58:27](#L8UFXEflBCk4TguxBr1LElh9P_nIjWpT5a9hVSb2zGg) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I have completed my work on a field value propagation dialect.
It is very simple:

```
propagate  [ctx/a ctx2/z]

```

So each time you write in `a`, then it is mirrored in `z`

But you can also express as

```
propagate  [a z]
or
propagate  [ctx/a z]
```

This is an example of a possible mapping:

```
propagate  [
  a ctx/z
  b ctx/y
  ctx/y ctx2/sss  <- Note, it propagates the previous step 
]
```

[0:58:37](#v8nWEKrTcUciWm7WkAVI0Oxe3np8V_0eiP1kdKA9j4Y) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You may also provide a transformation code, as you have `START` and `NXT` as available words in the code block

```
propagate  [
  ctx/a ctx2/z  [nxt/z: to-string start/a] 
  ctx/b ctx2/y
]
```

[0:58:50](#uyP0w0-Ep_Z7p1_EbyRAtShWVR4JErEReiV1y6sjg38) <GiuseppeChillemi (GiuseppeChillemi)>:
 * ```
propagate  [
  a [ctx2/z ctx2/y ctx2/w ctx2/x] 
  b ctx2/s
]
```

[0:59:05](#zqHVQlSuvroUloG_5lYEBvKuafEN3zGe2Lrnl8_RLx8) <GiuseppeChillemi (GiuseppeChillemi)>:
 * With tranformation code:

```
propagate  [
  ctx/a [ctx2/z [nxt/h: to-string start/a] ]  ctx2/y ctx2/w ctx2/x] 
  ctx/b ctx2/s
]
```

[1:00:18](#uUXh2TKnhZVmMuJSR0FU80B06LXEkBByI6r6zwa3yEg) <GiuseppeChillemi (GiuseppeChillemi)>:
greggirwin (Gregg Irwin): I have fixed the examples above that you have destroyed with your teleporting while I was in the middle of writing them. Don't interrupt me next time!

[1:00:59](#N1CAzw29Xr3IXKc4j_JMtzBs0Oh-qipX2FJqtKF_Jds) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> Sounds interesting, and flexible. So it's like a reactive system across objects?

 * Yes, it uses the reactivity to propagate a field to one or multiple destinations on each line. You may also add transformation code and there you can do anything with the source and destination context. You can modify the value to write or anything else.

[1:01:15](#TvGS5vtB9dCtlP-_pdOuFu2Wia4KqYnHJgjDTsSfrBE) <greggirwin (Gregg Irwin)>:
No promises. :^)

[1:14:04](#Q_w5gwuC4ZTI_4vphANFyx6TD0NNAmyxRf9U2W_L6ho) <greggirwin (Gregg Irwin)>:
Can you imagine how much code this would take in another language?

[1:17:53](#W-hjA5DaS-xicuwhVExejMX1gblwYWYjM8qvy3Jku7I) <GiuseppeChillemi (GiuseppeChillemi)>:
In fact I was looking at the code and admiring how short it was. In another language I would have spent a month and a lot of pages

[1:21:26](#menaDbNdms8gsAmmDRrhcIlTps8sVou2wdNSHeGbsHk) <GiuseppeChillemi (GiuseppeChillemi)>:
The only open question is how `react/link` I have used in `MIRROR` interacts with `on-change*`

[1:22:35](#v7gMOYyXrqf8SPRIiOQRCCBI1gt9q1BXPiU1hmtMUFw) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The only open question is how `react/link` I have used in `MIRROR` interacts with `on-change*` I have tried to patch it and seen only `WORD` has a value and `new` and `old` arguments are functions that requires a value.

[1:25:57](#AXbICfKfBFLyGYWWmwaVlk9vKjU186YIcvRWmXcqaL8) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The only open question is how `react/link` I have used in `MIRROR` interacts with `on-change*` I have tried to patch it and seen only `WORD` has a value and `new` and `old` arguments are functions that requires a value instead of values. So seems Red modifies the `on-change*` calling args

[1:26:37](#VvjQr4G0DXRofnUzQYSUYYpY4sSSf5ITvAhFalycPhM) <GiuseppeChillemi (GiuseppeChillemi)>:
I would like to mix gurzgri `mutator-object` tecnique with mine, so I can `GET/SET` and add propagation over it.

[1:26:56](#kANs1LA9-lQTk2VpVXaFA1q7bnGy6h_6IKJYh-xj_ks) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I would like to mix gurzgri `mutator-object` tecnique with my `propagate` one, so I can `GET/SET` and add propagation over it.

[1:35:19](#lRLzS9fc16O2HW4Vb_kYeF6T3cGb6nmG5GcV7k74Yzc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I would like to mix gurzgri `mutator-object` tecnique with my `propagate` one, so I can `GET/SET` and add propagation over it. But I don't undestand how reactions are queued, how the caller changes and how `*on-change` function is modified.

[1:35:41](#QRtly41joRvHfCdtgnD0CkjMfIHDW8oV9gF6qOMZnTE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I would like to mix gurzgri `mutator-object` tecnique with my `propagate` one, so I can `GET/SET` and add propagation over it. But I don't undestand how reactions are queued, how the caller changes and how `*on-change` function is modified by `react/link`

[1:36:20](#Ta31FM7iMFGNhqKh3RbO6Zlye2QxG48uRp8wNY3F-EM) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I would like to mix gurzgri `mutator-object` tecnique with my `propagate` one, so I can `GET/SET` and add propagation over it. But I don't undestand how reactions are queued, how the caller changes and how `*on-change` function is modified by `react/link` (funny, I have written `react/kink` and seen it has a sense :-D ) 

[2:03:26](#-pra-pAX1lp5Wp2p969Iw6tPweUDu89iNIizjSp23lA) <GiuseppeChillemi (GiuseppeChillemi)>:
I have found the source of reactivity functions in the blog. Where in the objects datatype and other parts of the source I can see how ON-CHANGE* is triggered and called?

[7:00:08](#AwXXsFlL02u48B4SWmUixbSvPsHD7na_rQFHJGPERyQ) <gurzgri>:
See `fire-on-set` and it's companions in `red/runtime/datatypes/object.reds`

[7:06:38](#ovzE7D7Dhhrdk6DpD3619aQPjHlnO2sSMM480gWRong) <GiuseppeChillemi (GiuseppeChillemi)>:
Grazie! 

## 26-Nov-2024

[2:41:18](#Wpl9nQIsrv7NFijuWmzv6xxHNTR2ZuLO2_9rEeiCGjE) <GiuseppeChillemi (GiuseppeChillemi)>:
I have simplified the `map-all` function and powered `PROPAGATE`

Now you can have an interface to another object. You can expose its field as READ-ONLY or READ-WRITE. There is a write back mechanism that is able to trigger the reactions of the starting field without triggering a loop.

Example:

```
ctx1: make reactor! [aaaaa: 44444 bbbbb: 66666 ccccc: 99999 ddddd: 11111]
ctx2: make reactor! [aaaaa:  bbbbb: none]

propagate [
	ctx1/aaaaa ctx2/aaaaa ctx1/bbbbb ctx2/bbbbb
	:ctx2/aaaaa ctx1/aaaaa :ctx2/bbbbb ctx1/bbbbb	
]
```
The `GET-*` notation mean: when you write back on me all reactions start but you skip the one that writes on me, so the look is interrupted.

```
Now we we write forward, from the original object to the interface
```
ctx2/aaaaa: "WRITING-FORWARD"
ctx1/bbbbb: "WRITING-FORWARD" 
Print "Context1"
probe ctx1
Print "Context2"
probe ctx2

;--- Result

Context1
make object! [
    aaaaa: "WRITING-FORWARD"
    bbbbb: "WRITING-FORWARD"
    ccccc: 99999
    ddddd: 11111
]
Context2
make object! [
    aaaaa: "WRITING-FORWARD"
    bbbbb: "WRITING-FORWARD"
]
```
Now we write backward, from the interface to the original object:

```
ctx2/aaaaa: "WRITING-BACKWARD" 
ctx2/bbbbb: "WRITING-BACKWARD" 
Print "Context1"
probe ctx2 ;--- Note, this is the interface
Print "Context2"
probe ctx1

;----- Result
Context2
make object! [
    aaaaa: "WRITING-BACKWARD"
    bbbbb: "WRITING-BACKWARD"
]
Context1
make object! [
    aaaaa: "WRITING-BACKWARD"
    bbbbb: "WRITING-BACKWARD"
    ccccc: 99999
    ddddd: 11111
]
```


[2:42:57](#__Z4c6p0SbaF4KD0pv9CjbFtSuk1UFvEnoN1HHMX9Vs) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I have simplified the `map-all` function and powered `PROPAGATE`

Now you can have an interface to another object. You can expose its field as READ-ONLY or READ-WRITE. There is a write back mechanism that is able to trigger the reactions of the starting field without triggering a loop.

Example:

```
ctx1: make reactor! [aaaaa: 44444 bbbbb: 66666 ccccc: 99999 ddddd: 11111]
ctx2: make reactor! [aaaaa:  bbbbb: none]

propagate [
	ctx1/aaaaa ctx2/aaaaa ctx1/bbbbb ctx2/bbbbb
	:ctx2/aaaaa ctx1/aaaaa :ctx2/bbbbb ctx1/bbbbb	
]
```

The `GET-*` notation mean: when you write back on me all reactions start but you skip the one that writes on me, so the look is interrupted.


Now we we write forward, from the original object to the interface
```

ctx2/aaaaa: "WRITING-FORWARD"
ctx1/bbbbb: "WRITING-FORWARD"
Print "Context1"
probe ctx1
Print "Context2"
probe ctx2

;--- Result

Context1
make object! [
  aaaaa: "WRITING-FORWARD"
  bbbbb: "WRITING-FORWARD"
  ccccc: 99999
  ddddd: 11111
]
Context2
make object! [
  aaaaa: "WRITING-FORWARD"
  bbbbb: "WRITING-FORWARD"
]

```
Now we write backward, from the interface to the original object:

```
ctx2/aaaaa: "WRITING-BACKWARD"
ctx2/bbbbb: "WRITING-BACKWARD"
Print "Context1"
probe ctx2 ;--- Note, this is the interface
Print "Context2"
probe ctx1

;----- Result
Context2
make object! [
  aaaaa: "WRITING-BACKWARD"
  bbbbb: "WRITING-BACKWARD"
]
Context1
make object! [
  aaaaa: "WRITING-BACKWARD"
  bbbbb: "WRITING-BACKWARD"
  ccccc: 99999
  ddddd: 11111
]
```

[2:43:32](#VYzRZDN5GHI21juySuqu8zPZojqUVc8do1AqfEJYRwo) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I have simplified the `map-all` function and powered `PROPAGATE`

Now you can have an interface to another object. You can expose its field as READ-ONLY or READ-WRITE. There is a write back mechanism that is able to trigger the reactions of the starting field without triggering a loop.

Example:

```
ctx1: make reactor! [aaaaa: 44444 bbbbb: 66666 ccccc: 99999 ddddd: 11111]
ctx2: make reactor! [aaaaa:  bbbbb: none]

propagate [
	ctx1/aaaaa ctx2/aaaaa ctx1/bbbbb ctx2/bbbbb
	:ctx2/aaaaa ctx1/aaaaa :ctx2/bbbbb ctx1/bbbbb	
]
```

The `GET-*` notation mean: when you write back on me all reactions start but you skip the one that writes on me, so the look is interrupted.

Now we we write forward, from the original object to the interface

```

ctx1/bbbbb: "WRITING-FORWARD"
ctx2/aaaaa: "WRITING-FORWARD"
Print "Context1"
probe ctx1
Print "Context2"
probe ctx2

;--- Result

Context1
make object! [
  aaaaa: "WRITING-FORWARD"
  bbbbb: "WRITING-FORWARD"
  ccccc: 99999
  ddddd: 11111
]
Context2
make object! [
  aaaaa: "WRITING-FORWARD"
  bbbbb: "WRITING-FORWARD"
]

```

Now we write backward, from the interface to the original object:

```
ctx2/aaaaa: "WRITING-BACKWARD"
ctx2/bbbbb: "WRITING-BACKWARD"
Print "Context1"
probe ctx2 ;--- Note, this is the interface
Print "Context2"
probe ctx1

;----- Result
Context2
make object! [
  aaaaa: "WRITING-BACKWARD"
  bbbbb: "WRITING-BACKWARD"
]
Context1
make object! [
  aaaaa: "WRITING-BACKWARD"
  bbbbb: "WRITING-BACKWARD"
  ccccc: 99999
  ddddd: 11111
]
```

[2:45:12](#NoGCLrMNUClMGs3s5r6vPq3q87OI3oa0xeBaEE6Tycg) <GiuseppeChillemi (GiuseppeChillemi)>:
You can have any interfaces you want but I need to deep test the interference between them.

[2:45:37](#HuWkTjpwugW9i4jigQ2Ynh_97VRaz_AO-7zGv6V_HAI) <GiuseppeChillemi (GiuseppeChillemi)>:
 * You can have any interfaces you want but I need to deep test the interferences between them.

[2:47:13](#eAagSZbX2FcV3nFaGkPv8uMIFC7RymRZlW8R2WVb0jo) <GiuseppeChillemi (GiuseppeChillemi)>:
The exposed interface can be READ/ONLY, READ/WRITE-BACK, or just WRITE-ONLY. 

[2:47:46](#wtJe-CKqbYL50aMkRkRxnpcuYI4BegV1vfC_bZQkHJ8) <GiuseppeChillemi (GiuseppeChillemi)>:
 * The exposed interface can be READ/ONLY (writing is not propagated back), READ/WRITE-BACK, or just WRITE-ONLY. 

[2:50:39](#LGjrgGKtqnPm-eGGAM1uauGOj-sDGB9U8KJvzrpyrVY) <GiuseppeChillemi (GiuseppeChillemi)>:
In the future version (very far), writing on a read only interface will keep the previous values or will trigger an error but I need to deep study the sistem. It won't happen for long time.

[2:51:18](#zdcZvYeHCG9G1u24ntAchl6_zkifeyn2x9JhAcxfnZQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Rememeber that when propagating, you can use an additional code to modify the value before writing to the target

[2:55:26](#KooyxH9kDpF8L-Z4kCDKsFfT3U_L3KafVzXwxKaa1FE) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I have simplified the `map-all` function and powered `PROPAGATE`

Now you can have an interface to another object. You can expose its field as READ-ONLY or READ-WRITE. There is a write back mechanism that is able to trigger the reactions of the starting field without triggering a loop.

Example:

```
ctx1: make reactor! [aaaaa: 44444 bbbbb: 66666 ccccc: 99999 ddddd: 11111]
ctx2: make reactor! [aaaaa:  bbbbb: none]

propagate [
	ctx1/aaaaa ctx2/aaaaa ctx1/bbbbb ctx2/bbbbb
	:ctx2/aaaaa ctx1/aaaaa :ctx2/bbbbb ctx1/bbbbb	
]
```

The `GET-*` notation mean: when you write back on me all reactions start but you skip the one that writes on me, so the loop is interrupted.

Now we we write forward, from the original object to the interface

```

ctx1/bbbbb: "WRITING-FORWARD"
ctx2/aaaaa: "WRITING-FORWARD"
Print "Context1"
probe ctx1
Print "Context2"
probe ctx2

;--- Result

Context1
make object! [
  aaaaa: "WRITING-FORWARD"
  bbbbb: "WRITING-FORWARD"
  ccccc: 99999
  ddddd: 11111
]
Context2
make object! [
  aaaaa: "WRITING-FORWARD"
  bbbbb: "WRITING-FORWARD"
]

```

Now we write backward, from the interface to the original object:

```
ctx2/aaaaa: "WRITING-BACKWARD"
ctx2/bbbbb: "WRITING-BACKWARD"
Print "Context1"
probe ctx2 ;--- Note, this is the interface
Print "Context2"
probe ctx1

;----- Result
Context2
make object! [
  aaaaa: "WRITING-BACKWARD"
  bbbbb: "WRITING-BACKWARD"
]
Context1
make object! [
  aaaaa: "WRITING-BACKWARD"
  bbbbb: "WRITING-BACKWARD"
  ccccc: 99999
  ddddd: 11111
]
```

## 29-Nov-2024

[2:58:53](#-w3Mf9J-o9S5N5MBJFtkuw7HrQXr7cqzbGwIUJAoebg) <GiuseppeChillemi (GiuseppeChillemi)>:
I have completed my functions:

[Mirror](https://gist.github.com/GiuseppeChillemi/99e77fa72f8a417b82d3e7502068c1a8) for 1 to 1 field propagation with optional modifying code

[Propagate](https://gist.github.com/GiuseppeChillemi/c329ea80c320eb0d696468c26dd060ad) For a mirroring dialect which can accept multiple sources and destination and code segments, together with reactions control. 

[2:59:21](#p8qRdP6qe7yFrZWEy_3JKaYBEz0pwqPVgvFZpRR_p1Q) <GiuseppeChillemi (GiuseppeChillemi)>:
 * I have completed my functions:

[Mirror](https://gist.github.com/GiuseppeChillemi/99e77fa72f8a417b82d3e7502068c1a8) for 1 to 1 field propagation with optional modifying code

[Propagate](https://gist.github.com/GiuseppeChillemi/c329ea80c320eb0d696468c26dd060ad) For a mirroring dialect which can accept multiple sources and destinations; code segments ans reactions control.

[2:59:44](#PgvxiLrxdgGbloeP_Hu9aTyeV2r0Gi3D2vzcXxSzoD8) <GiuseppeChillemi (GiuseppeChillemi)>:
Now I can go back to work on panels.

[3:00:07](#8zt4Lxn9ze3DG8PodV1EF-UGK8n_Ewjh7dRV8A9A0i0) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Now I can go back to work on composable panels, I have the instrument I needed.

[3:00:16](#8-7opd-hD_C9kEzpG02xD_iRNtbg7zRenLTxbCrMX2M) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Now I can go back to work on composable panels, I have the instrument I need.

[11:33:18](#_viKQJ9sfnrB2_XE2lyOknt_qbuPmIVA4Le59jNtIME) <GiuseppeChillemi (GiuseppeChillemi)>:
It still misses something: function execution support. Back to work using Apply! Ì†ΩÌ≤™Ì†ºÌøª

[20:28:44](#F9HO1JNeMfk1xz74KRMi3huoKURK_tbZGMVX6bNekx8) <GiuseppeChillemi (GiuseppeChillemi)>:
Well, I am on the way.  I have used the functions from the `apply` [article](https://www.red-lang.org/2023/06/dynamic-refinements-and-function.html). If you want to create the same function and and call the original one from the inside of the copy, I face a problem with all the approaches of the article: the `APPLY` function reduces his block. So if APPLY encounters a function, other args are EATEN, if the argument if a path, you have the same problem. So, how do I AVOID `APPLY` reducing the values without using QUOTE?
  

[20:57:07](#FKRkoliYRvXsTSe0F768xvkmCXJCIdsU0B-kiKNyXp0) <greggirwin (Gregg Irwin)>:
Can you post a small example of what you're trying to do? You are deep into abstractions now, which can be hard to convey by description.

[20:57:45](#mT0HYFV8EYtxGd6fnnwkHswR1bPOq38A-PZqf8eUUJg) <greggirwin (Gregg Irwin)>:
Ah, in the other group already.

[23:29:44](#HPcjLMbeedb9Ln5WtL8WWYkrrgclH1lH25wB0p4ahsg) <GiuseppeChillemi (GiuseppeChillemi)>:
Continuing from [here:](https://matrix.to/#/!mjbZGzLqlsqlDLaQVP:gitter.im/$MitE9ea9B_otZoUF-WZEE6QGWbbG9V3foMngd5saNEY?via=gitter.im&via=matrix.org&via=tchncs.de)

[23:31:50](#SM0oI17djK_qTXMcI1E91pzGMy5f81c-wk8mJr244YU) <GiuseppeChillemi (GiuseppeChillemi)>:
 * Continuing from [here:](https://matrix.to/#/!mjbZGzLqlsqlDLaQVP:gitter.im/$CPO5qjmf-77kJfI4oKN2a0tF8VeUIDiJuWrlH4F12u4?via=gitter.im&via=matrix.org&via=tchncs.de)

## 30-Nov-2024

[1:27:58](#1whDl97uoWrIDCCF2zZg0FVrMMPOiZyknk6ysyNxtOE) <GiuseppeChillemi (GiuseppeChillemi)>:
I have ended the work and now the function is called `replica`, you find it [here](https://gist.github.com/GiuseppeChillemi/892c6f3048a1d668713afed70ab1c6af)

The purpose of this function is to create one which calls the original having an identical interface. You can add a code to manipulate the passed arguments before calling the original function. I will use it in my `propagate` dialect to call a function in an inner object from an external one without copying it. The addituonal code could be used to manipulate the arguments between calling the target function. 







[1:31:56](#sID2SaW0owlmOf7ZyIWPA1LdaCizj9BkL42TPFfcysE) <GiuseppeChillemi (GiuseppeChillemi)>:
In this way the outer interface to inner object is able to call function other than propagating values. 

Think about a vid panel made of multiple ones that exposes:

`[play next back current-track song-name]`

Or a DB navigation composite panel with just:

`[prev next top bottom row-num row]`

That updates the panel in all of its parts with only this context.



[1:32:20](#b6GXmqTnTpunfczkE1k0dK72hOi4uMuGmK0deAWP4uo) <GiuseppeChillemi (GiuseppeChillemi)>:
This is the "vision"

[1:42:56](#sS3p0iDoDR0EDqB1n3n_np2MT-6Om0f_7tQIwYJ9vjU) <GiuseppeChillemi (GiuseppeChillemi)>:
But there is another one moving me since I have started being here: having a way to extend a function to manage custom datatypes and/or support more arguments and refinements.
Now that have APPLY and the ON-CHANGE* gurzgri: tecnique, I think I can reach the goal. REPLICA can be seen as the foundation of the to be created EXTEND-FUNCTION 

[1:43:35](#oDCk1dkm77VcVlb96ywYSboVq4_ZYl97Jl78w7Ajcgo) <GiuseppeChillemi (GiuseppeChillemi)>:
* But there is another one moving me since I have started being here: having a way to extend a function to manage custom datatypes and/or support more arguments and refinements. Now that have APPLY and the ON-CHANGE* (for the custom datatype part) 
@gurzgri-56c25b3ae610378809c19713:gitter.im: tecnique, I think I can reach the goal. REPLICA can be seen as the foundation of the to be created EXTEND-FUNCTION

[20:20:20](#LUwgSZmi6UwHYxo3JRaS52h_qjkJpHaRDlvmlgrdql0) <gurzgri>:
GiuseppeChillemi (GiuseppeChillemi)  That `replica` is a lot of code with a bunch of helpers.

```
wrap: function ["Recreate a function from its specs" fun [word! any-function! path!] /with code [block!]] [
	spec: remove-each value spec-of :fun [find [string! block!] type?/word value]
	unless find spec /local [append spec /local]
	words: copy collect [foreach word spec [keep to word! word]]
	func spec: spec-of :fun compose/only/deep [
		do bind system/words/any [(code) []] context? 'local
		apply/all quote (:fun) bind (words) context? 'local
	]
]

seek: wrap :find
seek [a b c d cc dd] 'c

power-seek: wrap/with :find [all [number? value value: value ** 2]]
power-seek [1 4 9 16 25 36 49] 5
```

seems to accomplish similiar things. Not tested beyond the samples provided, though.

[20:21:29](#E_YBu0NrkvB0_IUBPy3p5L_A4TlV0HGrL_paviqDK0Y) <gurzgri>:
 * GiuseppeChillemi (GiuseppeChillemi)  That `replica` is a lot of code with a bunch of helpers.

```
wrap-func: function ["Recreate a function from its specs" fun [word! any-function! path!] /with code [block!]] [
	spec: remove-each value spec-of :fun [find [string! block!] type?/word value]
	unless find spec /local [append spec /local]
	words: copy collect [foreach word spec [keep to word! word]]
	func spec: spec-of :fun compose/only/deep [
		do bind system/words/any [(code) []] context? 'local
		apply/all quote (:fun) bind (words) context? 'local
	]
]

seek: wrap-func :find
seek [a b c d cc dd] 'c

power-seek: wrap-func/with :find [all [number? value value: value ** 2]]
power-seek [1 4 9 16 25 36 49] 5
```

seems to accomplish similiar things. Not tested beyond the samples provided, though.

[20:22:52](#Ellcc9tlu_Li1yGm1HWxBzd1ZqMfM6oZO74Ip6vp_4s) <gurzgri>:
 * GiuseppeChillemi (GiuseppeChillemi)  That `replica` is a lot of code with a bunch of helpers.

```
wrap-func: function ["Recreate a function from its specs" fun [word! any-function! path!] /with code [block!]] [
	spec: remove-each value spec-of :fun [find [string! block!] type?/word value]
	unless find spec /local [append spec /local]
	words: copy collect [foreach word spec [keep to word! word]]
	func spec: spec-of :fun compose/only/deep [
		do bind system/words/any [(code) []] context? 'local
		apply/all quote (:fun) bind (words) context? 'local
	]
]

seek: wrap-func :find
seek [a b c d] 'c ;== [c d]

power-seek: wrap-func/with :find [all [number? value value: value ** 2]]
power-seek [1 4 9 16 25 36 49] 5 ;== == [25 36 49]
```

seems to accomplish similiar things. Not tested beyond the samples provided, though.

[20:23:29](#DWCYPW1XuBuViejZH_6viijFqwop4Nz2C7mZRKEb2W4) <gurzgri>:
 * GiuseppeChillemi (GiuseppeChillemi)  That `replica` is a lot of code and relies on a bunch of helpers, too.

```
wrap-func: function ["Recreate a function from its specs" fun [word! any-function! path!] /with code [block!]] [
	spec: remove-each value spec-of :fun [find [string! block!] type?/word value]
	unless find spec /local [append spec /local]
	words: copy collect [foreach word spec [keep to word! word]]
	func spec: spec-of :fun compose/only/deep [
		do bind system/words/any [(code) []] context? 'local
		apply/all quote (:fun) bind (words) context? 'local
	]
]

seek: wrap-func :find
seek [a b c d] 'c ;== [c d]

power-seek: wrap-func/with :find [all [number? value value: value ** 2]]
power-seek [1 4 9 16 25 36 49] 5 ;== == [25 36 49]
```

seems to accomplish similiar things. Not tested beyond the samples provided, though.

[20:23:51](#Fk-OUesrvuRVUVp2O-d8PPXSHIkEbGwqPLdeytADydc) <gurzgri>:
 * GiuseppeChillemi (GiuseppeChillemi)  That `replica` is a lot of code and relies on a bunch of helpers, too.

```
wrap-func: function ["Recreate a function from its specs" fun [word! any-function! path!] /with code [block!]] [
	spec: remove-each value spec-of :fun [find [string! block!] type?/word value]
	unless find spec /local [append spec /local]
	words: copy collect [foreach word spec [keep to word! word]]
	func spec: spec-of :fun compose/only/deep [
		do bind system/words/any [(code) []] context? 'local
		apply/all quote (:fun) bind (words) context? 'local
	]
]

seek: wrap-func :find
seek [a b c d] 'c ;== [c d]

power-seek: wrap-func/with :find [all [number? value value: value ** 2]]
power-seek [1 4 9 16 25 36 49] 5 ;== [25 36 49]
```

seems to accomplish similiar things. Not tested beyond the samples provided, though.

[20:24:33](#MqzuF9EVz4cNGno8FQDBF33E6GkEBWAoLsPy-YtkW0Q) <gurzgri>:
 * GiuseppeChillemi (GiuseppeChillemi)  That `replica` is a lot of code and relies on a bunch of helpers, too.

```
wrap-func: function ["Recreate a function from its specs" fun [word! any-function! path!] /with code [block!]] [
	spec: remove-each value spec-of :fun [find [string! block!] type?/word value]
	unless find spec /local [append spec /local]
	words: copy collect [foreach word spec [keep to word! word]]
	func spec: spec-of :fun compose/only/deep [
		do bind system/words/any [(code) []] context? 'local
		apply/all quote (:fun) bind (words) context? 'local
	]
]

seek: wrap-func :find
seek [a b c d] 'c ;== [c d]

power-seek: wrap-func/with :find [if number? value [value: value ** 2]]
power-seek [1 4 9 16 25 36 49] 5 ;== [25 36 49]
```

seems to accomplish similiar things. Not tested beyond the samples provided, though.

## 1-Dec-2024

[0:01:17](#xdulGqLrl4VBYojytkV3WOe8FnXxNuoKnqfx92O9ikg) <GiuseppeChillemi (GiuseppeChillemi)>:
Thanks, there are power commands that I still have to learn to make things shorter.

[3:19:17](#o5SdfBjYoY77IKgIXUvXWqmI7TKkAoL8fX62bpTUdL8) <GiuseppeChillemi (GiuseppeChillemi)>:
"Seems" :D 
I have seen it on the editor and tested. Great work!

[3:29:12](#JblVJZl0udpjXSFb6-2oawuUbaLwxP04yknCw2uZ-8g) <GiuseppeChillemi (GiuseppeChillemi)>:
But there is the same problem I have had to avoid with the additional GET-ALL and QUOTES:
```
f: func [
	x 
] [
	Probe :x
]
g: func [y [string!]] [Print ["hello " y]]

ff: wrap-func :f
ff :g "world!"
```
Result:
```
*** Script Error: x does not allow logic! for its y argument
*** Where: x
*** Near : apply/all quote func [x /local][Probe :x] 
*** Stack: do-file ff
*** Files: %"/G/Il mio Drive/Dev/Scripts/FLibrary2.r"
```

`Apply` reduces the words you pass, so they must all be quoted. 

[3:29:39](#US1P40Lu6CesizBGvNnscDeDQdGNt9cL22TALoPMm_A) <GiuseppeChillemi (GiuseppeChillemi)>:
 * But there is the same problem I have had to avoid with the additional `GET-ALL` and `QUOTES`:

```
f: func [
	x 
] [
	Probe :x
]
g: func [y [string!]] [Print ["hello " y]]

ff: wrap-func :f
ff :g "world!"
```

Result:

```
*** Script Error: x does not allow logic! for its y argument
*** Where: x
*** Near : apply/all quote func [x /local][Probe :x] 
*** Stack: do-file ff
*** Files: %"/G/Il mio Drive/Dev/Scripts/FLibrary2.r"
```

`Apply` reduces the words you pass, so they must all be quoted.

[3:31:25](#rTKIIHBXL0ZchdHXCpABNXyJJwhxXzCKn-38tEMDRxc) <GiuseppeChillemi (GiuseppeChillemi)>:
 * But there is the same problem I have had to avoid with the additional `GET-ALL` and `QUOTES`:

```
f: func [
	x 
] [
	Probe :x
]
g: func [y [string!]] [Print ["hello " y]]

ff: wrap-func :f
ff :g "world!"
```

Result:

```
*** Script Error: x does not allow logic! for its y argument
*** Where: x
*** Near : apply/all quote func [x /local][Probe :x] 
*** Stack: do-file ff
*** Files: %"/G/Il mio Drive/Dev/Scripts/FLibrary2.r"
```

`Apply` reduces the words you pass, so they must all be quoted, because if you pass a function or a path, they will become active.

[3:32:03](#-zUfNk6LXli3ZA8llNN36OYk-KMRS39cXIHhuxzbMx4) <GiuseppeChillemi (GiuseppeChillemi)>:
 * But there is the same problem I have had to avoid with the additional `GET-ALL` and `QUOTES`:

```
f: func [
	x 
] [
	Probe :x
]
g: func [y [string!]] [Print ["hello " y]]

ff: wrap-func :f
ff :g "world!"
```

Result:

```
*** Script Error: x does not allow logic! for its y argument
*** Where: x
*** Near : apply/all quote func [x /local][Probe :x] 
*** Stack: do-file ff
*** Files: %"/G/Il mio Drive/Dev/Scripts/FLibrary2.r"
```

`Apply` reduces the words you pass, so they must all be quoted, because if you pass a `function!` or a `path!` and other types, they will become active.

[3:33:53](#nFH9NhY8xId9P3nup3F-qpq1dGktJQShcZEstDdKQco) <GiuseppeChillemi (GiuseppeChillemi)>:
It is a (great) limitation of `apply`, you can't use it until you manually process the arguments or using a function made for the purpose.

[3:42:51](#DQ4JPUC-6MjfykX4N-1UkFxGDVPEDRX04JT4_jksF-U) <GiuseppeChillemi (GiuseppeChillemi)>:
 * But there is the same problem I have had to avoid with the additional `GET-ALL` and `QUOTES`:

```
f: func [
	x 
] [
	Probe :x
]
g: func [y [string!]] [Print ["hello " y]]

ff: wrap-func :f
ff :g "world!"
```

Result:

```
*** Script Error: x does not allow logic! for its y argument
*** Where: x
*** Near : apply/all quote func [x /local][Probe :x] 
*** Stack: do-file ff
*** Files: %"/G/Il mio Drive/Dev/Scripts/FLibrary2.r"
```

`Apply` reduces the words you pass, so they must all be quoted, because if you pass a `function!`, it  will become active (edited)

[13:37:36](#CfrxzM0sSrTP0Mqf9rrjjUxAmhWNnIIitJ8n1vmiZlA) <hiiamboris>:
`[keep to get-word! word]` seems to work

## 29-Dec-2024

[23:51:19](#vPvXUC9WrEejPCnmgkDisp2ntA0X3fa-dulIxcpzX-M) <GiuseppeChillemi (GiuseppeChillemi)>:
I have many functions that works on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing  this, it could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:

`apply/ctx :function-name ctx`

So you would save a lot of cycles having a common passing a CTX without the need to recreating it. 

What about this?

[23:51:26](#OGWUXFUfSskS4kR_ZRLs4jtbR1_gmE-vWuV2AwPmgy0) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many functions that work on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing  this, it could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:

`apply/ctx :function-name ctx`

So you would save a lot of cycles having a common passing a CTX without the need to recreating it.

What about this?

[23:52:37](#obUH9-oiQZpZJ3q38_o0AqD9i-RYqiJbZ11jfym2D2g) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many functions that work on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing  this, it could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:

`apply/ctx :function-name ctx`

So you would save a lot of cycles having a common passing a CTX without the need to recreating it.

What about this?

[23:52:58](#DNl_nCGY-Jmcl-rRvGhTKkUPWTiq0Y_IpWrt4YJvDhU) <GiuseppeChillemi (GiuseppeChillemi)>:
* A variation of the idea could be to pass a second `CTX` with the words of the invoked function that are not in the passed CTX.

[23:53:21](#8N_XeSjPSgGYO2D-sMZNBlMthOU07TqfCpF3R_OCjwU) <GiuseppeChillemi (GiuseppeChillemi)>:
* A variation of the idea could be to pass a second `CTX` with the words of the invoked function that are not in the passed CTX as:

[23:53:42](#XVlLFlSJrpYTk7roWn5A0rHZvOBdI0Zl-7da8pOWXfc) <GiuseppeChillemi (GiuseppeChillemi)>:
* A variation of the idea could be to pass a second `CTX` with the words of the invoked function that are not in the passed CTX as:

[23:54:49](#taQqJUvv1FUdsbpxFrT6x-BlYQBGjk4zggmFQauCpbI) <GiuseppeChillemi (GiuseppeChillemi)>:
* A variation of the idea could be to pass a second `CTX` with the words of the invoked function that are not in the passed `CTX` as:

[23:54:59](#USIao3baH4EtySQc1TimazH5Ftbh7v1ajo8eohIey0k) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many functions that work on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing  this, it could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:

`apply/ctx :function-name ctx`

So you would save a lot of cycles having a common passing a CTX without the need to recreating it.

[23:55:10](#D68OuC091FfRlPUHR0ENDvMAvBYcsRXj5VIhy9Bs3VM) <GiuseppeChillemi (GiuseppeChillemi)>:
What you think about this?

[23:59:36](#Am3D9RmwsuawNLkrCEWbwlDLVFxMGp0CQMh_F6F4FvA) <GiuseppeChillemi (GiuseppeChillemi)>:
(In think Rebol3 has already something like this: [here](https://www.rebol.com/r3/docs/functions/funct.html)

[23:59:44](#u5LmB5Q6uezneryE0CZ6bDsHF56dhhAyhXM0spkGf9I) <GiuseppeChillemi (GiuseppeChillemi)>:
* (In think Rebol3 has already something like this: [here])(https://www.rebol.com/r3/docs/functions/funct.html)

[23:59:58](#ntUFjbcL-zkfVHMzuxFnKhCQgSe83HKI7p4ov_FiFII) <GiuseppeChillemi (GiuseppeChillemi)>:
* (In think Rebol3 has already something like this: [here)(https://www.rebol.com/r3/docs/functions/funct.html))

## 30-Dec-2024

[0:00:13](#raSO6zHJzIAc5nw1V7D1S7jnYMTvGn8Hppu_qFxOnoc) <GiuseppeChillemi (GiuseppeChillemi)>:
* (In think Rebol3 has already something like this: [here](https://www.rebol.com/r3/docs/functions/funct.html))

[0:52:37](#CiiOWeTY2UjR-Xb5rU8ISH71OMhMpkvPaAj05fx_1pA) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many functions that work on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing this, a function could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:
apply/ctx :function-name ctx
So you would save a lot of cycles having a common passing a CTX without the need to recreating it.


[0:53:43](#QL1Cz95C59fuHTW2lZ1-VK8kGFOb_bV9vOtfOSk9tlM) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many functions that work on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing this, a function could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:
apply/ctx :function-name ctx
So you would save a lot of cycles passing a CTX without the need to reinit it.


[2:01:19](#eGldcaZE1jKCNgL4gYrUL5p2AV3jwzLQVsoCkoMrT10) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many functions that work on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing this, a function could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:
`apply/ctx :function-name ctx`
So you would save a lot of cycles passing a CTX without the need to reinit it.


[2:01:52](#3fJcvt3OAR1Cxhoog3Oyoct6yDNjn4e1udmUh3sbnvA) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many functions that work on the same set of data. They have similar interface and context. Each function does the basic init of its context and the continues its operation. Instead of doing this, a function could receive the context ready to be used from the previous functions and set its context to the corresponding values.
It would be great if I could:
`apply/ctx :function-name ctx`
So you would save a lot of cycles passing a CTX without the need to reinitialize it.

[5:28:54](#HrgfwQ3L_SWsgx2Firrk392N10_laxPg2oG2grEPM8s) <hiiamboris>:
what you're describing is how a typical object works: it has shared data and functions that work with it

[12:06:04](#9xTjJwvWRErgRlTRFCkz9QXtvR9uES2QzBTftFZiHOM) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes, a function is basically an object with an interface that you DO. What I am talking about is to SET FUNCTION-CTX CALLER-CTX and run the function, without using the interface syntax with all the argument inline, but just passing a context using APPLY. The command will set even the local words if present. 

[12:13:06](#FQk1vtKq9432z0V_WRHr2U295rjX6y02qHZrr0R1Zto) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes, a function is basically an object with an interface and a body bountls to it that you DO. What I am talking about is to SET FUNCTION-CTX CALLER-CTX and run the function, without using the interface syntax with all the argument inline, but just passing a context using APPLY. The command will set even the local words if present. 

[12:34:48](#jpEFaaRYXIL-kqAe5f6E0J8kzx2Qs6WJ38fhwFmtO2Q) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes, a function is basically an object with an interface and a body bound to it that you DO. What I am talking about is to SET FUNCTION-CTX CALLER-CTX and run the function, without using the interface syntax with all the argument inline, but just passing a context using APPLY. The command will set even the local words if present in the caller CTX.  So you basically have 2 ways of calling the function, the new one with just with just 1 argument and everything ready and in place.

[12:35:11](#gq1MJaX9mL_ypMIXcAvH17-8-Plbb0jhMJ1P2zwVV34) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes, a function is basically an object with an interface and a body bound to it that you DO. What I am talking about is to SET FUNCTION-CTX CALLER-CTX and run the function, without using the interface syntax with all the argument inline, but just passing a context using APPLY. The command will set even the local words if present in the caller CTX.  So you basically have 2 ways of calling functions, the new one with just with just 1 argument and everything ready and in place.

[12:44:54](#2ZGSSO_MmIu8AzfT4C43QPmrxpsknwZm05XP7Eh5dsc) <GiuseppeChillemi (GiuseppeChillemi)>:
Think about functions which works on a VID/SPACE element and at each run every function must do some pre work like checks and calculations and set them to local words. In this way,  when the first function has done this task, may pass the context each function of the same family it needs to call, and so each function called, saving a giant amount of CPU cycles. 

[13:52:41](#0e5Deqgru3U2PjP6i8jnqVRmwBLP3sx5Ex-HFHmyrfg) <hiiamboris>:
For Spaces it's different, it's just one argument I want to pass implicitly. And the "work" it's doing to achieve that is marginal (though that requires a bit trickier function construction).

[13:53:10](#twAoJAJ4UjIrgjvyE_E4lymdbfAiYHML_uhXAB9JifM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Think about functions which works on a VID/SPACE element and at each run every function must do some pre work like checks and calculations and set them to local words. In this way,  when the first function that has done this task, may pass the context to each function of the same family it needs to call, and so each function called can do the same, saving a giant amount of CPU cycles. 

[13:53:17](#aEwFr4UztrP5uf31d8AnMSNleU5M_kHzptrJcGYqGbQ) <hiiamboris>:
What you want sounds like an object with data and nullary functions.

[13:53:20](#YqUnDmrtrBHMCjeE40gQ8OMubkEpFnAwwtuJZkHpb0Q) <GiuseppeChillemi (GiuseppeChillemi)>:
(changed the last period)

[13:56:26](#J250MjgddISCKOO3534FpHty5mak0Pf5i42_0z5RL9s) <hiiamboris>:
A bit similar situation exists in Spaces: after I have rendered a space, I want to use all the intermediate results of this render in other functions in different places. So for that, I just stash the results in the `space/frames` map (in the new design).

[13:58:11](#CL8r7nGrPtYK5O2I6es6lDmD1WtifMzrFDDLn99UPEM) <hiiamboris>:
Also in CLI I used something a bit similar, but as a context for user-provided settings. In the end it paid not to make a mess but to type a prefix when I want to access something from those settings.

[14:14:57](#DC-MuQ8PjbXiYnmtv_vYSyR-KroQddA1Xi86W3W09A4) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@hiiamboris:tchncs.de> What you want sounds like an object with data and nullary functions.

Not nullary (thanks for teaching me this new term) because the function must be called via a regular interface too. But when you are inside loops with functions which have similar contexts, then you could switch to using this way of calling them, so you can bypass setups and checks. 

[14:52:07](#qLsC4DyjlH4Ep2qlK9XfXIOYIpLaX7GzQDCxENaee4c) <GiuseppeChillemi (GiuseppeChillemi)>:
This is a concept of the idea:

```

Test: func [
	"Functions that uses external code"
	a
	b
	/ctx
	ctx*
	/local
	code-ctx
	args-to-sync
] compose [
	
	args-to-sync: [a b]
	
	code-ctx: (
		
		;--- Creating a static object with COMPOSE so you can copy it 
		;  without interpreting a whole prototype at each run of the function
		;
		make object! [
				a:
				b:
				c:
				d:
				e:
				f: none
			]
			;--- Note, with this tecnique you may have default valuess
	)
		
	either ctx [
		;--- Using the passed context with all inits done
		;
		code-ctx: ctx* 
	] [
		;--- Creating a new context
		;
		code-ctx: copy code-ctx
		
		<Init code here>
	]

	;--- Syncing arguments
	;
	set-words code-ctx args-to-sync ;<--- I have a set-words function!
	
	;--- Core of the function without init, From now on you access all words using path
	;
	code-ctx/a: ....
	....
]

;--- In this way you call the function
;
test/ctx arg-a arg-b common-ctx
```

[14:52:58](#Xd7zS_Q6MXrBstX64PtoihCZljT8tk-oTgbLRCEG950) <GiuseppeChillemi (GiuseppeChillemi)>:
* This is a concept of the idea without `APPLY-VALUES`

```

Test: func [
	"Functions that uses external code"
	a
	b
	/ctx
	ctx*
	/local
	code-ctx
	args-to-sync
] compose [
	
	args-to-sync: [a b]
	
	code-ctx: (
		
		;--- Creating a static object with COMPOSE so you can copy it 
		;  without interpreting a whole prototype at each run of the function
		;
		make object! [
				a:
				b:
				c:
				d:
				e:
				f: none
			]
			;--- Note, with this tecnique you may have default valuess
	)
		
	either ctx [
		;--- Using the passed context with all inits done
		;
		code-ctx: ctx* 
	] [
		;--- Creating a new context
		;
		code-ctx: copy code-ctx
		
		<Init code here>
	]

	;--- Syncing arguments
	;
	set-words code-ctx args-to-sync ;<--- I have a set-words function!
	
	;--- Core of the function without init, From now on you access all words using path
	;
	code-ctx/a: ....
	....
]

;--- In this way you call the function
;
test/ctx arg-a arg-b common-ctx
```

[14:53:56](#_SXlH_7E9s0W9ZlY-sdvUhm-Eb5f-AfgpOoR2LpGlkY) <GiuseppeChillemi (GiuseppeChillemi)>:
With `APPLY-VALUES` you would jsut call the function using:

`APPLY-VALUES :TEST common-ctx 

[14:54:04](#5Hpv7865TmjHVXD13GMmlfyfaaX6coxg1tomuz1BmZI) <GiuseppeChillemi (GiuseppeChillemi)>:
* With `APPLY-VALUES` you would jsut call the function using:

\`APPLY-VALUES :TEST common-ctx`

[14:54:23](#PXqxJ8EThzwsQa1F5j819FpPMquAB2k5ZG8hv5_ZJqI) <GiuseppeChillemi (GiuseppeChillemi)>:
* With `APPLY-VALUES` you would jsut call the function using:

`APPLY-VALUES :TEST common-ctx`

[16:11:13](#VkNtjJF8sJ9uyqBrsLVhJw8CgKq4hWL5GjKwgLcxWi4) <hiiamboris>:
looks ultra complicated ;)

[16:12:47](#clnlZx7tbw26TmGGjWcoz-kHgedkp7dkBLZIwtgdLok) <GiuseppeChillemi (GiuseppeChillemi)>:
Don't be fooled by `compose` it is just to speed up things creating a pre-made object.

[16:13:12](#nVb_e9jek2lDNHP1E97Yq1vBOFz7_m-Khmp5myJ2qwc) <hiiamboris>:
I don't even see a `compose`...

[16:15:03](#-XB1AOWAfAwZq2tJOXR4MP1HtyHUtSeZU-Of5EBIZEE) <hiiamboris>:
I don't even see a `compose`...

[16:18:45](#tVTHB_fBmTbDRlkbtYjDperqnea-xERiQBc2KTyQbtQ) <hiiamboris>:
Found it ;)

[16:21:08](#zYa9Kb80TEprMpJhn1hw3Tnd17kB9Fk4m0HGmuiuk0Y) <hiiamboris>:
Sure, as long as your functions do not need reentrancy, this is a good way to address side-shipped data

[16:29:53](#jDn7cnAoZO84NtJvY0Q8vCg7KskI1UCm1c0OqWTENGk) <GiuseppeChillemi (GiuseppeChillemi)>:
Re-entrancy is managed here, in the second block of `either`: 

```
code-ctx: copy code-ctx. 
```
When you call the function without passing a CTX, the base CODE-CTX is copied.

The concep it: the new function stack frame created by calling again itself create a new function context containing the WORD `CODE-CTX` which is not totally new and independent. Then `code-ctx: copy code-ctx` creates a new woking context, totally independend from caller function, so permitting the reentrancy. 


[16:31:18](#pFgQTc556x6WUNOpFSOLu9HfcZSXMAMqTo_pJX0V2kU) <GiuseppeChillemi (GiuseppeChillemi)>:
* Re-entrancy is managed here, in the second block of `either`:

```
code-ctx: copy code-ctx. 
```

When you call the function without passing a CTX, the base CODE-CTX is copied.

The concep it: calling again yuourself you create a new function stack frame with the new function context containing the WORD `CODE-CTX` which is now totally new and independent. Then `code-ctx: copy code-ctx` creates a new woking context, totally independend from caller function, so permitting the reentrancy.

[16:33:20](#KCLEax8pM2vm5hrZtx0BHUoZsgHIDW6Xbi3cgoFFAKE) <GiuseppeChillemi (GiuseppeChillemi)>:
* Re-entrancy is managed here, in the second block of `either`:

```
code-ctx: copy code-ctx. 
```

When you call the function without passing a CTX, the base CODE-CTX is copied.

The concep is: calling again yuourself you create a new function stack frame with the new function context containing the WORD `CODE-CTX` which is now totally new and independent. Then `code-ctx: copy code-ctx` creates a new woking context, totally independend from caller function, so permitting the reentrancy.

[16:34:31](#B27bE2qucxxAC2Cvh4d20ZL8kOPPmix8JmK-Suu9zAo) <hiiamboris>:
Consider also hiding all this interface behind a custom function constructor ;)

[16:38:23](#jL8GLXE3x6WKxuUHfYRlPFUlRjxrsdrPm5qqtpGPRRs) <GiuseppeChillemi (GiuseppeChillemi)>:
It is a good idea but I would prefer having `apply/ctx`

[16:38:30](#p0sfMrk3e3Qp3AW6oS1t7e_7KYA6ET9XbddkLE4eUJ0) <GiuseppeChillemi (GiuseppeChillemi)>:
* It is a good idea but I would prefer having `apply/ctx` :D

[16:43:38](#WP-MPL3PgEN2Jsu-sj4udI7Oa4XxT9Q0kncw_4JkywI) <GiuseppeChillemi (GiuseppeChillemi)>:
Note: I have tried making and `APPLY-CTX` in the last hour but I have faced a fundamental problem: I must REBIND the whole `BODY` as I don't have access to the stack frame, can't create one and apply do the body or any form of virtual temporary binding.

[16:43:52](#dk31-BRvQHQp7n-UCkeOmEQy1QLRx1nWuYTyJYQtyVg) <GiuseppeChillemi (GiuseppeChillemi)>:
In other words: it is slow.

[16:44:17](#nann3q0tTUUhoPjIyHp6z8l3UqtACuWnbpXYXkVEpNU) <GiuseppeChillemi (GiuseppeChillemi)>:
* In other words: it is slow., failing to match the reason for `APPLY/CTX`

[16:44:38](#CiSe35Fid6tQ13QLbUXIartPwCz5M6SHALBwEZjwdWA) <GiuseppeChillemi (GiuseppeChillemi)>:
* Note: I have tried making and `APPLY-CTX` in the last hour but I have faced a fundamental problem: I must REBIND the whole `BODY` as I don't have access to the stack frame, can't create one and apply to the body or any form of virtual temporary binding.

[16:44:39](#9rVSnpqU_vjXQe10ynydy23zrcJYGSpXMi2IGIilx8s) <hiiamboris>:
It's also going to be fault-prone, because you may rebind a function that's half evaluated.. and after returning to it, it will keep evaluating in a wrong context

[16:45:30](#gxZcT-WVcB64IDzQ-RHzcCj9WJpSgWotDbK9SEyFn9Q) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes, I forgot to say: you must DEEP/COPY before BINDING it!

[16:45:53](#A3T1ZECY6jRVs3OQjYuycLvm0F9jNEZ0CuVerDq-mf4) <hiiamboris>:
If you copy/deep the body, you also recreate the function, right?

[16:45:59](#m5HJTlGYQeMuttNbv6me40d1tMWhPq5eQEvk1_qJB-Q) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes, I forgot to say: you must DEEP/COPY before BINDING it with my `APPLY-CTX`

[16:46:58](#IAu5zCk9BDMQTE-N1E-NA08bvYuvbzojs2zxyqnRXS8) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes, this is the reason why this approach if a total failure regarding the original goal of the idea: SPEED!

[16:47:06](#lwpo4IRSZPgoVZg3HaRnskweZkCc6VNj57Yx-8fsmzg) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes, this is the reason why this approach is a total failure regarding the original goal of the idea: SPEED!

[16:48:06](#Jt6H3n4LxmfCWIFk8_UFwFRgQ8lPtcrUGRCM6c0KYKA) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes, this is the reason why this approach is a total failure regarding the original goal of the idea: SPEED! You must DEEP/COPY and then recreate the function.

[16:48:45](#p8OqiKTr-UEFeH6wYnsLRHfvA5MiDr9CJyqXeaohwFE) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes, this is the reason why this approach is a total failure regarding the original goal of the idea: SPEED! You must DEEP/COPY and then recreate the function. Only a native `apply/ctx` can solve this

[19:45:19](#KqoC-VosYcec-e9ST4MP2sQwyrKEzDZmrpxnayTczn8) <GiuseppeChillemi (GiuseppeChillemi)>:
* Re-entrancy is managed here, in the second block of `either`:

```
code-ctx: copy code-ctx. 
```

When you call the function without passing a CTX, the base CODE-CTX is copied.

The concep is: calling again yourself you create a new function stack frame with the new function context containing the WORD `CODE-CTX` which is now totally new and independent. Then `code-ctx: copy code-ctx` creates a new woking context, totally independend from caller function, so permitting the reentrancy.

## 31-Dec-2024

[1:26:03](#dZw4UALZ27-gLByGUQBZeuzyIeehF4ZueK-eXh1HZUw) <GiuseppeChillemi (GiuseppeChillemi)>:
Have fun! [func-ctx](https://gist.github.com/GiuseppeChillemi/6061317f22680e272ae5200c338e16b4)

A whole afternoon work and night

[1:28:12](#5uSC1cIM7huKJdrVUQL-YeeLifnRaXRS1z_Br12-hgA) <GiuseppeChillemi (GiuseppeChillemi)>:
Simple like 1 2 3 4:

Your function:
```
f: func-ctx [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] [
	Probe reduce [
		code-ctx/a
		code-ctx/b
		code-ctx/x
		code-ctx/y
	]
]

;--- Test passing arguments as normal
```
f 1 2
```
--- Result: ---
```
[1 2 none none]

```
;--- Test passing context to set the internal one to
```
f/ctx 0 0 context [a: 1 b: 2 x: 3 y: 4]
```
--- Result: ---
```
[1 2 3 4]
```


[1:28:33](#FGgqoGSwaxganIwZBXmwVww1brYuLoi17RHMiCcCHJ4) <GiuseppeChillemi (GiuseppeChillemi)>:
* Simple like 1 2 3 4:

Your function:

```
f: func-ctx [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] [
	Probe reduce [
		code-ctx/a
		code-ctx/b
		code-ctx/x
		code-ctx/y
	]
]
```
;--- Test passing arguments as normal
```

f 1 2

```
--- Result: ---
```

\[1 2 none none\]

```
;--- Test passing context to set the internal one to
```

f/ctx 0 0 context \[a: 1 b: 2 x: 3 y: 4\]

```
--- Result: ---
```

\[1 2 3 4\]

[1:29:19](#QEOk8IJjUaUOCIIvaGtQGgPPVP1oox8qD34k4v3A7c0) <GiuseppeChillemi (GiuseppeChillemi)>:
* Simple like 1 2 3 4:

Your function:

```
f: func-ctx [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] [
	Probe reduce [
		code-ctx/a
		code-ctx/b
		code-ctx/x
		code-ctx/y
	]
]
```

;--- Test passing arguments as normal

```

f 1 2

```

--- Result: ---

```
[1 2 none none]
```

;--- Test passing context to set the internal one to

```
f/ctx 0 0 context [a: 1 b: 2 x: 3 y: 4]
```

--- Result: ---

```
[1 2 3 4]
```


[1:30:45](#Sh-hoOEcme-2dv9DQLrejYBPBmrZw2fOh-VP5AQ7e_g) <GiuseppeChillemi (GiuseppeChillemi)>:
* Simple like 1 2 3 4:

Your function: (100% Red syntax!)

```
f: func-ctx [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] [
	Probe reduce [
		code-ctx/a
		code-ctx/b
		code-ctx/x
		code-ctx/y
	]
]
```

;--- Test passing arguments as normal

```

f 1 2

```

--- Result: ---

```
[1 2 none none]
```

;--- Test passing context to set the internal one to

```
f/ctx 0 0 context [a: 1 b: 2 x: 3 y: 4]
```

--- Result: ---

```
[1 2 3 4]
```

[1:31:33](#HuHp9J0hoeY-zKZYAERO-ik8u-PVtkBPiM2s4IvYcDo) <GiuseppeChillemi (GiuseppeChillemi)>:
* Have fun! [func-ctx](https://gist.github.com/GiuseppeChillemi/6061317f22680e272ae5200c338e16b4)

A whole afternoon of work, evening and part of the night but it gave me great fun and sense of accomplishment of something nice.

[1:32:41](#pIdoqoP4ypsJ0kh3uqY0FDQE3PPq49Sk8Aw7n_gbOyc) <GiuseppeChillemi (GiuseppeChillemi)>:
* Simple like 1 2 3 4:

Your function: (100% Red syntax!)

```
f: func-ctx [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] [
	Probe reduce [
		code-ctx/a
		code-ctx/b
		code-ctx/x
		code-ctx/y
	]
]
```

;--- Test passing arguments as normal

```
f 1 2
```

--- Result: ---

```
[1 2 none none]
```

;--- Test passing context to set the internal one to
The passed value are dummy ones

```
f/ctx 0 0 context [a: 1 b: 2 x: 3 y: 4]
```

--- Result: ---

```
[1 2 3 4]
```

[1:32:59](#E6lZ-pvCYUldz1G-RqD1Rqv4mAb4vcqbWc8dFQnO9w8) <GiuseppeChillemi (GiuseppeChillemi)>:
* Simple like 1 2 3 4:

Your function: (100% Red syntax!)

```
f: func-ctx [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] [
	Probe reduce [
		code-ctx/a
		code-ctx/b
		code-ctx/x
		code-ctx/y
	]
]
```

;--- Test passing arguments as normal

```
f 1 2
```

--- Result: ---

```
[1 2 none none]
```

;--- Test passing context to set the internal one to
The passed value are dummy ones, will be used those of the context.

```
f/ctx 0 0 context [a: 1 b: 2 x: 3 y: 4]
```

--- Result: ---

```
[1 2 3 4]
```

[1:34:22](#yu-Fl6H7gsaYHKhnmUodWbhTB8SxJxQHDmZT2tkby_M) <GiuseppeChillemi (GiuseppeChillemi)>:
* Simply as 1 2 3 4:

Your function: (100% Red syntax!)

```
f: func-ctx [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] [
	Probe reduce [
		code-ctx/a
		code-ctx/b
		code-ctx/x
		code-ctx/y
	]
]
```

;--- Test passing arguments as normal

```
f 1 2
```

--- Result: ---

```
[1 2 none none]
```

;--- Test passing context to set the internal one to
The passed value are dummy ones, will be used those of the context.

```
f/ctx 0 0 context [a: 1 b: 2 x: 3 y: 4]
```

--- Result: ---

```
[1 2 3 4]
```

[1:36:07](#taHFUxp1__wMLLLpz9kBJsbb1INkmhaj34PkSJvW1-0) <GiuseppeChillemi (GiuseppeChillemi)>:
Hope you like it.

[1:44:08](#AC2RjvyHGq409wyS-1NjDuKb86hq81vgMsYdPHEzSaU) <GiuseppeChillemi (GiuseppeChillemi)>:
Looking at how I have done it, I think I could add a way to use my `set-word` to set th  context of the called function to the values of the passed one without using PREFIXED syntax with:
 
```
SET-WORDS words-of context? 'local ctx*
```
But I must investigate further.
Everything can be simplified if the standard `SET` could accept the function context as first argument.

[1:45:05](#IoE11I8Rxf_ZUrY9lEsiJzlocH59zBt2DH3LHvEq0qE) <GiuseppeChillemi (GiuseppeChillemi)>:
* Looking at how I have done it, I think I could add a way to use my `set-word` to set th  context of the called function to the values of the passed one without using PREFIXED syntax with:

```
SET-WORDS words-of context? 'local ctx*
```

But I must investigate further.
Everything could be simplified if the standard `SET` could accept the function context as first argument and a list of words to sync or not sync.

[1:50:33](#z3trSAV6VsnBpR6TwE0GD5_gtf0xqEJUBZrqhzkWvBw) <GiuseppeChillemi (GiuseppeChillemi)>:
* Hope you like it.
This is an idea I have had really long ago. The original one had a difference: instead of passing a CTX via refinement or using `APPLY/CTX`, a function could be called via an alternate interface when using a prefix or postfix character like:

`~FIND CTX` 

[1:51:10](#o4AU6yPaEso6miV_EwJyeJv4OTcKoctES5A7pbqKq8g) <GiuseppeChillemi (GiuseppeChillemi)>:
* Hope you like it.
This is an idea I have had really long ago. The original one had a difference: instead of passing a CTX via refinement or using `APPLY/CTX`, a function could be called via an alternate interface when **using a prefix or postfix character** like:

`~FIND CTX`

[2:10:58](#6ABeUgOXZM7QcIqYbGlDhuUO_PFN5ARz1rBxABcjbyM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Hope you like it.
This is an idea I have had really long ago. The original one had a difference: instead of passing a CTX via refinement or using APPLY/CTX, a function could be called and instructed to use an alternate interface when using a prefix or postfix character like:
FIND~ CTX


[16:31:14](#NtsFhLcdC6x9IHcBW9wSm5lbM8kkKWyRwQZcehRjEOw) <GiuseppeChillemi (GiuseppeChillemi)>:
Funny, not a bug:

```
>> a: func [b [integer!] integer!][]
== func [b [integer!] integer!][]
>> a 1
*** Script Error: a is missing its integer! argument
*** Where: a
*** Near : a 1
*** Stack: a 
```

[16:31:40](#QiByvfSyeBRm4Cnci_PKQRZZz7dtVEaI7ip_FETFPcE) <GiuseppeChillemi (GiuseppeChillemi)>:
`integer!` can be redefined insed the function specs.

[23:12:43](#XN-21cJJcFSxSfbyjrjNswkcWi-iVR3l8N6T6VQMSUA) <greggirwin (Gregg Irwin)>:
Haven't read it all in depth enough to see the difference, but seems very much like one of the later examples from the `apply` article.

## 1-Jan-2025

[1:03:52](#yZ4lx1otrFjbB88_QcR_iBruQeye5W9PQr95KZZUgGQ) <GiuseppeChillemi (GiuseppeChillemi)>:
These day I will work on the development and then make some whishes for parts that need to be improved in Red. 

[1:04:04](#TGgIEf2XLapwXor3OSJswmdPX1MFs9QldkbasMBAVXE) <GiuseppeChillemi (GiuseppeChillemi)>:
* These days I will work on the development and then make some whishes for parts that need to be improved in Red. 

[1:07:31](#206ropPs1uGH9hvhK8HmXj080SVaoQAtZG7MUxV8tus) <GiuseppeChillemi (GiuseppeChillemi)>:
One of these will be the request for `set/match block! block!`  to write to the target word having the same name, or where one or both are an `object!`. 

[1:39:51](#S1zXbUJ-uCBqfk7KuY42dRPQU9_jObWlbz1abjy9AVc) <GiuseppeChillemi (GiuseppeChillemi)>:
My 2025 starts with an improvement of `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function one to it. The second is... guess!

Normal specs
```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
]
```
Sister function specs:

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

[1:40:49](#N5EIXN_QzvuQmPS1uwmM1kWCM4E9ofyYK6ysp0rbAcs) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement of `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function one to it. The second is... guess!

Normal specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] [
    __proto: [a: none b: none x: none y: none] 
    code-ctx: make object! [
        a: none
        b: none
        x: none
        y: none
    ] 
    either ctx [
        code-ctx: ctx*
    ] [
        code-ctx: either init [make __proto] [copy code-ctx] 
        set-words/any code-ctx words-of context? 'local
    ] 
    if __args-to-sync [set-words code-ctx __args-to-sync] 
    Probe reduce [
        code-ctx/a 
        code-ctx/b 
        code-ctx/x 
        code-ctx/y
    ]
]
```

Sister function specs:

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

[1:41:28](#jVtP-UD3mbAZncLH39TMPie8WTGtVCzIe1yx-Is9FVo) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement of `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function one to it. The second is... guess!

Normal specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] [
    __proto: [a: none b: none x: none y: none] 
    code-ctx: make object! [
        a: none
        b: none
        x: none
        y: none
    ] 
    either ctx [
        code-ctx: ctx*
    ] [
        code-ctx: either init [make __proto] [copy code-ctx] 
        set-words/any code-ctx words-of context? 'local
    ] 
    if __args-to-sync [set-words code-ctx __args-to-sync] 
    Probe reduce [
        code-ctx/a 
        code-ctx/b 
        code-ctx/x 
        code-ctx/y
    ]
]
```

Sister function specs: (The body is identical so I have omitted it)

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

[1:42:35](#83Jqb7EuTR3za244XkXH2filAIEBxQft2Rl6GVf_Zfo) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement to `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function one to it. The second is... guess!

Normal specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] [
    __proto: [a: none b: none x: none y: none] 
    code-ctx: make object! [
        a: none
        b: none
        x: none
        y: none
    ] 
    either ctx [
        code-ctx: ctx*
    ] [
        code-ctx: either init [make __proto] [copy code-ctx] 
        set-words/any code-ctx words-of context? 'local
    ] 
    if __args-to-sync [set-words code-ctx __args-to-sync] 
    Probe reduce [
        code-ctx/a 
        code-ctx/b 
        code-ctx/x 
        code-ctx/y
    ]
]
```

Sister function specs: (The body is identical so I have omitted it)

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

[1:43:20](#x9MC22Nba2YrQh9eH92JwCtunAlS6CsDTnk3KZhEzjE) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement to `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function context to it. The second is... guess!

Normal specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] [
    __proto: [a: none b: none x: none y: none] 
    code-ctx: make object! [
        a: none
        b: none
        x: none
        y: none
    ] 
    either ctx [
        code-ctx: ctx*
    ] [
        code-ctx: either init [make __proto] [copy code-ctx] 
        set-words/any code-ctx words-of context? 'local
    ] 
    if __args-to-sync [set-words code-ctx __args-to-sync] 
    Probe reduce [
        code-ctx/a 
        code-ctx/b 
        code-ctx/x 
        code-ctx/y
    ]
]
```

Sister function specs: (The body is identical so I have omitted it)

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

[1:43:33](#3FkKAZuf9GjkCxe8GOZrBwS1p2NFL3wQnyFa-V4uHBY) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement to `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function context to it. The second is... guess it!

Normal specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] [
    __proto: [a: none b: none x: none y: none] 
    code-ctx: make object! [
        a: none
        b: none
        x: none
        y: none
    ] 
    either ctx [
        code-ctx: ctx*
    ] [
        code-ctx: either init [make __proto] [copy code-ctx] 
        set-words/any code-ctx words-of context? 'local
    ] 
    if __args-to-sync [set-words code-ctx __args-to-sync] 
    Probe reduce [
        code-ctx/a 
        code-ctx/b 
        code-ctx/x 
        code-ctx/y
    ]
]
```

Sister function specs: (The body is identical so I have omitted it)

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

[1:47:01](#J4syg6x3eOVDbr1GNN-b54sYL8p2DUyV12P0hhs5PDc) <GiuseppeChillemi (GiuseppeChillemi)>:
(Solution: a function with local words as arguments, so you can use `APPLY` and the context to set the locals too!)

[1:48:32](#Q-l9HMZr5BTjuhUEzKRz_kPmyCnxFvZMXsZxEMFBBTk) <GiuseppeChillemi (GiuseppeChillemi)>:
* (Solution: a replica of the function with `local` words as arguments, so you can use `APPLY` and the context you want to use to set the function one, so local will be set too when you call it!)

[1:51:02](#G0UtG2Tm6WgpG79vyP3ImKJtI_of3KneDAW_1FP85cA) <GiuseppeChillemi (GiuseppeChillemi)>:
This solution would be greatly enanched if in spedd if `apply` could use a context as second argument (as `apply :func ctx`) or if you implement the option to not reduce the block of the arguments.

[1:51:15](#SpIRSrkeR5FadQ3UeYN87SDCO6IG1NU5o5vh4zphG3Q) <GiuseppeChillemi (GiuseppeChillemi)>:
* This solution would be greatly enanched if in speed if `apply` could use a context as second argument (as `apply :func ctx`) or if you implement the option to not reduce the block of the arguments.

[1:53:16](#ujfDGWZWDIHAoSHbZFuLDhJ2MgquuRhAHLGbCkco7RI) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement to `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function context to it. The second is... guess it!

Normal specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] [
    __proto: [a: none b: none x: none y: none] 
    code-ctx: make object! [
        a: none
        b: none
        x: none
        y: none
    ] 
    either ctx [
        code-ctx: ctx*
    ] [
        code-ctx: either init [make __proto] [copy code-ctx] 
        set-words/any code-ctx words-of context? 'local
    ] 
    if __args-to-sync [set-words code-ctx __args-to-sync] 
    Probe reduce [
        code-ctx/a 
        code-ctx/b 
        code-ctx/x 
        code-ctx/y
    ]
]
```

Sister function specs: (The body is identical so I have omitted it)

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

Also, I am planning to not use the intermediate context in the first function but simply set all the words of the function using `set-word function-ctx context-passed`

[1:54:30](#gmUyfIL7Ur9AcWbASoI2x9OZX5EfNvc5Y7AbFjjhhHk) <GiuseppeChillemi (GiuseppeChillemi)>:
* One of these will be the request for `set/match block! block!`  to write to the target word having the same name, or where one or both are an `object!`.
Another will be to use the function context as target like:

`set context? 'local ctx`

[2:00:07](#4I0ahwPI7IAaE-ADVFx-Z6fdVSVwTOhvEr041R2cMIw) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes it is similar with 1 important difference: I set the LOCAL WORDS too if the CTX passed contains them.

[2:02:18](#uPBmGJhW-K8DUnG8hEIdxYZi_oB_hl-0_5Ghym0_v7Q) <GiuseppeChillemi (GiuseppeChillemi)>:
The goal is that previously calculated elements could be passed to the called function without recalculating them. So if the previous function has setup something from the args, the called one must not setup again them recalculating but simply set the locals of the target object.

[2:03:28](#S60XBVARFkMeeXAqIFVdHngNwjQSBHxBf6HrNGbT4lc) <GiuseppeChillemi (GiuseppeChillemi)>:
With the new refinement you can obtain them using apply creating a twin function where locals are arguments too, so APPLY could be.. applied :D

[2:05:13](#LfAfpk7eglRp6CrzszwttKKs9QB0KoXBD5_7l9-h5fg) <GiuseppeChillemi (GiuseppeChillemi)>:
(But I think this particular use case should be addressed by APPLY because this usage pattern really speeds things up when intermediate working CTX must be recalculated on each function call)

[2:05:59](#EtO6Prfs8WaI2a4LKUBnOzY6cUh4_fxlej0fh9Exq6A) <GiuseppeChillemi (GiuseppeChillemi)>:
* (But I think this particular use case should be addressed by APPLY because this usage pattern really speeds things up when intermediate working CTX must be recalculated at each function call, like explained in last discussion with hiiamboris )

[2:06:51](#6hZeSKwbhAcGCyfrATxPAS0xDZsZSEQy0Q0ukCaHmdg) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement to `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function context to it. The second is... guess it!

Normal specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] 
```

Sister function specs: (The body is identical so I have omitted it)

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

Also, I am planning to not use the intermediate context in the first function but simply set all the words of the function using `set-word function-ctx context-passed`

[2:07:47](#VTPa-jYodm7Om3J4vkTd5rKiMVFGmVEhyq830BnxQWQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes it is similar with 1 important difference: I set the called function LOCAL WORDS too if the CTX passed contains them.

[2:17:44](#_7cXoWH7MyNj11NHillFBbt6RXB-ngbHgCUFrFS4xZ8) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement to `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function context to it. The second is... guess it!

Creation specs:
```
f: func-ctx/sister [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] 
```
`Func-ctx` output specs
```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] 
```

function specs created by `/Sister` : 

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

Also, I am planning to not use the intermediate context in the first function but simply set all the words of the function using `set-word function-ctx context-passed`

[2:23:11](#NLDfiNEjmKmanaq_rpWlbySaSE3pxuBNzanr5K3N66g) <GiuseppeChillemi (GiuseppeChillemi)>:
* My 2025 starts with an improvement to `func-ctx`: the `/sister` refinement. Using it 2 function will be created from the same specs. The first is the one seen above, with the `/ctx` refinement to receive a context to set the function context to it. The second is... guess it!

Creation specs:

```
f: func-ctx/sister [
	"My test function"
	a [integer!] "Value A"
	b [integer!] "Value B"
	/local
	x
	y	
] 
```

`Func-ctx` output specs

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /ctx "Use a ctx to set the function context to" 
    ctx* 
    /init 
    /local 
    code-ctx 
    __proto 
    __args-to-sync 
    x 
    y
] 
```

function specs created by `/Sister` :

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    x 
    y
]
```

You simply remove `/local` when there are no refinements, otherwhise you add to them the datatype `[logic!]`

Also, I am planning to not use the intermediate context in the first function but simply set all the words of the function using `set-word function-ctx context-passed`

[8:46:49](#_o_xUcKYLni7ScGx_9LcRwl6I5Ev8kZr6W_AZ0V2Gic) <GiuseppeChillemi (GiuseppeChillemi)>:
Note: After 12 hours working on a model to pass the context and set the function one to it, init, testing, using path notation, building full specs parser, writing notes and writing here.... before going to bed I have realized the best solution seems taking the SPECS OF a function,  remove /LOCAL, take its BODY and recreate it with an additional character at the end of its name! Just one line of code Ì†ΩÌ∏Å

[8:47:36](#SS1LJ5CCVR1Y3l2PYP_yDtoh985GQhbrI4Umn4eyqWM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Note: After 12 hours working on a model to pass the context and set the function one to it, init, testing, using path notation, building full specs parser, writing notes and writing here.... before going to bed I have realized the best solution seems taking the SPECS OF a function,  remove /LOCAL, take its BODY and recreate it with an additional character at the end of its name! Then use APPLY. Just one line of code! Ì†ΩÌ∏Å

[19:17:33](#DllUA0dkdBIxyK9iBoVBwHxvtcUcDHzPeYi2-ghkq3A) <greggirwin (Gregg Irwin)>:
Red often involves doing things more than once to distill a solution you like.

[21:16:18](#lc4MxDrRdGU2gzWv_PtfhAKnmSOYg2QsNvIC4gtzVqs) <GiuseppeChillemi (GiuseppeChillemi)>:
> <@greggirwin-55659ddb15522ed4b3e1006f:gitter.im> Red often involves doing things more than once to distill a solution you like.

Maybe this process has led to the creation of a new function specs dialect. I have written down some simple to achive ideas. 

## 2-Jan-2025

[2:46:57](#vBxxqIyN7XZL_tZRooue4QaJYlE5OLYgA67o9dCo55g) <GiuseppeChillemi (GiuseppeChillemi)>:
I have a new function specs dialect, it adds 2 things:

1) Verification: just add a code block to the datatypes block like:
```
a [integer! [a > 3]] 
```
2) Default values in locals (with optional verification)
```
a [#set 22] 
```

This spec:



```
f: func-new [
	"My test function"
	a [integer! [a > 3]] "Value A"
	b [integer!] "Value B"
	/test "This is a test"
	/local
	x [#set 22]
	y	
]
```
Produces this:
```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /test "This is a test" 
    x
    y
][
  set/any 'x 22 
  if not do [a > 3] [make error! "Verify failed, arg: a"]
]
```
The principle is really simple:

It add to the body:

`set/any ARG value` for each argument which has a default value

And the line: 

`if not do [CODE-HERE] [make error! "Verify failed, arg: ARG-NAME"]`

For each verification found.

Being in the body of the function, the verification code and any words are all correctly bound.

What about it?

[2:48:22](#zWqLuMKq2FjJcU19x2aULBpT_6q7fbN-MX7Um81l9GA) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have a new function specs dialect, it adds 2 things:

1. Verification: just add a code block to the datatypes block like:

```
a [integer! [a > 3]] 
```

2. Default values in locals (with optional verification)- Just use `#SET <VALUE>` after the local word

```
a [#set 22] 
```

This spec:

```
f: func-new [
	"My test function"
	a [integer! [a > 3]] "Value A"
	b [integer!] "Value B"
	/test "This is a test"
	/local
	x [#set 22]
	y	
]
```

Produces this:

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /test "This is a test" 
    x
    y
][
  set/any 'x 22 
  if not do [a > 3] [make error! "Verify failed, arg: a"]
]
```

The principle is really simple:

It add to the body:

`set/any ARG value` for each argument which has a default value

And the line:

`if not do [CODE-HERE] [make error! "Verify failed, arg: ARG-NAME"]`

For each verification found.

Being in the body of the function, the verification code and any words are all correctly bound.

What about it?

[2:48:51](#uGO_P6rR-nIeeGsy30gmbvU1PFpVgdlh7nOoC5VT67A) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have a new function specs dialect, it adds 2 things:

1. Verification: just add a code block to the datatypes block like:

```
a [integer! [a > 3]] 
```

2. Default values in locals (with optional verification)- Just use `[#SET <VALUE>]` after the local word you want to initialize

```
a [#set 22] 
```

This spec:

```
f: func-new [
	"My test function"
	a [integer! [a > 3]] "Value A"
	b [integer!] "Value B"
	/test "This is a test"
	/local
	x [#set 22]
	y	
]
```

Produces this:

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /test "This is a test" 
    x
    y
][
  set/any 'x 22 
  if not do [a > 3] [make error! "Verify failed, arg: a"]
]
```

The principle is really simple:

It add to the body:

`set/any ARG value` for each argument which has a default value

And the line:

`if not do [CODE-HERE] [make error! "Verify failed, arg: ARG-NAME"]`

For each verification found.

Being in the body of the function, the verification code and any words are all correctly bound.

What about it?

[2:49:59](#4r-A-IYQST5yDFP196Cj7SJHNuYUEvQ_QoGmW2WdfXQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have a new function specs dialect, it adds 2 things:

1. Verification: just add a code block to the datatypes block like:

```
a [integer! [a > 3]] 
```

2. Default values in locals (with optional verification)- Just use `[#SET <VALUE>]` after the local word you want to initialize

```
a [#set 22] 
```

This spec:

```
f: func-new [
	"My test function"
	a [integer! [a > 3]] "Value A"
	b [integer!] "Value B"
	/test "This is a test"
	/local
	x [#set 22]
	y	
]
```

Produces this:

```
func [
    "My test function" 
    a [integer!] "Value A" 
    b [integer!] "Value B" 
    /test "This is a test" 
    x
    y
][
  set/any 'x 22 
  if not do [a > 3] [make error! "Verify failed, arg: a"]
]
```

The principle is really simple:

It add to the body:

`set/any 'ARG-NAME value` for each argument which has a default value

And the line:

`if not do [CODE-HERE] [make error! "Verify failed, arg: ARG-NAME"]`

For each verification found.

Being in the body of the function, the verification code and any words are all correctly bound.

What about it?

[2:59:58](#PVS-8eXwDNUjTPTPNseBYHOlQ0pKXHPrIEfnMVu72ns) <greggirwin (Gregg Irwin)>:
Yes, there are a few others in the wild like this. hiiamboris has one, rebolek (Boleslav B≈ôezovsk√Ω) has one, and I did one many years ago.

On the `set` feature, this aligns with a `default` func that some of us would like as standard, which may also be done with a declarative syntax. e.g. using a set-word for the param. I think Boris, Bolek, and I all used parens for the constraint, as it nicely denotes an active step.

[3:02:10](#UDkkW_atIQWLwFWoJzvGEq6zzypPU-A6FPrJayvlNwY) <GiuseppeChillemi (GiuseppeChillemi)>:
I have avoided paren while having the same idea that it denotes the active step, as we would loose `COMPOSE` capability

[3:02:21](#eTJUtQqZCNuNGMXMK6O9BiDbfnkOBBBPBsCtZE9vjGE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have avoided parens while having the same idea that it denotes the active step, as we would loose `COMPOSE` capability

[3:04:30](#a_7w36lNcgdzmGqXlPEH4sCvaBZSZjG960bQvHKtFi4) <GiuseppeChillemi (GiuseppeChillemi)>:
The output you see is generated by the function, so it is already working.

[3:04:49](#WEuUPNyWoZYiu0nm_h0DFxJ6TOAF_6qkUNLvb-7L5u4) <GiuseppeChillemi (GiuseppeChillemi)>:
* The output you see is generated by func-new, so it is already working.

[3:06:20](#bstz0dulK6PTFehsFyg-9nPrewfu66LPXXNrkC2mYJk) <GiuseppeChillemi (GiuseppeChillemi)>:
* The output you see is generated by func-new, so it is already working. I need just to add the special function generator without `/local` for apply and an `arity 1` function generator with just the context argument containing all. Few days more.

[3:06:28](#NvvfmOwrpzCsQJLN87j0Qfk9pf-ccfno31RCaHHP8nQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* The output you see is generated by func-new, so it is already working. I need just to add the special function generator without `/local` for apply and an `arity 1` function generator with just the context argument containing all. Few days more and it will be here.

[3:06:41](#kaJlXdB8IwZCFgmcECJjQyhNlQPqhcs5dbx6a6994Tg) <GiuseppeChillemi (GiuseppeChillemi)>:
* The output you see is generated by `func-new`, so it is already working. I need just to add the special function generator without `/local` for apply and an `arity 1` function generator with just the context argument containing all. Few days more and it will be here.

[3:09:26](#TOjydH7akZtY-Kc6iH8hqc0CV47FqAk6hCJIcdSLmv8) <GiuseppeChillemi (GiuseppeChillemi)>:
* The output you see is generated by `func-new`, so it is already working. I need just to add the special function generator without `/local` for apply, and an `arity 1` function generator with just the context argument containing all. Few days more and it will be here.

## 4-Jan-2025

[3:04:33](#5uN5NLljP1izGzsz35g9jrFyUSD0SaBB9GzTqZG-jvk) <GiuseppeChillemi (GiuseppeChillemi)>:
The func-ctx is quite ready. Now it has 3 output function with 3 interfaces:
1) Base with defaults, extra checks, init code
2) Plain, with all locals (but special marked) as args on the interface
3) Arity 1 with 1 CTX where you can pass the context and the locals

All from the same specs with just refinements on the creation function

[3:04:46](#EL9I6p2eGD12qAldn0I7iSSGzCMEYZCRFax4eCK_UeM) <GiuseppeChillemi (GiuseppeChillemi)>:
I think on sunday it will be complete

[3:08:46](#CCwiCS-kN_QIJe2gWNgE8r_9wvEXogWS87rDRIPJIgY) <GiuseppeChillemi (GiuseppeChillemi)>:
hiiamboris: Suggesting to have a function creator was the best one. You cant mentally manage all the building process without an automator. The work is to error prone, expecially because I use FUNC

[3:09:03](#WCpwp3MBcUzs-9jpcfKHnZ6au5xCgIwQz2-aOXiwDAs) <GiuseppeChillemi (GiuseppeChillemi)>:
* hiiamboris: Suggesting to have a function creator was the best one. You cant mentally manage all the building process without an automator. The work is too error prone, expecially because I use FUNC

[7:42:40](#ivVa4Hs1jcTAUr-PRJrG_UBGIvvjvj1OWtKu2m4mKC4) <greggirwin (Gregg Irwin)>:
Anxious to see it. 

## 7-Jan-2025

[21:51:24](#LfohT2zt52LviAO0LhqgxnVBnC0107b9HHRUCoQ01i8) <GiuseppeChillemi (GiuseppeChillemi)>:
Remember: specs-block must be deep copied before parsing it!

```
>> help find
USAGE:
     FIND argument argument refinement refinement refinement refinement refinement refinement refinement refinement refinement refinement refinement refinement refinement refinement

DESCRIPTION: 
     FIND is an action! value.

ARGUMENTS:
     argument     [series! bitset! typeset! port! map! none!] 
     argument     [any-type!] 
     refinement    
     refinement   [number! series!] 
     refinement    
     refinement    
     refinement    
     refinement    
     refinement    
     refinement   [string!] 
     refinement    
     refinement   [integer!] 
     refinement    
     refinement    
     refinement    
     refinement    
```

[22:24:51](#GxeKf-XnH2Fylw8ISbBzbQZt7h-3JFB3TICJlKkyWek) <greggirwin (Gregg Irwin)>:
In your version, right, because you modify it?

[22:43:01](#3Fme3IDUkcm6ojHwSX2gfo1fW06OsE8zqLnOMoyhBUg) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes!

[22:44:49](#rs_d9EloTQet_rtkxYE1K2NaU5PYwlt0QM_H1VaBWX8) <GiuseppeChillemi (GiuseppeChillemi)>:
But I don't understand how it is happening. 

[22:46:16](#crN8NNUdnYSvMVtskSxWqAZnolturAZrcNKGacBqNXo) <GiuseppeChillemi (GiuseppeChillemi)>:
I use PARSE with REMOVE and change... I am investigating. It should be a really stupid mistake

[22:48:18](#fG7h1GM5gZMikls-v1fB7fjnloZBDfQ96H6jmAosIxc) <GiuseppeChillemi (GiuseppeChillemi)>:
I think it is the cause:

```
>change set refinement refinement!
```

I thought I could mix `change` and `set` in an unique command. Do you know if it is possible?

[22:48:30](#mqR2JAnnMuDrhXZDqJgpHUSTOED6o6p_QtsrM4Fw1FQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* I think it is the cause:

```
>change set refinement refinement!
```

I thought I could mix `change` and `set` in an unique rule. Do you know if it is possible?

[22:52:07](#xXgp6AU4csEOfbn6MkYhQLOf3BEYepQhsGAxamtYpBg) <GiuseppeChillemi (GiuseppeChillemi)>:
Also, it is change on the specs block which just is... a block! So removing a string does not generate error.

[23:37:09](#rSEqYFkxZF6-tLVPQsGoVBFNw7ZXAvKtywt88D_yKTQ) <greggirwin (Gregg Irwin)>:
Anytime you modify the input `parse` is processing, you run this risk. What I often do is print the input to the console with a parse action, so you can see where in the input you really are, not where you think you are.

[23:39:37](#GE-axzcYbllGanK_kvyamQaY5PtyCnN04q6VMcVcNzM) <greggirwin (Gregg Irwin)>:
If `refinement` is your rule, also look at that. I've never used `change set ...` that I recall. 

## 8-Jan-2025

[0:27:58](#OjALyPrTSRjYBOgEgtY2YVq6wffP0UFsc0_LY4FN9q0) <GiuseppeChillemi (GiuseppeChillemi)>:
I do the same, I print the position when I need to debug it. This is very effective. Also when parse returns FALSE, I check the rule filing puttin a canary in the rules. If the canary tweets, I move it until there is no more output, so I understand which rule is failing!

[0:28:28](#rcKrzgvsqpuGupUBdBVB2qHu3vmpknLqh3p09-KctXM) <GiuseppeChillemi (GiuseppeChillemi)>:
(please, don't tell this to the WWF!)

[0:28:48](#2NJowCvYZK7gZnFr9AvZbeBJCaDqQwI5O-L7XwURohs) <GiuseppeChillemi (GiuseppeChillemi)>:
* I do the same, I print the position when I need to debug it. This is very effective. Also when parse returns FALSE, I check the rule filing puttin a canary in the rules. If the canary tweets, I move it until there are no more tweets, so I understand which rule is failing!

[0:33:00](#XFBELbtVsvRIcMNNKoIdXDoVo7afILlyLkSj_BPom_8) <GiuseppeChillemi (GiuseppeChillemi)>:
* I do the same, I print the position when I need to debug a long rule. This is very effective. Also when parse returns FALSE, I check the rule filing puttin a canary in the rules. If the canary tweets, I move it until there are no more tweets, so I understand which rule is failing!

[0:34:27](#XdRDyBbyzZDJbBUG4lbtInRRsHC888dZ9eKhWTCzC-w) <GiuseppeChillemi (GiuseppeChillemi)>:
* I do the same, I print the position when I need to debug a long rule. This is very effective. Also when parse returns FALSE, I check what is failing puttin a canary in the rules. If the canary tweets, I move it until there are no more tweets, and then again searching where it tweets, and again where the are no tweets, so I understand which rule is failing and where!

[0:35:02](#G79mr-C4vUVSmkcCama2Ikv3IJpFQTfnW68xjiNK5iM) <GiuseppeChillemi (GiuseppeChillemi)>:
* I do the same, I print the position when I need to debug a long rule. This is very effective. Also when parse returns FALSE, I check what is failing puttin a canary in the rules. If the canary tweets, I move it until there are no more tweets, and then again searching where it tweets, and again where there are no tweets, so I understand which rule is failing and where!

[22:01:08](#NyuhLbtQZ4jmpIfpGzbRLjXjIXnBrt1uW4W3anVI5Lg) <greggirwin (Gregg Irwin)>:
I use the alphabet quite often when debuggin, so I know how far I get.

## 9-Jan-2025

[10:47:08](#50iMK13-IwZPUVOJ4ve6-cDvyBz487t7dAbquWWEu7o) <hiiamboris>:
I've added reflection support to my [`classy-object`](https://codeberg.org/hiiamboris/red-common/src/branch/master/classy-object.red). I mainly intend to use it to better document various parts of Spaces, to help developers learn it. So its primary feature is *docstrings* ;) Similarly to what we have in function specs.

Since I find both `?` and `??` useful on objects, I hijacked `source` for this job. Example output:
```
>> source spaces/focus
SPACES/FOCUS is an object of class 'unnamed-classy-object-2':

  Keyboard focus management.

''FIELD'''''''  DESCRIPTION''''''''''''''''''''''''''''''''''''''''''''''''''''''''  EQ  TYPES''''''''''  ON-CHANGE'''''''''''''''''''''''''''''''''''''''''''''''''''''
  current:      Current keyboard focus target (face or space object)                     [object! none!]  func [obj word new old [any-type!]][focus/move-focus :old new]
  history:      Values previously assigned to /current (used for focus restoration)      [block!]

''FUNCTION''''  DESCRIPTION'''''''''''''''''''''''''''''''''''''''''''''  ARGS''''''''''''''''''''''''''''''''''''''''''
  move-focus:   (internal) Called when the keyboard focus moves           old [object! none! unset!] new [object! none!]
  focus-space:  Put keyboard focus on a SPACE                             space [object!]
  focused?:     Test if SPACE has keyboard focus                          space [object!]
  restore:      Put keyboard focus to the last target that is still live

''CONTEXT'''''  DESCRIPTION''''''''''''''''''''''''''''''''''''''''''''''''''''''  WORDS'''''''''''''''''''''''''''''''''''''''''''''''''''
  tracking:     Kludges that help Spaces track what the currently focused face is  focus-tracker focus-down-tracker set-focus focus-on-face

>> source spaces/events
SPACES/EVENTS is an object of class 'unnamed-classy-object-9':

  Events management.

''FIELD'''''''''''  DESCRIPTION'''''''''''''''''''''''''''''  EQ  TYPES'  ON-CHANGE
  sheets:           Tree of original event handling sheets        [map!]
  handlers:         Tree of compiled event handling matrices      [map!]

''FUNCTION''''''''  DESCRIPTION''''''''''''''''''''''''''  ARGS''''''''''
  define-handlers:  Define event handlers using Event DSL  sheet [block!]

''CONTEXT'''''''''  DESCRIPTION'''''''''''''''''''''''''''''''''''  WORDS'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
  support:          Reference data and support functions            event-types pointer-event-types event-flags is-pointer-event? is-va...
  encoding:         Encoding of events into unique ids for lookups  encode-type encode-flag encode-flags encode-event list-ids
  dialect:          Support for `define-handlers` dialect           grammars decode-mask split-sheet compile-handler compile-sheet
  storage:          events/handlers matrix: storage and lookups     fetch-handlers store-handlers find-handlers store-sheet fetch-sheet ..
  processing:       The core of events processing                   pipeline previewers finalizers dispatch prepare-event fill-args lis...
  commands:         Commands accessible from event handlers code    sink bubble stop
```
What do you think?

[13:14:27](#TCv9N9eNKyVzgvb4IfiiDIAOZu_dld4vGObDsmROM30) <GiuseppeChillemi (GiuseppeChillemi)>:
I have seen the example on a simple object. I takes the head string and arg strings for each args. Also it seems to inspect the body of the function for other objects, doen't it?

[13:14:36](#8D2F8jgTClRmO9bNjEa5VH9BrtLl8gS9pSF8EYc7fPw) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have seen the example on a simple object. I takes the head string and arg strings for each args. Also it seems to inspect the body of the function for other objects, doens't it?

[13:16:20](#zEXbQS8jJof6jJtqhJ1sZAlm61NawBi0PIfTnTDknG8) <GiuseppeChillemi (GiuseppeChillemi)>:
Personally I like it. In my approach I will be putting extra data inside a block in the head of the body. But you can also a string for extended documentation instead of using comments as we actually do. 

[13:16:46](#ZVRwJ0uOLt7uYcRycNR9cqQWgCQ84KRl8l5LHQ3kzdw) <GiuseppeChillemi (GiuseppeChillemi)>:
* Personally I like it. In my approach I will be putting extra data inside a block in the head of the body. But you can also a string for extended documentation instead of using comments as we actually do, so the comment is also documentation you can access via command line or even code.

[13:17:27](#pfBymc_9eW4SA6XThRAZ6ECgfVz3EkB-YZay8QRv7qo) <GiuseppeChillemi (GiuseppeChillemi)>:
* Personally I like it. In my approach I will be putting extra data inside a block in the head of the function body or `on-change*`. But you can also a string for extended documentation instead of using comments as we actually do, so the comment is also documentation you can access via command line or even code.

[13:18:16](#4tZyLoIFdsS-vHpXl5GXKxDZrYIBQYHCHKaXwjxcLYs) <GiuseppeChillemi (GiuseppeChillemi)>:
* Personally I like it. In my approach I will be putting extra data inside a block in the head of the function body or `on-change*`. But you can also use a string in the head for extended documentation instead of using comments as we actually do, so the comment is also documentation you can access via command line or even code.

[13:25:01](#vv05dAk4RlydTIDqDZ_4d71HpwIKyQKFpPxm5xDkTPw) <hiiamboris>:
Yeah comments are one of the things I'm simply rewriting into strings, and planning to try to use that info for the refererence docs later.

[13:33:32](#42NfqVVUwqJojzjT65jkJDnAohO_h38xCCITGW62m60) <hiiamboris>:
Body of the function is not inspected at all, no.

[13:33:46](#gCUXZKlXaby-iWyb883bmjzsLhCZ_2hsDWnp2ROyP9c) <GiuseppeChillemi (GiuseppeChillemi)>:
This has all started when I realized that Redbol languages simply skips strings, refinements, blocks and other datatypes during runtime if they are not eaten by a function arg. So you can creatively use them for documentation, tagging, extra data...

[13:37:34](#308eU-VcPmY--ZAQfeGJvbIQhZiKR3xUEA2SVRsG3p4) <GiuseppeChillemi (GiuseppeChillemi)>:
Also `comment "doc"` could be a valid solution.

[13:37:53](#_hI6hgNWAr1RbrLCVGOkAwQo__dt3JgAW5MYMSOz354) <GiuseppeChillemi (GiuseppeChillemi)>:
* Also `comment "doc"` could be a valid solution. You search for this word and put everything there.

[13:38:29](#SXv702QCZeUOLtyQVrnpFGocG3q4V6Zqs4sukW7Zat0) <GiuseppeChillemi (GiuseppeChillemi)>:
* Also `comment "doc"` or `comment []`could be a valid solution. You search for this word and put everything there.

[13:43:24](#Jr_6TpmP9CWPIgBCIRVzfEJ5H6uwcn8t0CkbmCm_U8E) <hiiamboris>:
I was thinking of `#doc` marker, but don't want too many markers around as all this metadata already makes the code overly dense.

[13:49:36](#p8reqz-wbxHCJYLzCisr-c3hsqyKhZGBiYQflKVUi78) <GiuseppeChillemi (GiuseppeChillemi)>:
So, where do you take the CONTEXT part?

[13:55:46](#mJZy3227bytTBn3mVWRackB-9UPmi-t18dDZPR4BKN4) <hiiamboris>:
It's the objects in the inspected object.

[13:58:52](#2G6Wd_1hpYm3m_7e2meMlO_8tjKMD0ykYI32SQr2zCk) <GiuseppeChillemi (GiuseppeChillemi)>:
Ok, I had in mind my function approach. But do you inspect the proto or store docs in `on-change*`?

[13:59:08](#D7t_z1VqQSYcJdUktAWwuxOpsPn4zR0Z6tAMCrwS7KQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* Ok, I had in mind my function approach. But for object description do you inspect the proto or store docs in `on-change*`?

[13:59:21](#IV_94aPVex2oY5fGEr1iIS04TsTDzQLvZOKYq1Q9wk4) <GiuseppeChillemi (GiuseppeChillemi)>:
* Ok, I had in mind my function approach. But for theobject description do you inspect the proto or store docs in `on-change*`?

[13:59:26](#D7SqK3so0xTa2KSxUONMuVVmW710LiueuoP4sLnIOiY) <GiuseppeChillemi (GiuseppeChillemi)>:
* Ok, I had in mind my function approach. But for the object description do you inspect the proto or store docs in `on-change*`?

[14:00:55](#C9yU6RyKO5DqfquzqNU1Ui_2Oyu1PXBEQSIrzWp4VN0) <hiiamboris>:
I store all class info in the `classes` map.

[17:20:51](#qe_oAjKdf_07np-tyBeqkKsfJgYQxlHu_DfhtwzM_ro) <GiuseppeChillemi (GiuseppeChillemi)>:
Have you seen the output of my `func-ctx` code? It adds sections dividers like your:

```
'FIELD'''''''  DESCRIPTION''''''''''''''''''''''''''''''''''''''''''''''''''''''''  EQ  TYPES''''''''''  ON-CHANGE'''''''''''''''''''''''''''''''''''''''''''''''''''''
  current:      Current keyboard focus target (face or space object)                     [object! none!]  func [obj word new old [any-type!]][focus/move-focus :old new]
```


[17:21:48](#uUNwyvR9rJn0IvTjql8gALxWMy3a2JNIYnpJOvK_Ly4) <GiuseppeChillemi (GiuseppeChillemi)>:
Code may be dense but you can also divide it so everyone will jump at the end.

[17:23:20](#8XS6CzamrztIau4ZUQVS0bw2PNe9hmBEH8oyKj7739I) <GiuseppeChillemi (GiuseppeChillemi)>:
Another solution is our own "parse" approach: shorten in the output some parts.

[17:23:31](#4-iv2L4r5FKVevBGLmlrzdC73WbWcWeIEtYcTw1YEqI) <GiuseppeChillemi (GiuseppeChillemi)>:
* Another solution is your own "parse" approach: shorten in the output some parts.

[18:06:12](#-gr_gf9qCtTKm4sCkKtgGaC3o2oPd54oDf9QKo-2V9c) <greggirwin (Gregg Irwin)>:
I've also done some thinking about how to include more reflective information in code, but have to think about this output format. The tick-mark seps seem very noisy to me, visually, but the main thing is how much data you can effectively use in a console, and how to format it. e.g. the words section is very dense. For a long time I've leaned toward tooling as the way forward, with some additions for basic envs like consoles. Then it's figuring out what metadata helps tools.

[18:20:19](#n5l6hLCgSfFjOmrs7YQCltjY3UgQ87aCdUQlIRTDPDE) <GiuseppeChillemi (GiuseppeChillemi)>:
In the mean time I have completed a second function specs parser. It outputs into a MAP! the structure of the specs, so you can easily access it with normal path notation:



[18:20:55](#8qUeSdaHSaPP_7FIounRwj-I8aOK34INlPwYsMEXATc) <GiuseppeChillemi (GiuseppeChillemi)>:
This is the output of `SET`

```
#[
    fdescription: "Sets the value(s) one or more words refer to"
    returns: none
    flags: []
    words: [word #[
        function-name: set
        arg: word
        datatypes: [any-word! block! object! any-path!]
        description: "Word, object, map path or block of words to set"
        fdescritpion: none
        element-type: argument
        ordinal: 1
    ] value #[
        function-name: set
        arg: value
        datatypes: [any-type!]
        description: "Value or block of values to assign to words"
        fdescritpion: none
        element-type: argument
        ordinal: 2
    ] any #[
        function-name: set
        arg: any
        datatypes: [logic!]
        description: {Allow UNSET as a value rather than causing an error}
        fdescritpion: none
        element-type: refinement
        ordinal: 3
    ] case #[
        function-name: set
        arg: case
        datatypes: [logic!]
        description: "Use case-sensitive comparison (path only)"
        fdescritpion: none
        element-type: refinement
        ordinal: 4
    ] only #[
        function-name: set
        arg: only
        datatypes: [logic!]
        description: {Block or object value argument is set as a single value}
        fdescritpion: none
        element-type: refinement
        ordinal: 5
    ] some #[
        function-name: set
        arg: some
        datatypes: [logic!]
        description: {None values in a block or object value argument, are not set}
        fdescritpion: none
        element-type: refinement
        ordinal: 6
    ] return #[
        function-name: set
        arg: return:
        datatypes: [any-type!]
        description: none
        fdescritpion: none
        element-type: refinement
        ordinal: 7
    ]]
]
```

[18:22:20](#3905P4uPVDSTxMVHJL_Jt3YgwOpnNtf9KWb9yub-LXI) <GiuseppeChillemi (GiuseppeChillemi)>:
I need to add just 1 field: the type of word: (`get-word!`,`word!`, `lit-word!`)

[18:22:27](#aWtFnGOjdmsvwfdRHEQqzoQBnMV4P-5Et7Xsf9tWA1c) <GiuseppeChillemi (GiuseppeChillemi)>:
* I need to add just 1 field: the type of word: `get-word!`,`word!`, `lit-word!`

[18:23:44](#U0SSDnfVVyfJFAYmYdVDZZypBxzXQScSdpOuDLTOuTI) <GiuseppeChillemi (GiuseppeChillemi)>:


It is made by an external `MAP!` and another connected to `WORDS` which has all words function specs

[18:57:16](#j2GD6v4CTSLfir1CddbQxeR_bhQ9O9f_RPYkV3dYF3Y) <greggirwin (Gregg Irwin)>:
Similar to what `help` does, except that it uses blocks in the output objects, inside param and refinement groupings.

## 10-Jan-2025

[1:15:54](#jT-mTZOxbcVoAVzFuKE4pwoXUOTUZSNOZzOfOUUqYzQ) <GiuseppeChillemi (GiuseppeChillemi)>:
It is needed to do everything someone wants with function specs. Just an example extracting words to create a matrix of checks.

```

target: copy []
foreach [spc] sp [
	foreach [wr specs] spc/words [
		new-line back back insert tail target reduce [wr specs/datatypes] true
	]
]

probe target

[
    word [any-word! block! object! any-path!] 
    value [any-type!] 
    any [logic!] 
    case [logic!] 
    only [logic!] 
    some [logic!] 
    return [any-type!]
]
```

I have built it for my alternative function interface progject, where locals are visible too in the inteface and you can use with apply.

[1:19:37](#8Y1f2ostNaO9mbAUv3eFfL5oQfwYCv3wCqPYIZNVuzg) <GiuseppeChillemi (GiuseppeChillemi)>:
Also I have discovered that REBOL3 is able to use `local` as refinement, so you can do `myfunc/local`. I will be ablet to output either plain interfaces, R3 like or the new type where you can have local refinements to denote group of local words you can init using the interface.

[16:49:48](#ek1ashfabc4oZtwYaesF6CbmYrmQhatSNcqLcdcSjFU) <GiuseppeChillemi (GiuseppeChillemi)>:
I have completed the specs-parser. I have tested it against the whole `system/words` object and none ot the specs failed and was able to test all!
Ì†ºÌΩæÌ†ºÌΩæÌ†ºÌΩæ

[16:55:59](#7NPwkAdJHq_fJqdOsNQSrfjor-swnfRl6Zl-jhkaDso) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have completed the specs parser. I have tested it against the whole `system/words` object and none ot the specs failed and was able to test all!
Ì†ºÌΩæÌ†ºÌΩæÌ†ºÌΩæ

[19:42:31](#0c-0uA3g1HL5SKS1yMTTcJYx5jfxKXahDqW9H5sbfwY) <greggirwin (Gregg Irwin)>:
Nice work!

[22:46:54](#amIHlBNXxkmI824gxj-G4lhP90vXKdcWRlhcWZBxcGI) <GiuseppeChillemi (GiuseppeChillemi)>:
I have another litte gem I have created during the whole afternoon: [leak-check](https://gist.github.com/GiuseppeChillemi/dcc35427e5c64cded2eb7b0998701056)

It is very simple to use. Start with `leak-check/before` than `leak-check/after` after your code to have the difference returned as block. `/stop` and `/report` are useful to stop at difference or report on screen. `/log` let you provide an ID before each on screen report. 

Example:

``` 
;--- Start collecting the system context
  ;
  leak-check/before

  f: func [a] [b: 33 aa: 44]

  f 99

  ;-- Checks skipping word <F>
  ;--   and stopping after a an error is found
  ;
  leak-check/after/stop/skip [f] 

;--- Result:
;--- Skipped: [f] |  Leaks: [b aa]
```
 
`


[22:47:28](#VFJT37UJMYPUUx0bNNxj0mZGUpVgQqafRTFLlOIaULs) <GiuseppeChillemi (GiuseppeChillemi)>:
What about it?

[22:55:07](#pV67Bafg08Y0Z5XscrSrLOWpw2_IdfbTF0L21DN3JvA) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have another litte gem I have created during the whole afternoon: [leak-check](https://gist.github.com/GiuseppeChillemi/dcc35427e5c64cded2eb7b0998701056)

It is very simple to use. Start with `leak-check/before` than `leak-check/after` after your code to have the difference returned as block. `/stop` and `/report` are useful to stop at difference or report on screen. `/log` let you provide an ID before each on screen report.

Example:

```
;--- Start collecting the system context
  ;
  leak-check/before

  f: func [a] [b: 33 aa: 44]

  f 99

  ;-- Checks skipping function word <F>
  ;--   and stopping after a an error is found
  ;
  leak-check/after/stop/skip [f] 

;--- Result:
;--- Skipped: [f] |  Leaks: [b aa]
```

\`

[22:55:22](#gRl_BEu1pswthPOtcyNnsEM3RzYHt_cH1sKI5i6MhaQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have another litte gem I have created during the whole afternoon: [leak-check](https://gist.github.com/GiuseppeChillemi/dcc35427e5c64cded2eb7b0998701056)

It is very simple to use. Start with `leak-check/before` than `leak-check/after` after your code to have the difference returned as block. `/stop` and `/report` are useful to stop at difference or report on screen. `/log` let you provide an ID before each on screen report.

Example:

```
;--- Start collecting the system context
  ;
  leak-check/before

  f: func [a] [b: 33 aa: 44]

  f 99

  ;-- Checks skipping function word <F>
  ;--   and stopping after an error is found
  ;
  leak-check/after/stop/skip [f] 

;--- Result:
;--- Skipped: [f] |  Leaks: [b aa]
```

\`

[23:04:44](#PXrPWmB-oWaSoLp8rRItUJZSivRgx3EPbYfwhysAglU) <greggirwin (Gregg Irwin)>:
It's useful. I have an old R2 version called 'mark-my-words.

[23:28:58](#Lh1QRPOHh-abU7MhyLLnzu1Ke0ZNKtKEDdhdemmPd9c) <GiuseppeChillemi (GiuseppeChillemi)>:
You can put it in multiple places of your code and if it is leaking it will warn or stop. Otherwise will run as before, just a little slower.

[23:31:40](#wa8h85pLJ1WaH1C79O9yFJ8HrwBBXmsvDvugrgDBBok) <GiuseppeChillemi (GiuseppeChillemi)>:
I am thinking about changing the /AFTER refinement into /INIT and removing /BEFORE, so each run of LEAK-CHECK will just make its controls. 

## 11-Jan-2025

[3:12:13](#6l4CBI8kBIzy6KN_UlvW6YTHaVl2oRivDIzWEILU3EE) <GiuseppeChillemi (GiuseppeChillemi)>:
I have modified it: now `/before` has become `/init` and at each run you get the leaked words without need of any refinement. `/log` is not `/id` so this former word is reserved when logging will be available.


[4:22:27](#vIM-cjFS08LhskWivJntie9oB8p3pRCqrC98XYzc91o) <GiuseppeChillemi (GiuseppeChillemi)>:
Deep night here but I was full immersion in the creativity tunnel. Now [leak-check](https://gist.github.com/GiuseppeChillemi/dcc35427e5c64cded2eb7b0998701056) accepts block of code or a `%file` for testing.

[4:24:42](#He61ZxbD2SdInF7AX3EwbaMVj_jndgeQA0rM7gB7E7g) <GiuseppeChillemi (GiuseppeChillemi)>:
This will let you test your code one file each time. It should only contain an `#assert [code]` to run the code inside and see if it leaks 

[4:54:19](#7tC3rhnbfpO0t6bbPN16iHpngEKdbrB77JvpnNiycXU) <GiuseppeChillemi (GiuseppeChillemi)>:
* Deep night here but I was full immersion in the creativity tunnel. Now [leak-check](https://gist.github.com/GiuseppeChillemi/dcc35427e5c64cded2eb7b0998701056) accepts block of code or a `%file` for testing.
It also allows `/TEST`ing you code against a test file. Just run pass your code and a test one (it could be a file) 

[5:16:58](#RwW0jnWLuo0N5OP64ulMjwzUx9HJpZ46-cK7LJFxiXc) <GiuseppeChillemi (GiuseppeChillemi)>:
* Deep night here but I was full immersion in the creativity tunnel. Now 
leak-check accepts block of code or a %file for testing.
It also allows /TESTing you code against a test file. Just pass your code and a test one (it could be a file)
note: /attempt mode still not implemented

[9:32:39](#AXf89pGDzqm0javgzOaQhZvpcf2h7J5ynneJQrodWmA) <hiiamboris>:
https://codeberg.org/hiiamboris/red-common/src/branch/master/leak-check.red ‚òª

[10:35:44](#H_XoBhjFQmTQHU-GjEN1hKK5SorSld7Ek0uDnunU5i0) <GiuseppeChillemi (GiuseppeChillemi)>:
Ì†æÌ¥£Ì†æÌ¥£Ì†æÌ¥£

[13:26:42](#06YC1hm01WXUlMj-ma2iVaZ-nTQZiQAMOxH-mZvhFQ4) <GiuseppeChillemi (GiuseppeChillemi)>:
hiiamboris: Now it is important to creata a "Boris Dupe Check", to prevent this from happening.

[13:47:20](#Bnt6PPBBka389CD6hOIATpzCEgLkIVUEvqzRx0T-gJI) <GiuseppeChillemi (GiuseppeChillemi)>:
* hiiamboris: Now it is important to creat a "Boris Dupe Check", to prevent this from happening.

[13:47:27](#YVtTgLFrqXSpPaWF7pTPs05DkMXTwY7UQAGV1t0JRL0) <GiuseppeChillemi (GiuseppeChillemi)>:
* hiiamboris: Now it is important to create a "Boris Dupe Check", to prevent this from happening.

[16:00:20](#LU_Qifa_xVl3_vnALX_VTl1PbsnbUOP1eu_RYcRI6vE) <GiuseppeChillemi (GiuseppeChillemi)>:
I think I can optimize it in the future, but know it is important to have it working. I have implemented better output strings and `attempt` to warn when a code or test fails. Now lets face the week with... `query-specs`

## 12-Jan-2025

[13:43:40](#mNNkWSSB0oMXnobE3A-DXI-1KJN8G0N5iTlTgn6Tvag) <GiuseppeChillemi (GiuseppeChillemi)>:
I have a function that repeats ANY command over multiple targets, it is the magic of `apply`.
```
repeat-on: func [
	"Repeats a command on a target container"
	target [integer!] "The arg position to repeat the function on"
	command [block!] "A code block which starts with the command"
	/local
	targets
	command*
	command-arguments
] [

	command*: first command
	command-arguments: next command
	targets: first at command-arguments target
	
	
	forall targets [
		change/only command-arguments targets/1
		apply command* command-arguments
		;probe command;<<--- Uncomment this to debug
	]
	
]

repeat-on 1 [append [a b] "hi"]
probe reduce [a b]
```
Result:
```
[["hi"] ["hi"]]
```

[13:53:03](#-w1aR0jAtF94y-rETsgzPtWJv_636GTkyqu-1iEppJE) <GiuseppeChillemi (GiuseppeChillemi)>:
(In the future I will modify it to be used with OP too)

[17:00:16](#N_i1Jnp0fUnDqJRQyZHjmt_8ld81oq7F66a1OmpOE0A) <hiiamboris>:
looks like a more esotetic version of:
`foreach c reduce [a b] [append c "hi"]`

[17:04:18](#42JM9tiQEGWi9KgvYnCZm_eIlMRSVDhqNWCwDlrqpyA) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes, I am experimenting poking the command block instead of using standard loops.

[23:59:41](#lcpE3mVEtdaJni5k8KdUGYce3PFt3NOgCyVAip4hnRM) <GiuseppeChillemi (GiuseppeChillemi)>:
```
a: copy []
b: copy []
probe dt [loop 1000000 [repeat-on 1 copy/deep [append [a b] "hi"]]]

a: copy []
b: copy []

probe dt [
	loop 1000000 [
		targets: [a b]
		foreach t targets [
			do copy/deep [append get t "hi"]
		]
	]
]
```

## 13-Jan-2025

[0:01:01](#HTroIMIFCrPYUwH8VOagvGLZoCXB4MWyyZ999or5XPs) <GiuseppeChillemi (GiuseppeChillemi)>:
Results:
```
repeat-on: 0:00:06.39842
foreach: 0:00:08.19932
```

[0:04:12](#QtY-9wAWmZzjFetk6dYlKt6xNqMZiX2TCa0Uajfeq-g) <GiuseppeChillemi (GiuseppeChillemi)>:
No

[0:04:19](#Q9qiF3d1BC2qakRPlGpTjFL0qq63xEmLZ1wwBrprnfQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Your version is faster:

[0:04:41](#atEY2pOed4S_Z8KMugYZYchVUpLTgcKswsb8Cf46Ghk) <GiuseppeChillemi (GiuseppeChillemi)>:
```
probe dt [
	loop 1000000 [
		foreach c reduce [a b] [append c "hi"]
	]
]

probe length? a
```
Result:
```
0:00:01.84177
```


[0:06:21](#8IG6WLftzX-u16MrRu3gWNgSs8uB5XHNKu48UcfQDXQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Even with the `copy/deep` hurdle you don't go past 4,6 seconds (I have had to use it because `repeat-on` changes the code block)

[0:07:15](#omt83D8F3gNY15b6VmcRwRtZvOR1ooTrNyWUqcWoKCM) <GiuseppeChillemi (GiuseppeChillemi)>:
I have on screen the message:

"Repeat-on failed successfully"

[0:07:33](#0Jn22ELBR75UkYbH2mPQRzN_m1blWusGD6lRqSCAPnQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have on screen the message:

`Repeat-on failed successfully`

## 14-Jan-2025

[1:15:45](#30XAUlbmgCdB7kjVxYHUXBwOR9yyZPCE4hwXet5AsWo) <GiuseppeChillemi (GiuseppeChillemi)>:
I have made 3 interpreters of  function specs interfaces in a week. Once you understand the tecnique, you never stop playing.
Some refinement and the idea I had more than 3 years ago could come to life. 

[1:16:02](#IWUUgMdiazAhFjEtGIgpHaTwbh7hFgI64spUigb2_EE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have made 3 interpreters of  function specs interfaces in a week. Once you understand the tecnique, you never stop playing.
Some refinements and the idea I had more than 3 years ago could come to life. 

[1:31:29](#lcyGJN8q0m0NQ9xfcTDu8u0TudCWc_-zPKRT6HulsaM) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have made 3 interpreters of  function specs in a week. Once you understand the tecnique, you never stop playing.
Some refinements and the idea I had more than 3 years ago could come to life. 

## 15-Jan-2025

[6:01:37](#abP11mX_10TvOI1c89OrKP13886rvwESsOvprujYyq4) <greggirwin (Gregg Irwin)>:
It's the same for me. :^)

[18:44:59](#8933BqqcuwjZe9q6B1yEWMEcd1uA0b69XMtlhvrDJo0) <GiuseppeChillemi (GiuseppeChillemi)>:
Small experiments

[18:45:11](#P2OADMrOFMS05kjH4NHQ9ufyomGeDzYaBOvzKK6lv9c) <GiuseppeChillemi (GiuseppeChillemi)>:
![https://gitter.ems.host/_matrix/media/v3/download/gitter.im/d27256538b145923a2f418b897158cf1a2fa41e31879600733548969984](https://gitter.ems.host/_matrix/media/v3/download/gitter.im/2ef3a26fd46cb9e44fce7b59c7afbff2e4ea0c901879600735033753600)

## 16-Jan-2025

[22:01:26](#mGiWPS3Sn0X9MSMCy6q4odYv-4iXTYC5Ccc1746_Fe8) <GiuseppeChillemi (GiuseppeChillemi)>:
Things you don't know:
```
>> get make object! [a: 22 b: 33]
== [22 33]
```
Are there any differences with `values-of`?

[22:07:21](#Xcu5bNmpx9kFLY2zi2lRhzELNsMKZ2dBOXHY9KWRTg8) <greggirwin (Gregg Irwin)>:
No. In the current implementation `get` uses `reflect` on objects, just like `values-of` so it's exactly the same.

## 17-Jan-2025

[23:10:13](#OWh3dd4zQubDcFytYvsAk6Yf_YnN2QhqGkdOcLPqx8Y) <GiuseppeChillemi (GiuseppeChillemi)>:
Do you think that it would be possible supporting this?

```
>> set/any 'aaaa ()
>> unset? aaaa
```

I mean testing with `unset?` without using `unset? get/any 'aaaa`

[23:11:36](#7txOWKIII2lAkmNsZjKAqrpCQ0O6C1D9JRahIpAOjVA) <GiuseppeChillemi (GiuseppeChillemi)>:
We would save one step when working with elements that could be `unset!`

[23:11:54](#ZAMzqOIKI5isBkoapLlH12vvB5H3mbWZvitw2ugsRE4) <GiuseppeChillemi (GiuseppeChillemi)>:
* We would save one step when working with elements that could have `unset!` value

[23:36:07](#4eJZALPpxG0Vez26n932FnxR3wzgl61nPWWWluxejFU) <greggirwin (Gregg Irwin)>:
Use `value? 'aaaa`.

## 18-Jan-2025

[0:02:31](#5EAqSrk0GEsAS4veD3zVyoeVQ-z_1ZALEdFh_4S7I5E) <GiuseppeChillemi (GiuseppeChillemi)>:
Great!

[0:03:00](#e2V_UFJ6LXfgRBPxRXYTPyF-HXxuvooNDI5M7xhMwy8) <GiuseppeChillemi (GiuseppeChillemi)>:
I like to find something I need already implemented

[0:03:22](#-1YAyx1Dsrvz2KY_y3jULRINQplbP35DBK6MDVKUmvw) <greggirwin (Gregg Irwin)>:
Me too. :^)

[5:43:53](#m9ZMDnfX3-AYfyJB0lU6H-Q12GS6maByRTzoj3dwzW4) <hiiamboris>:
`unset? :aaaa`

## 19-Jan-2025

[0:54:14](#M-TrxNxzfnmeuYvjzXYcxtkbZtTLeKPALlsNUFceP6A) <GiuseppeChillemi (GiuseppeChillemi)>:
So you have a map with CLASS-IDs?

[5:31:37](#h02FTYTSheGAoweM81a-DNGSYVnW8377Xh2q1Hk-ADQ) <hiiamboris>:
I am using class names as keys

## 25-Jan-2025

[1:04:56](#7dMC0T6voVDwdrQrSOU3qNZ_WghleOsM55veRrsL30c) <GiuseppeChillemi (GiuseppeChillemi)>:
How many times do you use the following checks?

```
a: "Hello"
either string? a [if find a "he" [Print "Found He"!]] [do make error! ....]
```
I have always tought it would be nice to have a shorter version. So I have made a pass-though checker creator to use this kind of code:

```
if find string?? a "he" [Print "Found he!"]
```
Where
`String??` fires an error or passes the value to the function which needs it.

It is simple as 1 + 1:

```
make-checker 'string?? [string!]
```
The source is here:

```

make-checker: func [
	"Create a pass throught checker"
	name [word!] "The name of the checker"
	checks [block! datatype!] "The datatype to test for"
] [
	;TBD: function
	checks: blockify checks
	either error? try [
		checks: make typeset! checks] [do make error! "Error in datatypes block"
	] [
		set name func [
			data [any-type!]
		]	compose/deep [
			either find (checks) type? :data [:data] [do make error! rejoin [lf "--->   Value: " :data lf "--->   check: " (to-string name) lf "---> Waiting: " to-block (checks) lf "--->   found: " mold type? :data]]
		]
	]	
]
```


[1:06:24](#QWxetZJgfr1qLyqgNzYo64uuYrwvxJlO1VEmwtS-ZLo) <GiuseppeChillemi (GiuseppeChillemi)>:
* How many times do you use the following checks?

```
a: "Hello"
either string? a [if find a "he" [Print "Found He"!]] [do make error! ....]
```

I have always tought it would be nice to have a shorter version. So I have made a pass-though checker creator to use this kind of code:

```
if find string?? a "he" [Print "Found he!"]
```

Where
`String??` fires an error or passes the value to the function which needs it.

It is simple as 1 + 1:

```
make-checker 'string?? [string!]
```

The source is here:

```

make-checker: func [
	"Create a pass throught checker"
	name [word!] "The name of the checker"
	checks [block! datatype!] "The datatype to test for"
] [
	;TBD: function
	checks: to block! checks
	either error? try [
		checks: make typeset! checks] [do make error! "Error in datatypes block"
	] [
		set name func [
			data [any-type!]
		]	compose/deep [
			either find (checks) type? :data [:data] [do make error! rejoin [lf "--->   Value: " :data lf "--->   check: " (to-string name) lf "---> Waiting: " to-block (checks) lf "--->   found: " mold type? :data]]
		]
	]	
]
```

[1:08:19](#ToQdum5Q0YRe02swUJmcROpM07egW6vZSmGPQASv02w) <GiuseppeChillemi (GiuseppeChillemi)>:
Other examples:
```
make-checker 'int-str?? [integer! string!]
probe int-str?? 1
1

probe int-str?? "a"
"a"

make-checker 'integer?? [integer!]
probe integer?? 1
1

probe integer?? 'a

*** User Error: 
--->   Value: a
--->   check: integer??
---> Waiting: integer!
--->   found: word!
*** Where: do
*** Near : do make error! rejoin [lf "--->   Value: "]
*** Stack: do-file probe integer??
*** Files: %"/G/....r"
```

[1:08:52](#YCtksuuPH6102M6xc1yyz0beMjzK29MXDzv6OKtkQbM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Other examples:

```
make-checker 'int-str?? [integer! string!]
probe int-str?? 1
1

probe int-str?? "a"
"a"

make-checker 'integer?? [integer!]
probe integer?? 1
1
```

[1:09:06](#iLR6Jc1bx-QJIQOJTaSUskGCdli58yXWrH4p0jEgIgU) <GiuseppeChillemi (GiuseppeChillemi)>:
As you can see, values are passed transparently

[1:09:32](#JQVNFOUojaQ3WJtFyvmDwWpNJU3kAL0JXtoanq_qJEM) <GiuseppeChillemi (GiuseppeChillemi)>:
But if you pass the wrong value:

```
probe integer?? 'a

*** User Error: 
--->   Value: a
--->   check: integer??
---> Waiting: integer!
--->   found: word!
*** Where: do
*** Near : do make error! rejoin [lf "--->   Value: "]
*** Stack: do-file probe integer??
*** Files: %"/G/....r"
```

[1:10:33](#Rq1PMoofnGJwyIxN4--IQEmx_Md_FLG297rwKLmWdQw) <GiuseppeChillemi (GiuseppeChillemi)>:
(Just need to change `make error` to `cause-error`)

[1:15:00](#DnDnXBj-pKiTOHIvEO37wtwfBddK8koUnP9S19kaIyA) <GiuseppeChillemi (GiuseppeChillemi)>:
* How many times do you use the following checks?

```
a: "Hello"
either string? a [if find a "he" [Print "Found He"!]] [do make error! ....]
```

I have always thought it would be nice to have a shorter version. So I have made a pass-though checker creator to use this kind of code:

```
if find string?? a "he" [Print "Found he!"]
```

Where
`String??` fires an error or passes the value to the function which needs it.

It is simple as 1 + 1:

```
make-checker 'string?? [string!]
```

The source is here:

```

make-checker: func [
	"Create a pass throught checker"
	name [word!] "The name of the checker"
	checks [block! datatype!] "The datatype to test for"
] [
	;TBD: function
	checks: to block! checks
	either error? try [
		checks: make typeset! checks] [do make error! "Error in datatypes block"
	] [
		set name func [
			data [any-type!]
		]	compose/deep [
			either find (checks) type? :data [:data] [do make error! rejoin [lf "--->   Value: " :data lf "--->   check: " (to-string name) lf "---> Waiting: " to-block (checks) lf "--->   found: " mold type? :data]]
		]
	]	
]
```

[1:17:01](#Ny3hhugn-mp0-p-JJIHLvF5ni2BI5RBsN3gFjlZeMW4) <GiuseppeChillemi (GiuseppeChillemi)>:
* (Just need to change `make error!` to `cause-error`)

[1:28:20](#zuQiviXyCE42JzVLKnKA7LFWngzCxPILMFDE1bznyFg) <GiuseppeChillemi (GiuseppeChillemi)>:
* How many times do you use the following kind checks?

```
a: "Hello"
either string? a [if find a "he" [Print "Found He"!]] [do make error! ....]
```

I have always thought it would be nice to have a shorter version. So I have made a pass-though checker creator to use this kind of code:

```
if find string?? a "he" [Print "Found he!"]
```

Where
`String??` fires an error or passes the value to the function which needs it.

It is simple as 1 + 1:

```
make-checker 'string?? [string!]
```

The source is here:

```

make-checker: func [
	"Create a pass throught checker"
	name [word!] "The name of the checker"
	checks [block! datatype!] "The datatype to test for"
] [
	;TBD: function
	checks: to block! checks
	either error? try [
		checks: make typeset! checks] [do make error! "Error in datatypes block"
	] [
		set name func [
			data [any-type!]
		]	compose/deep [
			either find (checks) type? :data [:data] [do make error! rejoin [lf "--->   Value: " :data lf "--->   check: " (to-string name) lf "---> Waiting: " to-block (checks) lf "--->   found: " mold type? :data]]
		]
	]	
]
```

[1:28:27](#7Z2SrB6EHFNdlkMz9FHwS0UeyUgZF-E5JPUvVrmxmrQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* How many times do you use the following kind of checks?

```
a: "Hello"
either string? a [if find a "he" [Print "Found He"!]] [do make error! ....]
```

I have always thought it would be nice to have a shorter version. So I have made a pass-though checker creator to use this kind of code:

```
if find string?? a "he" [Print "Found he!"]
```

Where
`String??` fires an error or passes the value to the function which needs it.

It is simple as 1 + 1:

```
make-checker 'string?? [string!]
```

The source is here:

```

make-checker: func [
	"Create a pass throught checker"
	name [word!] "The name of the checker"
	checks [block! datatype!] "The datatype to test for"
] [
	;TBD: function
	checks: to block! checks
	either error? try [
		checks: make typeset! checks] [do make error! "Error in datatypes block"
	] [
		set name func [
			data [any-type!]
		]	compose/deep [
			either find (checks) type? :data [:data] [do make error! rejoin [lf "--->   Value: " :data lf "--->   check: " (to-string name) lf "---> Waiting: " to-block (checks) lf "--->   found: " mold type? :data]]
		]
	]	
]
```

[1:29:03](#S6bXNEvChpg8g0pJkuqtwx0Ebp67ifjhYdUJ97SdRfY) <GiuseppeChillemi (GiuseppeChillemi)>:
* Other examples: You can do MULTI CHECKS!!!

```
make-checker 'int-str?? [integer! string!]
probe int-str?? 1
1

probe int-str?? "a"
"a"

make-checker 'integer?? [integer!]
probe integer?? 1
1
```

[1:36:43](#pKByW85KJVT_2Anl8eWJAOSSamiOK8ZwmHZV2F5Vlc0) <greggirwin (Gregg Irwin)>:
Yes. Many helpers like this through the years.

[1:43:07](#t_UghNV0edwcD2YDzHq-1tRR1cNOOQfCSiprdKw6ieI) <GiuseppeChillemi (GiuseppeChillemi)>:
Here is how to create one for all datatypes:

```
create-checkers: function [] [
	t: to-block any-type! 
	forall t [
		make-checker to-word head change back tail to string! t/1 "??" reduce t/1
	]
]

create-checkers
```

[1:53:09](#HPVbjijSID8vtGHgC7fIVlFTsMX6QPy5Asvnftf0wqA) <GiuseppeChillemi (GiuseppeChillemi)>:
* How many times do you use the following kind of checks?

```
a: "Hello"
either string? a [if find a "he" [Print "Found He"!]] [do make error! ....]
```

I have always thought it would be nice to have a shorter version. So I have made a pass-though checker creator to use this kind of code:

```
if find string?? a "he" [Print "Found he!"]
```

Where
`String??` fires an error or passes the value to the function which needs it.

It is simple as 1 + 1:

```
make-checker 'string?? [string!]
```

The source is here:

```
make-checker: func [
	"Create a pass throught checker"
	name [word!] "The name of the checker"
	checks [block! datatype! typeset!] "The datatype to test for"
] [
	;TBD: function
	checks: blockify checks
	either error? try [
		checks: make typeset! checks] [do make error! "Error in datatypes block"
	] [
		set name func [
			data [any-type!]
		]	compose/deep [
			either find (checks) type? :data [:data] [do make error! rejoin [lf "--->   Value: " :data lf "--->   check: " (to-string name) lf "---> Waiting: " to-block (checks) lf "--->   found: " mold type? :data]]
		]
	]	
]
```

[1:53:30](#WaMSsEi3WrlrjuPF9_tCWoVuyCja6Kl5o3_vBTwd4LE) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here is how to create one for all datatypes:

```
create-checkers: function [] [
	t: to-block any-type! 

	w: words-of system/words
	forall w [
		if typeset? get/any :w/1 [append t w/1]
	]

	forall t [
		make-checker to-word head change back tail to string! t/1 "??" reduce t/1
	]
]
```

[9:47:43](#QEjZxcTNAkQnWBG5mDm058_j9eLyWbznKviDSnsWWxs) <Oldes (@oldes.h:matrix.org)>:
I would not recommend using something like that.. you are making code slower and unnecessary complex.. but if you enjoy playing with it, why not.... 

[9:53:08](#sZO1J8ThBNs2mSSHS0RHNKaIYPHJIeUS9S0FQxzoaUU) <GiuseppeChillemi (GiuseppeChillemi)>:
How do you test if a value has a datatype before feeding it to any function process it? Isn't it the short version if It or am I missing something?

[9:58:30](#QQDh0bMieinAvtTbb8NUZ96emRhv2h8NKR9qfEWigC8) <Oldes (@oldes.h:matrix.org)>:
Something like this?
```
if all [string? a find a "he"][ "Found HE" ]
```

[10:00:41](#b18JlUwUJxUwsjfkRTrFAiHbV0ZK7LUrxgnkPF9alSg) <Oldes (@oldes.h:matrix.org)>:
With _complexity_ I mean, that I even cannot try your function which you pasted here, because it depends on other home made functions, like ` blockify`. You should be aware that each function evaluation has its price.

[10:01:50](#NiyKZpamPKb1qfqG57vtn-wyVvUGoLXnwoFZ5pLhXgA) <GiuseppeChillemi (GiuseppeChillemi)>:
Pardon, I have made a mistake during copy & paste. Change blockify in TO BLOCK!

[10:06:10](#9b_k8zIsILRFM_zHT0TvBRFYLAnzjIvI4ndUPiRHZ5w) <GiuseppeChillemi (GiuseppeChillemi)>:
BLOCKIFY was not needed here. Is a function I use to make everything as a block when a function accepts either a single value or a block of multiple values. So I can manage everithing with only a FORALL loop, avoiding testing for the single value case.

[10:06:37](#eKogLlr_M41gQ2zCpc61vFugpdItfDa1cFXTGuDbryE) <GiuseppeChillemi (GiuseppeChillemi)>:
* BLOCKIFY was not needed here. It is a function I use to make everything as a block when a function accepts either a single value or a block of multiple values. So I can manage everything with only a FORALL loop, avoiding testing for the single value case.

[10:17:03](#VWE3fw1ih3vlQ4uiFAJm806mNDR5JFotU7r6FZmaak8) <Oldes (@oldes.h:matrix.org)>:
![](https://matrix-client.matrix.org/_matrix/media/v3/download/matrix.org/yPbMlUycRJoOMyhfyKMFoMoW)

[10:20:35](#FnU5Q9cTu_DO1doIXxmKhr9K-AzMwwNuq95YIFqhCaY) <Oldes (@oldes.h:matrix.org)>:
If you want to throw an error like in your example above, in Rebol there is an `assert` native...
```rebol
>> a: "ne" assert [string? a find a "he"]

** Script error: assertion failed for: [string? a find a "he"]
** Where: assert
** Near: assert [string? a find a "he"]
```

[10:28:46](#OXqdATEtQqAoYxuiVHlwAqq5UFpVgzlBoAinraPel4o) <GiuseppeChillemi (GiuseppeChillemi)>:
Which command are you using to get eval stats? We don't have anything similar in Red I think.

[10:32:47](#U0g5AMVp7s2cr20FR8xWUD25Hm4hA0tp07izoy8GxnA) <Oldes (@oldes.h:matrix.org)>:
```
>> stats/profile
== make object! [
    timer: 0:41:09.594508
    evals: 2029426
    eval-natives: 889502
    eval-functions: 18489
    series-made: 197746
    series-freed: 184784
    series-expanded: 771
    series-bytes: 3701216
    series-recycled: 184012
    made-blocks: 187420
    made-objects: 197
    recycles: 9204
    collisions: 2
]
```

[10:33:30](#grREVi0KUOJfpjTaDwyUbU2L3SqhyETtt6eO-Y-QMPk) <GiuseppeChillemi (GiuseppeChillemi)>:
Do we have typesets in Rebol3?

[10:33:42](#kOXVbJovCCd26MhHtg9Prwsr8UyLsvs5_6p8WbW9DDg) <Oldes (@oldes.h:matrix.org)>:
Of course.

[15:26:41](#SGH70sLtejYpxHg3qdoWaY2Hw8e5Dxjvyartuq4WUug) <GiuseppeChillemi (GiuseppeChillemi)>:
The purpose is to make visually shorter and more expressivve the phrase. I accept a couple of cycle less in not speed intensive functions. I have made another version which accepts arity-1 functions in checks block too, other than DT and typeset. 

[15:27:08](#2mLRgZ6vfx5Ctv63SuK9eZltZDmSfxPRa00rz6IqopU) <GiuseppeChillemi (GiuseppeChillemi)>:
* The purpose is to make visually shorter and more expressive the phrase. I accept a couple of cycle less in not speed intensive functions. I have made another version which accepts arity-1 functions in checks block too, other than DT and typeset. 

## 28-Jan-2025

[2:31:30](#T_3BWdgPPDhezVLlnfNgT1sz-PHy5TQdTnbEMpJriJo) <GiuseppeChillemi (GiuseppeChillemi)>:
Soon(tm) on your screen `extract+` a simple DSL to extract and/or trasform all your data, in any row shape it comes (it just need to have rows of the same horizontal length)

[2:31:54](#YqBgU1srgSYtjyAhCqBUzUh3G19km7ROcgnsbyiurMc) <GiuseppeChillemi (GiuseppeChillemi)>:
It is complete, I just need to write some documentation.

[2:34:37](#6q001PGhAfaNMfTrTeot5YEe0Y7iIhxeuFypRE-BebU) <GiuseppeChillemi (GiuseppeChillemi)>:
* Soon(TM) on your screens `extract+` a simple DSL to extract and/or trasform all your data, in any row shape it comes (it just need to have rows of the same horizontal length)

[2:34:54](#PJIGGNy5yfcy_RYVx4W9OWt1hX02nS5xv7Y6QkDCQyY) <GiuseppeChillemi (GiuseppeChillemi)>:
* Soon(TM) on your screens: `extract+`! A simple DSL to extract and/or trasform all your data, in any row shape it comes (it just need to have rows of the same horizontal length)

[21:11:19](#43xXyf_uOOpiuQgCVwXffHtDCKHKLpvX9QUPmr-XMp0) <GiuseppeChillemi (GiuseppeChillemi)>:
Dear friend, here it is my `Extract+` DSL for processing rows, hope you will like it: https://github.com/GiuseppeChillemi/Extract_plus

[21:11:28](#FsIPufKxx1APGdaFck_zn1OUqzTmrYGlhzYGRTSc7d4) <GiuseppeChillemi (GiuseppeChillemi)>:
* Dear friends, here it is my `Extract+` DSL for processing rows, hope you will like it: https://github.com/GiuseppeChillemi/Extract\_plus

[21:12:03](#BZ8I0D4kusyyzTRih1w9RwvrgPZ1rYVRpA0kvKAOh88) <GiuseppeChillemi (GiuseppeChillemi)>:
It is in its infancy but it works. Please report any error

[21:13:44](#5iXTbSo7-Z4CfD4-sU-zOXytAplKG79Pc_XQZbCUqmw) <GiuseppeChillemi (GiuseppeChillemi)>:
Having this series:
```
series: [a1 b1 c1 a2 b2 c2 a3 b3 c3]
```
This command:
```
extract+ series 3 [1 3]
```
Will produce:
```
[
  a1 c1 
  a2 c2 
  a3 c3
]
```


[21:15:58](#2Bl5XZAyTUcwc35_BOY8eqivbLbsEKTaoYdRYcxyLX8) <GiuseppeChillemi (GiuseppeChillemi)>:
But you can also assign WORDS to values:

Having this series:

```
series: [
	a1 b1 #[x: 10 y: 20] 
	a2 b2 #[x: 30 y: 40]
	a3 b3 #[x: 50 y: 60]
]
```
This code:

```
extract+ series 3 [1 #no a: 3 (a/xx)]
```
Will create:

```
[
	a1 10 
	a2 30 
	a3 50
]
```


[21:17:21](#a2_BCljuxgdg8ma-pQD3ISYuJvNEWhwTlyOOkQXEz4s) <GiuseppeChillemi (GiuseppeChillemi)>:
Any code in  paren will be processed. Its result will be used. If the code or the column integer is preceded from the `#no` it will not appear in the final row

[21:18:26](#7APHaQBy8W9CdYcZ_RO4Gs-1mxNKeAbi7E_-QA4y6qc) <greggirwin (Gregg Irwin)>:
Very cool.

[21:20:35](#6EqH6KATEx815tZ2nj-j9FP5cEp_2ZUKDJ1gKL1VHHQ) <GiuseppeChillemi (GiuseppeChillemi)>:
Thank you. It's for the help received from you all that was able to create this DSL

[21:27:12](#gRUD-BVPPVQwH-7IKLwtvV7HbDru9USxL9zPJr4BiSk) <GiuseppeChillemi (GiuseppeChillemi)>:
It is very simple but to make it this way, I have spent 5 days writing phrases trying to express what I want. The code has gone throught 1 rewriting but now I am satisfied.

[21:27:46](#Tw0MozjGBc8uGOZ9ZmJjoh_IlLowNfO7jqTWw5nZ_Q0) <GiuseppeChillemi (GiuseppeChillemi)>:
Just a picture from my notpad with all my phrasing attempts:

[21:27:52](#jMRII8jLuIAqm_kzb9sby_jybsKtSH3eB8zVQpLn684) <GiuseppeChillemi (GiuseppeChillemi)>:
![](https://gitter.ems.host/_matrix/media/v3/download/gitter.im/26ceb98b84d4c9e5d593ba76ee7b30d58ad30ad41884352716226953216)

[21:29:54](#uC8UWxG8psqPiokXSNYkbFooS00K8XS4g2FuJj0FtvY) <GiuseppeChillemi (GiuseppeChillemi)>:
* Just a picture from my notpad with all my phrasing attempts, with different hyphotesis of phrase segments.

[21:29:58](#SFjIVqjKJziAfAZR5hrYrJjmVyBz-xGGDjPtXdt_uew) <greggirwin (Gregg Irwin)>:
I often write a lot of samples when designing dialects.

[21:32:08](#trDpTOTminNIzDplGJN1P27dqK-X6zCZkpxp7GUswx8) <GiuseppeChillemi (GiuseppeChillemi)>:
This has been very difficult but source of great pleasure. Because the whole language is involved and you must have readability, but also obey reducing, composing, processing picked data...

[21:32:21](#OXWdh7utgnOy7KYyG2mKfgUF2-duj2c5mgEmFPcWdiI) <GiuseppeChillemi (GiuseppeChillemi)>:
* This has been very difficult but source of great pleasure. The whole language is involved and you must have readability, but also obey reducing, composing, processing picked data...

[21:32:30](#bTUU81b_9N4ExKaM5dUYZe1v-c8V3gT7cs8NckTasSo) <GiuseppeChillemi (GiuseppeChillemi)>:
* This has been very difficult but source of great pleasure. The whole Red language is involved and you must have readability, but also obey reducing, composing, processing picked data...

[21:32:45](#WrHucyO_jVp2mU8a4afW1xgNDyE8vX9IA-QJGgED8sI) <GiuseppeChillemi (GiuseppeChillemi)>:
* This has been very difficult but source of great pleasure. The whole Red language is involved and you must have readability, but also obey to reducing rules, composing, processing picked data...

[21:33:16](#fk_YjuJHx11e3-FwAGny6p7PtKQGdv5kCfoLZ0B7Sr8) <GiuseppeChillemi (GiuseppeChillemi)>:
* But you can also assign WORDS to values:

Having this series:

```
series: [
	a1 b1 #[xx: 10 y: 20] 
	a2 b2 #[xx: 30 y: 40]
	a3 b3 #[xx: 50 y: 60]
]
```

This code:

```
extract+ series 3 [1 #no a: 3 (a/xx)]
```

Will create:

```
[
	a1 10 
	a2 30 
	a3 50
]
```

[21:35:15](#MBiHFb_PMGwqbBgsJ2HRzCtFQvnTyq_Q6usJNX6qPkI) <GiuseppeChillemi (GiuseppeChillemi)>:
* But you can also assign WORDS to columns content:

Having this series:

```
series: [
	a1 b1 #[xx: 10 y: 20] 
	a2 b2 #[xx: 30 y: 40]
	a3 b3 #[xx: 50 y: 60]
]
```

This code:

```
extract+ series 3 [1 #no a: 3 (a/xx)]
```

Will create:

```
[
	a1 10 
	a2 30 
	a3 50
]
```

[21:35:40](#XWs5AaYAKUIhSdZ1P-u1GTiWONCTaEq7NODRFydBpoA) <greggirwin (Gregg Irwin)>:
Some of the most challenging projects are the most rewarding.

## 29-Jan-2025

[16:27:22](#1K-4hflZ1vmyLbIUqRjDDErvjibq3hvsX4LhLnaC3B4) <GiuseppeChillemi (GiuseppeChillemi)>:
In `extract+` I have just implemented `before` and `after` filtering. You provide to the function a block of code, if it returns `true` the data is skipped, otherwise is used. It works in two instants. `BEFORE` is run providing the original `ROW` at the current position, for pre evaluation; `AFTER` is run when all data is processed, `ROW` is formed and your code can avaluate it before the final `APPEND` to the return block.

I have in mind 3 styles for passing the filtering code (and other in future)

1) Only 1 Refinement solution and 2 ARGS
```
extract+/where series skip-size [before-code] [after-code]
```
2) Each code has 1 refinement and 2 ARGS
```
extract+/before/after series skip-size [before-code] [after-code]

```
3) only 1 refinement 1 arg, all is passed into a block:
```
[
  before [
     ...code here...
  ]
  after [
     ...code here...
  ]
]
```
4) As in point 3 but using set-words inside the block instead of words: `before:` and `after:`

[16:28:16](#3M0vdcdQf0zENHLuQpHG4YnTcYzHyL-rseDESzcP0gs) <GiuseppeChillemi (GiuseppeChillemi)>:
I don't know what to choose. have you any thoughts on the topic?

[16:29:44](#Ql0KNEMSWry08T1FVgc58snDmLAcHppayyKjOHMejbA) <GiuseppeChillemi (GiuseppeChillemi)>:
* In `extract+` I have just implemented `before` and `after` filtering. You provide to the function a block of code, if it returns `true` the data is skipped, otherwise is used. It works in two instants. `BEFORE` is run providing the original `ROW` at the current position, for pre evaluation; `AFTER` is run when all data is processed, `ROW` is formed and your code can avaluate it before the final `APPEND` to the return block.

I have in mind 3 styles for passing the filtering code (and other in future)

1. Only 1 Refinement solution and 2 ARGS

```
extract+/where series skip-size [row-proto] [before-code] [after-code]
```

2. Each code has 1 refinement and 2 ARGS

```
extract+/before/after series skip-size [before-code] [after-code]

```

3. only 1 refinement 1 arg, all is passed into a block:

```
[
  before [
     ...code here...
  ]
  after [
     ...code here...
  ]
]
```

4. As in point 3 but using set-words inside the block instead of words: `before:` and `after:`

[16:30:16](#F1y2xzY9QEOVtTEJ-JrWTvL6yfGUnC4hgPzcncMcYpc) <GiuseppeChillemi (GiuseppeChillemi)>:
* In `extract+` I have just implemented `before` and `after` filtering. You provide to the function a block of code, if it returns `true` the data is skipped, otherwise is used. It works in two instants. `BEFORE` is run providing the original `ROW` at the current position, for pre evaluation; `AFTER` is run when all data is processed, `ROW` is formed and your code can avaluate it before the final `APPEND` to the return block.

I have in mind 3 styles for passing the filtering code (and other in future)

1. Only 1 Refinement solution and 2 ARGS

```
extract+/where series skip-size [row-proto] [before-code] [after-code]
```

2. Each code has 1 refinement and 1 ARG

```
extract+/before/after series skip-size [before-code] [after-code]

```

3. only 1 refinement 1 arg, all is passed into a block:

```
[
  before [
     ...code here...
  ]
  after [
     ...code here...
  ]
]
```

4. As in point 3 but using set-words inside the block instead of words: `before:` and `after:`

[16:30:36](#G0eZl0gwiixIu5aZNSX9-zj8gfh4dNm-ruavLR8xRC4) <GiuseppeChillemi (GiuseppeChillemi)>:
* In `extract+` I have just implemented `before` and `after` filtering. You provide to the function a block of code, if it returns `true` the data is skipped, otherwise is used. It works in two instants. `BEFORE` is run providing the original `ROW` at the current position, for pre evaluation; `AFTER` is run when all data is processed, `ROW` is formed and your code can avaluate it before the final `APPEND` to the return block.

I have in mind 3 styles for passing the filtering code (and other in future)

1. Only 1 Refinement solution and 2 ARGS

```
extract+/where series skip-size [row-proto] [before-code] [after-code]
```

2. Each code has 1 refinement and 1 ARG

```
extract+/before/after series skip-size [before-code] [after-code]

```

3. only 1 refinement 1 ARG, all is passed into a block:

```
[
  before [
     ...code here...
  ]
  after [
     ...code here...
  ]
]
```

4. As in point 3 but using set-words inside the block instead of words: `before:` and `after:`

[16:31:40](#lNnNpnjYTIuxrTfMp_ZkY-DG_7Qsm1G7gYriyqfPndk) <GiuseppeChillemi (GiuseppeChillemi)>:
* In `extract+` I have just implemented `before` and `after` filtering. You provide to the function a block of code, if it returns `true` the data is skipped, otherwise is used. It works in two instants. `BEFORE` is run providing the original `ROW` at the current position, for pre evaluation; `AFTER` is run when all data is processed, `ROW` is formed and your code can avaluate it before the final `APPEND` to the return block.

I have in mind 3 styles for passing the filtering code (and other in future)

1. Only 1 Refinement solution and 2 ARGS

```
extract+/where series skip-size [row-proto] [before-code] [after-code]
```

2. Each code has 1 refinement and 1 ARG

```
extract+/before/after series skip-size [before-code] [after-code]

```

3. only 1 refinement 1 ARG, all is passed into a block:

```
[
  before [
     ...code here...
  ]
  after [
     ...code here...
  ]
]
```

4. As in point 3 but using `set-words` inside the block instead of words: `before:` and `after:`

[16:34:03](#TwQ20yHYSuAam9PXQlRSgJiE2il3zSGCuXnD9m466bk) <GiuseppeChillemi (GiuseppeChillemi)>:
* In `extract+` I have just implemented `before` and `after` filtering. You provide to the function a block of code, if it returns `true` the data is skipped, otherwise is used. It works in two instants. `BEFORE` is run providing the original `ROW` at the current position, for pre evaluation; `AFTER` is run when all data is processed, `ROW` is formed and your code can avaluate it before the final `APPEND` to the return block.

I have in mind 3 styles for passing the filtering code (and other in future)

1. Only 1 Refinement solution and 2 ARGS

```
extract+/where series skip-size [row-proto] [before-code] [after-code]
```

2. Each code has 1 refinement and 1 ARG

```
extract+/before/after series skip-size [row-proto]  [before-code] [after-code]

```

3. only 1 refinement 1 ARG, all is passed into a block:

```
extract+/where series skip-size [row-proto] [
  before [
     ...code here...
  ]
  after [
     ...code here...
  ]
]
```

4. As in point 3 but using `set-words` inside the block instead of words: `before:` and `after:`

[16:34:44](#bpoB3gqDDly8j5Qa1OnVbxWNGtxSu7y5dNYZaKVZTNQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* In `extract+` I have just implemented `before` and `after` filtering. You provide to the function a block of code, if it returns `true` the data is skipped, otherwise is used. It works in two instants. `BEFORE` is run providing the original `ROW` at the current position, for pre evaluation; `AFTER` is run when all data is processed, `ROW` is formed and your code can avaluate it before the final `APPEND` to the return block.

I have in mind 3 styles for passing the filtering code (and other in future)

1. Only 1 Refinement solution and 2 ARGS

```
extract+/where series skip-size [row-proto] [before-code] [after-code]
```

2. Each code has 1 refinement and 1 ARG

```
extract+/before/after series skip-size [row-proto] [before-code] [after-code]

```

3. only 1 refinement 1 ARG, all is passed into a block:

```
extract+/where series skip-size [row-proto] [
  before [
     ...code here...
  ]
  after [
     ...code here...
  ]
]
```

4. As in point 3 but using `set-words` inside the block instead of words: `before:` and `after:`

[17:09:29](#pN5WvLmD4S8qjabz95loqNwMINy2hLrL-EHshbDAoIk) <GiuseppeChillemi (GiuseppeChillemi)>:
just a correction, TRUE keeps the data, FALSE discards it.

## 30-Jan-2025

[0:39:13](#sghLvw49-D0kGn-ecaTfvZpRCSI74yDIY8SMHVv_5J0) <GiuseppeChillemi (GiuseppeChillemi)>:
I have added filtering and some improvements. https://github.com/GiuseppeChillemi/Extract_plus
Documentation has been updated too.

[0:42:29](#iW77Hjka2omCQ0bgeS4mJULepObnPu6wY3UXAxUIH9w) <GiuseppeChillemi (GiuseppeChillemi)>:
`ctx-user` is now availble. You can use it in you `where-before` and `where-after` code. `data` and `row` are the block of data passed at current row position and the `row` created by the proto, just before being stored in the final container. The latter is only valid when `where-after` code is run. Return `true` as last element if you want to keep your data or `false` to skip to the next row.

[0:42:35](#pCOWYs7iBMJcjS5Zyp6ZB0CKYxIva5fgC0K4yuj0q2Y) <GiuseppeChillemi (GiuseppeChillemi)>:
```
series: [
    a1 b1 #[xx: 10 yy: 20] 
    a2 b2 #[xx: 30 yy: 40]
    a3 b3 #[xx: 50 yy: 60]
]

extract+/where series 3 [quote 1 1 #no a: 3 (a/xx)] [
    either ctx-usr/data/1 = 'a2 [false] [true]
] 
[
    either ctx-usr/row/3 = 50 [false] [true]
]
```

[0:42:50](#qt_QU3L4DJzbRp52yR8rEe7mWEu2gNnhyZB2HiSEAls) <GiuseppeChillemi (GiuseppeChillemi)>:
Result:

[0:43:30](#U_U92_JpZTo_S8EORaWJ86uoSHrZRKKHaI9q59b_ZAg) <GiuseppeChillemi (GiuseppeChillemi)>:
```
[1 a1 10]
```


[0:44:36](#pGguh0vxBw6By2K_NMtcRxwKx13w_vC5m_wAgeGXptk) <GiuseppeChillemi (GiuseppeChillemi)>:
This code skips the current row when `data` column 1 is `a2` and where `row` created column 3 is `50`

[0:44:54](#fS1s95QSEUPZvTSsTkG7bhKOTioTbGVgQvIb_qyLFjQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* This code skips the current data row when `data` column 1 is `a2` and where `row` created column 3 is `50`

[0:46:25](#A8Obj5bfi_efx4XQ0qYsVu8pVo9E2exQlMdD1VHAeLo) <GiuseppeChillemi (GiuseppeChillemi)>:
It is funny, I have started with a 15 minutes work on extracting multiple columns and I have ended in a 7 days long DSL creation. 

[1:19:20](#SXMI30TlnnUDcqFJJuZbrV4qvInC_DvWcoTyuaRO5yk) <GiuseppeChillemi (GiuseppeChillemi)>:
I will add an option to bind your code to the column names, as you have full control on them  and there is no risk breaking your code bindings until you voluntary do this.

[1:21:28](#-YwuY5ruS_YvljmMcLd34PKyOem-lEnc2ukjcvJVs5A) <GiuseppeChillemi (GiuseppeChillemi)>:
* I will add an option to bind your code to the columns CTX, so you can use the column names for ROW. As you have full control on them, there is no risk breaking your code bindings until you voluntary do this.

[17:27:44](#rpZ-QT6XuV4fiPRQd_BWJgT84Lo4iNWt7Ap1V8gE4iI) <GiuseppeChillemi (GiuseppeChillemi)>:
Testing:

```

				red []
				people []
			]
		]
	]
]

words: [hello world red people]

ctx: context [
	hello: []
	world: []
	red: []
	people: []

]

probe dt [
	loop times [
		forall words [
			word: words/1
			do ctx/:word
		]
	]
]
		
probe dt [
	loop times [
		forall words [
			;word: words/1
			do ctx/(:words/1)
		]
	]
]

```

Result:

```
0:00:02.17141
0:00:02.04899
0:00:01.73097
```

It is totally unexpected for me. I thought the switch block would be more inefficient than ctx

[17:34:00](#4Hc1kjM4V7GIyxv01Q9bumBI0UJ4v7bcjUqK0YJWctc) <hiiamboris>:
your code is half eaten, no?

[17:34:48](#wiwEqNkIJjc6oZPIHiZ2zYrqrR1av8AdWE0ZVgdOI8I) <GiuseppeChillemi (GiuseppeChillemi)>:
* Testing:

```
times: 1000000

words: [hello world red people]

probe dt [
	loop times [
		forall words [
			word: words/1
			switch word [
				hello []
				world []
				red []
				people []
			]
		]
	]
]

words: [hello world red people]

ctx: context [
	hello: []
	world: []
	red: []
	people: []

]

probe dt [
	loop times [
		forall words [
			word: words/1
			do ctx/:word
		]
	]
]
		
probe dt [
	loop times [
		forall words [
			;word: words/1
			do ctx/(:words/1)
		]
	]
]

```

Result:

```
0:00:02.17141
0:00:02.04899
0:00:01.73097
```

It is totally unexpected for me. I thought the switch block would be more inefficient than ctx

[17:35:19](#-KJk83j5SUORffMWvmIddFeQNVwEIdB4mTYJ9KfQTuA) <GiuseppeChillemi (GiuseppeChillemi)>:
No, take a bettel look at it (and don't mind the "modified" text, it is a bug)

[17:35:55](#0UecWhPFsPcPPkJim48G7lc1EkNHiqwticZ4-0Qtg4E) <hiiamboris>:
:)

[17:37:07](#Xm9xrCX4-e9c-7gqyCa5jIVb7_j4Q8eSkdkYxI-SzVM) <GiuseppeChillemi (GiuseppeChillemi)>:
Only the last solution is about 30% faster

[17:37:15](#dl2z3FDAU0HSl-prZpGkbTHgAeYBH3XguMqb8rj131c) <GiuseppeChillemi (GiuseppeChillemi)>:
* Only the last solution is about 20% faster

[17:46:45](#Xy2_bhMBYgpoK8DIViI6cWhTBQtLHm38pMHWvPJjuNI) <hiiamboris>:
every token has an evaluation cost

[18:19:09](#y07niwxbqUZZwE9_OKM9R69KaMrkbSpgC3p2lJFJa_Y) <GiuseppeChillemi (GiuseppeChillemi)>:
1 million of selections via switch should be far more time consuming from selections on paths but I as wrong

[18:19:17](#aSwlVVhLFvnVTZ0aFsM6d2Osoi5j64vWuI_lmhckSJ0) <GiuseppeChillemi (GiuseppeChillemi)>:
* 1 million of selections via switch should be far more time consuming from selections on paths but I was wrong

## 31-Jan-2025

[7:31:02](#OQCyz-ALtbGJwGiI29O-vQhBZ4sSTnKO1krGvDq3jvU) <hiiamboris>:
FYI this example:
```
extract+/where series 3 [quote 1 1 #no a: 3 (a/xx)] [
    either ctx-usr/data/1 = 'a2 [false] [true]
] 
[
    either ctx-usr/row/3 = 50 [false] [true]
]
```
Can be much more readably rewritten as:
```
extract+/where series 3 [quote 1 1 #no a: 3 (a/xx)] [
    ctx-usr/data/1 <> 'a2
] 
[
    ctx-usr/row/3 <> 50
]
```
But what I wanted is to show that while it may be tempting to make a swiss army knife that does everything at once, the same or better result could come from carefully designed separate tools, e.g.:
```
map/drop/eval each series [c1 _ c3] [
	when all [
		c1 <> 'a2
		c3/xx <> 50
	][
		[1 c3/xx]
	]
]
```
(in case of a long table row this example will also be using something like `extract .. [50 100]`)

[11:55:39](#8zCNPOCr6D_GfAV6QUekHvkQUEyUuvBz1MMupVp3jH4) <GiuseppeChillemi (GiuseppeChillemi)>:
Thank you are right but there is a reason I have made this example so explicit:

```
extract+/where series 3 [quote 1 1 #no a: 3 (a/xx)] [
    either ctx-usr/data/1 = 'a2 [false] [true]
] 
[
    either ctx-usr/row/3 = 50 [false] [true]
]
```

My goal was to show in a explicy way the use of the context and then the return of `true` and `false`. They are examples for newbye which do not know about truthy values.

[12:01:58](#I9mPIhbhb-Po6P9SPuRcx8JqKQ5jOUV0fCfBD_kRKgE) <GiuseppeChillemi (GiuseppeChillemi)>:
My code could be easily written in this way (and later with just 1 block)

```
	[1 a1 10] = probe extract+/where series 3 [quote 1 y:  1 #no a: 3 (a/xx)] [
		true
	] 
	[
		either any [y = 'a2 a/xx = 50] [false] [true] 
	]
```

[12:04:06](#WDdr-g6ZiV62OEMu06cuKPNU2hrtTd0_teNZNpFSwEI) <GiuseppeChillemi (GiuseppeChillemi)>:
There is a specific reason why I am forcing to return `true` and `false`. I later plan to give block returned as values a special meaning: If it is returned instead of `logic`, the block will be used instead of the one actually processed, letting you provide totally new and fresh data.

[12:04:29](#9R9EobJgcjQm55DbiBGh0k5bEj6GxBxm9P2K_r2ZRfE) <GiuseppeChillemi (GiuseppeChillemi)>:
* There is a specific reason why I am forcing to return `true` and `false`. I later plan to give to block returned as values a special meaning: If it is returned instead of `logic`, the block will be used instead of the one actually processed, letting you provide totally new and fresh data.

[12:29:33](#5qvBaUq3EAN1E8dK_NZG7Ym2hqrWkBwgoLKNddZ0Ql8) <GiuseppeChillemi (GiuseppeChillemi)>:
OkI have pushed a commit splitting `/where` in `before/after` refinements

[12:30:12](#ro0SXoscC57rSBaE0bxbUhsgrhym462hT1UFjGV4Wdo) <GiuseppeChillemi (GiuseppeChillemi)>:
Now you can write:

```
	[1 a1 10] = probe extract+/where series 3 [quote 1 y:  1 #no a: 3 (a/xx)] [
		either any [y = 'a2 a/xx = 50] [false] [true] 
	]
```


[12:30:45](#J6VzXMIL71tBo1hVAhDv6lG0EIRlhihgHJlKKvDx9dA) <GiuseppeChillemi (GiuseppeChillemi)>:
* Ok, I have pushed a commit splitting `/where` in `before/after` refinements

[14:30:47](#Tl9e0DkZqQLSfXpZlDsuPWTMZfk0PmfxoUGKgfi69yk) <GiuseppeChillemi (GiuseppeChillemi)>:
hiiamboris: You `map` solution is good but does not cover the "long row" problem my DSL has been created for: very long rows. Sometime you have CSV with 20 rows and no column names. It problematic to write:
```
[a b _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ name _ _]
```
As you may miss an element.
It is less prone to errors:
```
[a 1 b 2 name 18]
```
And 
```
reduce [a b "something" name]
```
There are aspect of my solution I would like to change and I am more incline to have a separate block for column names. So you solution is an inspiration for cleaness but a good one (for me) needs position. I will rework everything on a separate  branch



[14:30:56](#xSXe_DRQT6SH8caiu0DybyaGeJLCdszM5z70vTMOz00) <GiuseppeChillemi (GiuseppeChillemi)>:
* hiiamboris: You `map!` solution is good but does not cover the "long row" problem my DSL has been created for: very long rows. Sometime you have CSV with 20 rows and no column names. It problematic to write:

```
[a b _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ name _ _]
```

As you may miss an element.
It is less prone to errors:

```
[a 1 b 2 name 18]
```

And

```
reduce [a b "something" name]
```

There are aspect of my solution I would like to change and I am more incline to have a separate block for column names. So you solution is an inspiration for cleaness but a good one (for me) needs position. I will rework everything on a separate  branch

[14:31:12](#Gx7CO2tsGXfmJXHMLc2EST1uDixBuee-iGXAHNOM14Y) <GiuseppeChillemi (GiuseppeChillemi)>:
* hiiamboris: You `map!` solution is good but does not cover the "long row" problem my DSL has been created for: very long rows. Sometime you have CSV with 20 columns and no column names. It problematic to write:

```
[a b _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ name _ _]
```

As you may miss an element.
It is less prone to errors:

```
[a 1 b 2 name 18]
```

And

```
reduce [a b "something" name]
```

There are aspect of my solution I would like to change and I am more incline to have a separate block for column names. So you solution is an inspiration for cleaness but a good one (for me) needs position. I will rework everything on a separate  branch

[14:32:26](#SC9RHjsjLqMuYBo0ei-rT5hXsgYCYy5KOKgSz67xdDk) <GiuseppeChillemi (GiuseppeChillemi)>:
* hiiamboris: You `map!` solution is good but does not cover the "long row" problem my DSL has been created for: very long rows. Sometime you have CSV with 20 columns and no column names. It problematic to write:

```
[a b _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ name _ _]
```

As you may miss an elements.
It is less prone to errors:

```
[a 1 b 2 name 18]
```

And

```
reduce [a b "something" name]
```

There are aspect of my solution I would like to change and I am more incline to have a separate block for column names. So you solution is an inspiration for cleaness but a good one (for me) needs position. I will rework everything on a separate  branch

[14:35:10](#OcZBvC-iVu6ZNQRIy2uh10_-sctblRqw2xIF6sZFpBw) <GiuseppeChillemi (GiuseppeChillemi)>:
PS: I have searched on `common` repository but I have not found `map` only map-each`, `new-each` and `each`

[14:35:31](#uWoLL5uohuU2nM6BiElhUAjyjOdtaefEbmwu4oXcp68) <GiuseppeChillemi (GiuseppeChillemi)>:
* PS: I have searched on `common` repository but I have not found `map` only `map-each`, `new-each`and `each`

[14:35:44](#A5SKTK9aDE_zResh0ue6OuJOVbjrwrJOadTdMQPR2Lc) <GiuseppeChillemi (GiuseppeChillemi)>:
* PS: I have searched on common repository but I have not found `map` only `map-each`, `new-each`and `each`

[14:35:53](#rHohwzVP6q-LDRKlAcpBnhGmmqjWNHf6rDT2acAUuxo) <GiuseppeChillemi (GiuseppeChillemi)>:
* PS: I have searched on COMMON repository but I have not found `map` only `map-each`, `new-each`and `each`

[14:43:40](#wujRItnVhS7ka7lWYtMz90nmloSfxFJfamaixqSQVBY) <GiuseppeChillemi (GiuseppeChillemi)>:
This is a new version I think it would be a lot faster and clean:

```
extract+/init series witdth [a: 1 b: 2 c: 10]  [
   reduce [a b "hello" c]
] [counter: 0]
```
The first block is a DSL with words mapping to positions.
The second one returns the current row or `true`/`false` for skipping.
The last one is an `init` block  


[14:43:55](#MnW2KZC0Do9GyHqw3zsk5aL2wP1AypXzcfkoQ2Z8wjE) <GiuseppeChillemi (GiuseppeChillemi)>:
* This is a new version I think it would be a lot faster and clean:

```
extract+/init series width [a: 1 b: 2 c: 10]  [
   reduce [a b "hello" c]
] [counter: 0]
```

The first block is a DSL with words mapping to positions.
The second one returns the current row or `true`/`false` for skipping.
The last one is an `init` block

[15:16:09](#6BX3I1Vm7kQbZWnOf98r1zzlHecDXgu40PjT88lO61E) <hiiamboris>:
it is addressed by the last sentence in my message

[15:17:51](#vzs2k7whw-77Vojy86jAKEnSkXuvFykemlQocxqyjtc) <hiiamboris>:
it is addressed by the last sentence in my message

[15:18:24](#mIdM424MidMTrVhMErKqUtkTz8F2IPrX4FqsNrgRvCo) <hiiamboris>:
https://github.com/red/REP/issues/168

[15:19:50](#a-3ZivSSy1EOcssfxlWICfx140wzbc1rUl6kh9KbhFs) <hiiamboris>:
I would try to place `init`  before the rest

[15:20:38](#52R37IM1mbmZzUP2goPQwfYKMFcSD9yBwPIHKHyVVYI) <hiiamboris>:
* but what is it for? why not put it in a line before `extract`?

[15:22:22](#4NUZoVNw4EuSRwiAQ_1wLDlL413wDUEbEKM3ciNWmuw) <hiiamboris>:
* I would try to put `init` before the rest.  But what is it for? why not put it in a line before `extract`?

[15:39:30](#GI9Ja_VMfI_nE4y3HqiHNiLPNrF1eZx2X2KwRgxIZDA) <GiuseppeChillemi (GiuseppeChillemi)>:
`Init` is adding fields to the columns context after the picking by position phase.

So you have:
````
ctx: context [
  a: func[][:data/1]
  b: func[][:data/2]
  c: func[][:data/10]
]
```
Then the function will create another object using the init block
```
ctx: make object! ctx [counter: 0]
```

So the final object! will be:

``` [
  a: func[][:data/1]
  b: func[][:data/2]
  c: func[][:data/10]
  counter: 10
]
```

[15:39:56](#eWYJuTJqvdFySQxpDyLcwzGFqO6d-YP439BFesrdbOA) <GiuseppeChillemi (GiuseppeChillemi)>:
* `Init` is adding fields to the columns context after the picking by position phase.

So you have:

````
ctx: context [
  a: func[][:data/1]
  b: func[][:data/2]
  c: func[][:data/10]
]
```
Then the function will create another object using the init block
```
ctx: make object! ctx [counter: 0]
```

So the final object! will be:

``` [
  a: func[][:data/1]
  b: func[][:data/2]
  c: func[][:data/10]
  counter: 10
]
```


[15:40:43](#HkRN0vA5bA6BNloIlrjgHvrDtWnhH5HA-RgScxkvK-0) <GiuseppeChillemi (GiuseppeChillemi)>:
So I can access each column via word, and also other meaningful data for row processing

[15:42:27](#ivB74-42o_MB9mwuLylSAB-09sBDOeUF8wdTwHCGym0) <GiuseppeChillemi (GiuseppeChillemi)>:
The lack of an active syntax for paths to pick elements limits me a lot. 

[15:42:53](#4s50vBKdcHkYqVoMhtCKi_86ZsDsWYyF7jTMsz9s5DA) <GiuseppeChillemi (GiuseppeChillemi)>:
* The lack of an active syntax for paths to pick elements limits me in speed as I must pass from a function interface

[15:43:03](#s_rBsps6agJQepN2Irye33DCFCOgDnQbMlWyIrdvRVA) <GiuseppeChillemi (GiuseppeChillemi)>:
* The lack of an active syntax for paths to pick elements, limits me in speed as I must pass from a function interface

[15:45:23](#NuSh0ISDtSZXxqiDD3sPhWBcnW6HfKeyy3o0LkBiPqc) <GiuseppeChillemi (GiuseppeChillemi)>:
I have not understood if you have implemented `map/drop/eval` or are you suggesting me to modify it in this way

[16:03:54](#B7blrwfSyZE8dPEjLh-GbBfBm__I5xmApFrnywoAy4A) <hiiamboris>:
I'm saying that a carefully crafted language constructs alleviate the need for a lot of adhoc solutions :)

[16:07:26](#sqZVKPgzy90euyKjHAb3hF8RGTwaxlrn0cE0WErsdl4) <hiiamboris>:
I'm not saying Red is there or nearly there

[19:10:23](#Hq6r8_OZxKZGUE1eTsOzfBn1Nha1IVdfn_ReZoykVx8) <GiuseppeChillemi (GiuseppeChillemi)>:
Hope we will create it in the future. 

[19:10:41](#G2L_OCf9bn42aITp-aGp-YJtGKTkw9R5i6yL4wCxONw) <GiuseppeChillemi (GiuseppeChillemi)>:
Paths is the way for simplicity and speed

[20:47:00](#VVNUuaWoUVqw7AGH2-evUCKBfL2YGLRnAVpn5vBFS2E) <GiuseppeChillemi (GiuseppeChillemi)>:
Nice read

[20:47:16](#FcuG1pwGvuQ8qf2Bmx7SG4e3zQRU-O82N6JXWtFoHIo) <GiuseppeChillemi (GiuseppeChillemi)>:
I will return on it yo understand it fully

[20:47:27](#FIbrSZQjPxQb9cmswptQKx-K9MfyYr-jXTMuAvAvPGE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I will return on it to understand it fully

[23:03:42](#X3yeF3Wt9rQZxKbGUCiepieMmqVSjgywMVSdlio02HM) <greggirwin (Gregg Irwin)>:
Haven't kept up here. Will try to catch up soon.

## 4-Feb-2025

[14:53:03](#0ocfOKx5XitGDPKE7Re_eQNKY_I3sxZcAQ5Y6ZE4wW8) <GiuseppeChillemi (GiuseppeChillemi)>:
I have continued the idea of `make-active-path` here:

```
make-row-accessor: func [
	container-word [word!]
	columns [block!]
	type [word!]
	;Other types here
	/strings
	/words
	/local
	m
	w
	column-name
] [
	;make copy scheme e reduce e map
	m: make map! #[]
	forall columns [
		case [
			type = 'bob [
				column-name: columns/1
					case [
						all [not string? column-name not word? column-name] [do make error! rejoin ["Bad datatype of column at: " index? columns]]
						all [strings word? column-name] [
							column-name: to-string column-name
						]
						all [words string? column-name] [
							column-name: attempt [to-word column-name]
							if not column-name [do make error! rejoin ["Can't convert column at: " index? columns]]
						]
					]
			]
			true [do make error! rejoin ["Type not supported: " type]]
		]
		put m column-name make-active-path to-path reduce [container-word 1 index? columns]
	]
	m
]
```
As now it supports the block of block types:

```
table: next [
	[col1 col2 col3 col4]
	[1 2 3 4]	
	[11 22 33 44]	
	[111 222 333 444]	
	[1111 2222 3333 4444]	
	[11111 22222 33333 44444]	
]
```
Now lets make the accessor for the table row
```
row: make-row-accessor 'table first head table 'bob
```
And print all column `col1` values
```
forall table [
	probe row/col1
]
```
Result:

```
1
11
111
1111
11111
```
If you view the accessor with: `probe row` 
```
#[
    col1: func [][:table/1/1]
    col2: func [][:table/1/2]
    col3: func [][:table/1/3]
    col4: func [][:table/1/4]
]
```

[14:54:16](#1TWqIyPhE9r9XwmJL7k9glIDK6Snh4a_2TXgYpQnfJc) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have continued the idea of `make-active-path` here:

```
make-row-accessor: func [
	container-word [word!] "The word containing the data"
	columns [block!] "The columns"
	type [word!] "the type of container data"
	/strings
	/words
	/local
	m
	w
	column-name
] [
	;make copy scheme e reduce e map
	m: make map! #[]
	forall columns [
		case [
			type = 'bob [
				column-name: columns/1
					case [
						all [not string? column-name not word? column-name] [do make error! rejoin ["Bad datatype of column at: " index? columns]]
						all [strings word? column-name] [
							column-name: to-string column-name
						]
						all [words string? column-name] [
							column-name: attempt [to-word column-name]
							if not column-name [do make error! rejoin ["Can't convert column at: " index? columns]]
						]
					]
			]
			true [do make error! rejoin ["Type not supported: " type]]
		]
		put m column-name make-active-path to-path reduce [container-word 1 index? columns]
	]
	m
]
```

As now it supports the block of block types:

```
table: next [
	[col1 col2 col3 col4]
	[1 2 3 4]	
	[11 22 33 44]	
	[111 222 333 444]	
	[1111 2222 3333 4444]	
	[11111 22222 33333 44444]	
]
```

Now lets make the accessor for the table row

```
row: make-row-accessor 'table first head table 'bob
```

And print all column `col1` values

```
forall table [
	probe row/col1
]
```

Result:

```
1
11
111
1111
11111
```

If you view the accessor with: `probe row`

```
#[
    col1: func [][:table/1/1]
    col2: func [][:table/1/2]
    col3: func [][:table/1/3]
    col4: func [][:table/1/4]
]
```

[14:54:33](#XHHMDmOkCro3wVHUSLydFl2bXWVrhoTKYEklMS5q-mk) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have continued the idea of `make-active-path` here:

```
make-row-accessor: func [
	container-word [word!] "The word containing the data"
	columns [block!] "The columns"
	type [word!] "the type of container data"
	/strings
	/words
	/local
	m
	w
	column-name
] [
	m: make map! #[]
	forall columns [
		case [
			type = 'bob [
				column-name: columns/1
					case [
						all [not string? column-name not word? column-name] [do make error! rejoin ["Bad datatype of column at: " index? columns]]
						all [strings word? column-name] [
							column-name: to-string column-name
						]
						all [words string? column-name] [
							column-name: attempt [to-word column-name]
							if not column-name [do make error! rejoin ["Can't convert column at: " index? columns]]
						]
					]
			]
			true [do make error! rejoin ["Type not supported: " type]]
		]
		put m column-name make-active-path to-path reduce [container-word 1 index? columns]
	]
	m
]
```

As now it supports the block of block types:

```
table: next [
	[col1 col2 col3 col4]
	[1 2 3 4]	
	[11 22 33 44]	
	[111 222 333 444]	
	[1111 2222 3333 4444]	
	[11111 22222 33333 44444]	
]
```

Now lets make the accessor for the table row

```
row: make-row-accessor 'table first head table 'bob
```

And print all column `col1` values

```
forall table [
	probe row/col1
]
```

Result:

```
1
11
111
1111
11111
```

If you view the accessor with: `probe row`

```
#[
    col1: func [][:table/1/1]
    col2: func [][:table/1/2]
    col3: func [][:table/1/3]
    col4: func [][:table/1/4]
]
```

[15:03:06](#8uoDDstjy8m8jKuJ73fact1kJBozVvqS_TgKxxCoZ5I) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have continued the idea of `make-active-path` discussed [here](https://matrix.to/#/!wUTlqkqOhNGtfQzIsO:matrix.org/$173832694519rFhOF:gitter.im?via=gitter.im&via=matrix.org&via=tchncs.de):

```
make-row-accessor: func [
	container-word [word!] "The word containing the data"
	columns [block!] "The columns"
	type [word!] "the type of container data"
	/strings
	/words
	/local
	m
	w
	column-name
] [
	m: make map! #[]
	forall columns [
		case [
			type = 'bob [
				column-name: columns/1
					case [
						all [not string? column-name not word? column-name] [do make error! rejoin ["Bad datatype of column at: " index? columns]]
						all [strings word? column-name] [
							column-name: to-string column-name
						]
						all [words string? column-name] [
							column-name: attempt [to-word column-name]
							if not column-name [do make error! rejoin ["Can't convert column at: " index? columns]]
						]
					]
			]
			true [do make error! rejoin ["Type not supported: " type]]
		]
		put m column-name make-active-path to-path reduce [container-word 1 index? columns]
	]
	m
]
```

As now it supports the block of block types:

```
table: next [
	[col1 col2 col3 col4]
	[1 2 3 4]	
	[11 22 33 44]	
	[111 222 333 444]	
	[1111 2222 3333 4444]	
	[11111 22222 33333 44444]	
]
```

Now lets make the accessor for the table row

```
row: make-row-accessor 'table first head table 'bob
```

And print all column `col1` values

```
forall table [
	probe row/col1
]
```

Result:

```
1
11
111
1111
11111
```

If you view the accessor with: `probe row`

```
#[
    col1: func [][:table/1/1]
    col2: func [][:table/1/2]
    col3: func [][:table/1/3]
    col4: func [][:table/1/4]
]
```

[15:04:04](#F_BO5ufgeIOKdM3G4goDjUQdOcm-8qjkCbpICYRCdTc) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have continued the idea of `make-active-path` discussed [here](https://matrix.to/#/!wUTlqkqOhNGtfQzIsO:matrix.org/$173832694519rFhOF:gitter.im?via=gitter.im&via=matrix.org&via=tchncs.de):

I have created a row accessor for _block of blocks_ data that can be used inside a `forall` loop

```
make-row-accessor: func [
	container-word [word!] "The word containing the data"
	columns [block!] "The columns"
	type [word!] "the type of container data"
	/strings
	/words
	/local
	m
	w
	column-name
] [
	m: make map! #[]
	forall columns [
		case [
			type = 'bob [
				column-name: columns/1
					case [
						all [not string? column-name not word? column-name] [do make error! rejoin ["Bad datatype of column at: " index? columns]]
						all [strings word? column-name] [
							column-name: to-string column-name
						]
						all [words string? column-name] [
							column-name: attempt [to-word column-name]
							if not column-name [do make error! rejoin ["Can't convert column at: " index? columns]]
						]
					]
			]
			true [do make error! rejoin ["Type not supported: " type]]
		]
		put m column-name make-active-path to-path reduce [container-word 1 index? columns]
	]
	m
]
```

As now it supports the block of block types:

```
table: next [
	[col1 col2 col3 col4]
	[1 2 3 4]	
	[11 22 33 44]	
	[111 222 333 444]	
	[1111 2222 3333 4444]	
	[11111 22222 33333 44444]	
]
```

Now lets make the accessor for the table row

```
row: make-row-accessor 'table first head table 'bob
```

And print all column `col1` values

```
forall table [
	probe row/col1
]
```

Result:

```
1
11
111
1111
11111
```

If you view the accessor with: `probe row`

```
#[
    col1: func [][:table/1/1]
    col2: func [][:table/1/2]
    col3: func [][:table/1/3]
    col4: func [][:table/1/4]
]
```

[15:10:28](#0-2w4BicfiFliK4J18P1TkKisHyCnQY85hswNTNttkc) <GiuseppeChillemi (GiuseppeChillemi)>:
I will add the /set refinement of full read/write.
You need just to position the table to the desired position

[15:15:03](#Es6ymxO1OavX95YGF0pXVT7uozippHmcEFZY-FU8JME) <GiuseppeChillemi (GiuseppeChillemi)>:
Again, as discussed in the past months, the biggest problem I have is the lack of side data and actors, otherwhise I could do a lot more. The output is a map to manage the case where columns could be strings. 

## 5-Feb-2025

[0:45:13](#rpgSGpGVLdttbgMKCMZoWGT9rc3jr_-PR60ncz4txAA) <GiuseppeChillemi (GiuseppeChillemi)>:
GiuseppeChillemi (GiuseppeChillemi): Experimenting with paths

While discussing about path pickers, I tought about having a caracter in the middle of a path to JOIN the result of a paren instead of using it to select.
This is the result:

```
probe pt: 'table/!/('m/col)

parse pt [
	any [
		change ['! set code paren!] (do code) 		 
	|
		any-type!
	]
]

>> probe pt
table/m/col
```


[0:45:22](#JGoD1oSaOnxWbx_Aev9kKC924QDgITTE09huil8yfU0) <GiuseppeChillemi (GiuseppeChillemi)>:
* GiuseppeChillemi (GiuseppeChillemi): Experimenting with paths

While discussing about path pickers, I tought about having a caracter in the middle of a path to JOIN the result of a paren instead of using it to select.
This is the result:

```
pt: 'table/!/('m/col)

parse pt [
	any [
		change ['! set code paren!] (do code) 		 
	|
		any-type!
	]
]

>> probe pt
table/m/col
```

[0:46:53](#nmppoRvG5il1YZWhbAZ4AsNucG9aHXXxl0xzOubrhdI) <GiuseppeChillemi (GiuseppeChillemi)>:
* GiuseppeChillemi (GiuseppeChillemi): Experimenting with paths

While discussing about path pickers, I tought about having a caracter in the middle of a path to JOIN the result of a paren instead of using it to select.
This is the result:

```
pt: 'table/!/('m/col)

parse pt [
	any [
		change ['! set code paren!] (do code) 		 
	|
		any-type!
	]
]

>> probe pt
table/m/col
```

[0:59:29](#BHufoP_3lNKPTYE7d_BtNpO__rYLLxxrjr1gqAOPq0s) <GiuseppeChillemi (GiuseppeChillemi)>:
If the code in `paren!` contains a function, the path will be completed with its result. This should permit to select the column picker of a data in a function and have it complete the path.
Try with: 
```
'table/!/(rejoin [to-path pick [x y z] 2 pick ["hello" "red" "people"] 3])
```
And the result will be:
```
table/y/"people"
```
Note the difference: a normal path would be `length = 2` because `y/"people"` would be a path used as unique key. Instead using this parser `length = 3`, because each element is added in a separate way.


[1:00:25](#0IVTJL1NRUE4elIqcWYCuem7uKWckYbhSu0T9dSM0Qo) <GiuseppeChillemi (GiuseppeChillemi)>:
* Why this?

If the code in `paren!` contains a function, the path will be completed with its result. This should permit to select the column picker of a data in a function and have it complete the path.
Try with:

```
'table/!/(rejoin [to-path pick [x y z] 2 pick ["hello" "red" "people"] 3])
```

And the result will be:

```
table/y/"people"
```

Note the difference: a normal path would be `length = 2` because `y/"people"` would be a path used as unique key. Instead using this parser `length = 3`, because each element is added in a separate way.

[1:28:47](#C4NJg1y5UPCUXhplocDtRRtjVwgLGbOPfID1NUwhc8I) <GiuseppeChillemi (GiuseppeChillemi)>:
This will allow:

```
data/!/(get-extractor-path container 'name)
```

[6:26:41](#wF5PzQ0DNM5mwMup4prueQAl5HKIoJYZQjLaKuGU2MY) <hiiamboris>:
You could base it on `compose`:
```
>> as path! compose as block! 'table/('m/col)
== table/m/col
```

[19:41:17](#bsXUPZbPjinAhr98DOv4h9SFYYb3ULlkuJyUKfAIYkM) <greggirwin (Gregg Irwin)>:
Dialected paths are something I hadn't thought of until the `apply` work. Another amazing way Red can be bent to our will.

[19:41:39](#zCzn0k9qsaQSr9JztW4NOyctKEeVsxqMYe_dI4u_Gc4) <greggirwin (Gregg Irwin)>:
Very fun accessor work GiuseppeChillemi (GiuseppeChillemi) .

[20:07:50](#oS4qITTEVtE6eIvAnU9qLM5B36tHgUnDh8ZB5K64o8I) <GiuseppeChillemi (GiuseppeChillemi)>:
Paths have a great potential.
My last work, where a path starts with +, has started to have relative paths. It is an element you can append to any word or path, to complete it and access an element. 

[20:14:25](#0jbcpSUi6mG5st9l0-5ocMbiVfdXdhtLGZvR8NzE3SE) <greggirwin (Gregg Irwin)>:
Well, the standard for relative paths is just being a path. An absolute *file* path starts with a slash, but `path!` values don't allow that. From file systems we also have `.` and `..` for relative shifts.

It's another area where we want to look at the big picture of file globbing/selection, and structural query models, like XPath/JSONPath. The more we can unify things, the better.

[20:50:35](#enL5qEQKrGCvVMAZX1Iva05oCPzigLAvFLFqKSjGXzE) <GiuseppeChillemi (GiuseppeChillemi)>:
Parse is a better friend here for navigation INTO nodes. I will work on something based on it. Paths have always been my passion. Lets see what comes out from mind. 

## 7-Feb-2025

[18:04:11](#xVZtx8_yCVaCbX3wMNEkgJdz7x5FFBQL1XbkByivxV4) <GiuseppeChillemi (GiuseppeChillemi)>:
I have use my `parse-specs` to check count and sort the number of refinements. Here is the result:

[Sorted Function by refinements](https://gist.github.com/GiuseppeChillemi/a0c33f5fabff8e02c3b15eaf2ef7a091)

[18:04:44](#KIIsBffHBEGgSYT7ZOv8yNelVUloAFB2ukxgjYBGmvQ) <GiuseppeChillemi (GiuseppeChillemi)>:
The winner is... `FIND!` with 11 refinements

[18:05:00](#d0-eQOvywCfq8jMGH2aMCwT6NrN1DCZeSuCKsSNKhI4) <GiuseppeChillemi (GiuseppeChillemi)>:
* The winner is... `FIND` with 11 refinements!

[20:25:18](#LXJnyU2upYp5WFLAJmJGiSgddm4dUZmwx5B0Ms8z87Q) <greggirwin (Gregg Irwin)>:
Nice. I did a similar tally some years back.

[20:47:11](#SVIa8pvk_HN2c252KDEXcAUEnxPHPKPmZFnOP2xYLD4) <GiuseppeChillemi (GiuseppeChillemi)>:
We all love Red

[20:50:32](#q_sIOW956par7AWNn-8VToi93TiVMFYHcc0EY0QSdBc) <GiuseppeChillemi (GiuseppeChillemi)>:
I have many ideas of automatic creators for documentation. It has been difficult but never surrending, I have now reached the target I have myself 3 years ago. 

[20:50:53](#SMVMXdI0AWvem0r6SP3S34gWWPzyukFtJ9d3315A83o) <GiuseppeChillemi (GiuseppeChillemi)>:
(And with your help)

[23:44:43](#Kh8NK61i1uIPJiKka62kL0h375XmvVSNg-QVKjuOSRY) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have many ideas of automatic creators for documentation. It has been difficult but never surrending, I have now reached the target I gave myself 3 years ago. 

## 8-Feb-2025

[0:46:44](#xNDwrCQycn-Epzh9gQO6qIZBe3afdoGEQdOE4KQ9Xvs) <GiuseppeChillemi (GiuseppeChillemi)>:
During the last month we have discussed about the hypotehsis of having `APPLY` use a context to set the /LOCALS of the called function. This to avoid the init phase. This could be important for strict loops where the init and check phase heavy. Rebol 3 has already something like this and some functions can receive a context.
I have written an `extract-keys` function. This needs a container to be created at each run and some checks on keys. Also I have created an `extract-keys-fast` At the end you can see the difference.
[Here is the test](https://gist.github.com/GiuseppeChillemi/8bd833ba511af556ae135474088dda06)

[0:53:17](#ud4NBOtRKEZnXviWvhCSGaS2maXGclqwP83AacqcWFw) <GiuseppeChillemi (GiuseppeChillemi)>:
Also, as function engineering rule, the more precalculated element you pass, the better it is. This at the cost of being less precise in the error messages and wrapping the code in an `error? try block` which throws an error.

[0:54:02](#2rfHJKYFhbR7orpFzRAvLA6ieKGSfRJrG4-zOi7-NWM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Also, as function engineering rule, the more precalculated element you pass, the better it is. This at the cost of being less precise in the error messages. You wrap the code in an `error? try block` and it throws a more generic error.

[2:31:44](#zIukxLmXDcJ__g0DGT6Vj6JnTrkB8L6g9rYaLmdmPfU) <GiuseppeChillemi (GiuseppeChillemi)>:
* During the last month we have discussed about the hypothesis of having 
APPLY use a context to set the /LOCALS of the called function. This to avoid the init phase. This could be important for strict loops where the init and check phase is heavy. Rebol 3 has already something like this and some functions can receive a context.
I have written an extract-keys function. This needs a container to be created at each run and some checks on keys. Also I have created an extract-keys-fast At the end you can see the difference.
Here is the test

[12:21:05](#7IeHiAFzkC2K93Yn91VB-rhTvZhvvTPCW8wEL1BS87A) <GiuseppeChillemi (GiuseppeChillemi)>:
The mobile app has deleted my link.
Here is the [code](https://gist.github.com/GiuseppeChillemi/8bd833ba511af556ae135474088dda06). 

[13:08:04](#7Y4ihRf9o9LDpzIh_3-BhxmKoLcAvjUMNo1Jvh9xbqQ) <GiuseppeChillemi (GiuseppeChillemi)>:
I have done extensively tests, profiling each part of the code. The following sections are the most time consuming parts:

```
[
			
			out-data: copy []
			
			forall keys-to-write [ 
				append out-data reduce [
					either datatype = object! [to-set-word :keys-to-write/1][:keys-to-write/1] 
					none
				]
			]

			err: "Error creating datatype"
			either attempt [out-data: make datatype out-data]	[go-on?: true] [go-on?: false]
		]
	]
	;Intead of the previous code, an empty container should used

;	if go-on? [
;		target-keys: words-of out-data		
;		data-keys: words-of data
;		
;		go-on?: contains? data-keys keys-to-pick 
;	] 

[13:10:07](#08hvzHIOq22NfS4Zu_fDobMsVpREJheUrq5_LufZvKo) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have done extensively tests, profiling each part of the code. The following sections are the most time consuming parts:

```

;---------- Loop for creating the output container			
out-data: copy []

forall keys-to-write [ 
	append out-data reduce [
		either datatype = object! [to-set-word :keys-to-write/1][:keys-to-write/1] 
		none
	]
]

err: "Error creating datatype"
either attempt [out-data: make datatype out-data]	[go-on?: true] [go-on?: false]
	
	
;--------- Loop to check if all the keys required are in the source

if go-on? [
	target-keys: words-of out-data		
	data-keys: words-of data
	
	go-on?: contains? data-keys keys-to-pick 
] 


```

[13:11:19](#VL1iLGZqrCUJQnyrobcS4M597cvCr_XYOlP-a2kqD1o) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have done extensively tests, profiling each part of the code. The following sections are the most time consuming parts:

```

;---------- Section for creating the output container			
out-data: copy []

forall keys-to-write [ 
	append out-data reduce [
		either datatype = object! [to-set-word :keys-to-write/1][:keys-to-write/1] 
		none
	]
]

err: "Error creating datatype"
either attempt [out-data: make datatype out-data]	[go-on?: true] [go-on?: false]
	
	
;--------- Section to check if all the keys required are in the source

if go-on? [
	target-keys: words-of out-data		
	data-keys: words-of data
	
	go-on?: contains? data-keys keys-to-pick ; <--- This is: exclude a b [
] 


```

[13:11:46](#RMe0UEUAwaJzT7GugPeOUPMEK9xo7J5rqQuin_jjQeQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have done extensively tests, profiling each part of the code. The following sections are the most time consuming parts:

```

;---------- Section for creating the output container			
out-data: copy []

forall keys-to-write [ 
	append out-data reduce [
		either datatype = object! [to-set-word :keys-to-write/1][:keys-to-write/1] 
		none
	]
]

err: "Error creating datatype"
either attempt [out-data: make datatype out-data]	[go-on?: true] [go-on?: false]
	
	
;--------- Section to check if all the keys required are in the source

if go-on? [
	target-keys: words-of out-data		
	data-keys: words-of data
	
	go-on?: contains? data-keys keys-to-pick ; <--- This is: exclude a b 
] 


```

[13:17:40](#A3ejBvEGkQoh3FvXvz7QWdsZ63pKVPccllUMyk4MLCU) <GiuseppeChillemi (GiuseppeChillemi)>:
So the best optimization is to remove che check if keys and wrap the write routine inside a:

`error? try [loop here]`

And if generates an error, checks the keys only when the error fires.
Also, the target container (`map!` or `object!`) but be already created and reused at each run
The other checks give 10% mask of speed gain, but there 2 are more than 60%


[13:26:47](#DbOgrbKNSDXjefszJvAgL6_9ErdOdyiPQRo6J34ONqs) <GiuseppeChillemi (GiuseppeChillemi)>:
These are the changes for each optimization:

```
;--- Results
;Full: 0:00:01.37004 																				;The base function
;Typeset: 0:00:01.34702																			;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276														;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894										;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221										;No check if keys exists
;Fast: 0:00:00.174525
```


[13:31:27](#J-ts_pT3k8O_urtKZkOOM6xCOwjSuhgfHsgn2OkGN8I) <GiuseppeChillemi (GiuseppeChillemi)>:
* These are the changes for each optimization:

```
;
;--- Results (Note, they are not cumulative, the reference is the FULL version)
;Full: 0:00:01.37004 							;The base function
;Typeset: 0:00:01.34702							;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276					;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894				;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221				;No check if keys exists
;Fast: 0:00:00.174525							;Just the loop and everything external

```

[13:31:55](#RTXLVlVmIQfVrjR8qP86gtrp67QhSOO_M01zbSewqrk) <GiuseppeChillemi (GiuseppeChillemi)>:
* These are the changes for each optimization:

```
;
;--- Results (Note, they are not cumulative, the reference is the FULL version)
;Full: 0:00:01.37004 						;The base function
;Typeset: 0:00:01.34702						;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276					;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894				;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221				;No check if keys exists
;Fast: 0:00:00.174525							;Just the loop and everything external

```

[13:32:15](#DUY8ZSYdXjOzU_OsGIoN3CJ46sORvfQPPa65RQ-kBhc) <GiuseppeChillemi (GiuseppeChillemi)>:
* These are the changes for each optimization:

```
;
;--- Results (Note, they are not cumulative, the reference is the FULL version)
;Full: 0:00:01.37004 						;The base function
;Typeset: 0:00:01.34702						;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276				;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894				;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221				;No check if keys exists
;Fast: 0:00:00.174525							;Just the loop and everything external

```

[13:32:25](#bsq2N8u2HITRQ8z0Ai49-rfJ9slTA2Eebq_QmIbIX1w) <GiuseppeChillemi (GiuseppeChillemi)>:
* These are the changes for each optimization:

```
;
;--- Results (Note, they are not cumulative, the reference is the FULL version)
;Full: 0:00:01.37004 						;The base function
;Typeset: 0:00:01.34702						;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276				;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894				;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221				;No check if keys exists
;Fast: 0:00:00.174525						;Just the loop and everything external

```

[13:33:11](#RAzdeXybSQ94pjBQ5cqeABLUwSXVRS0o9WqCFFNyB1g) <GiuseppeChillemi (GiuseppeChillemi)>:
* These are the changes for each optimization:

```
;
;--- Results (Note, they are not cumulative, the reference of the next
;  one  is the FULL version)
;Full: 0:00:01.37004 						;The base function
;Typeset: 0:00:01.34702						;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276				;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894				;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221				;No check if keys exists
;Fast: 0:00:00.174525						;Just the loop and everything external

```

[13:38:51](#keXtsY451p8bPQURSgmJWc9cAU-RD015vh_iUtfDcL8) <GiuseppeChillemi (GiuseppeChillemi)>:
* These are the changes for each optimization:

```
;
;--- Results (Note, they are not cumulative, the reference of the next
;  one  is the FULL version)
;Full: 0:00:01.37004 						;The base function
;Typeset: 0:00:01.34702						;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276				;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894				;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221				;No check if keys exists
;Fast: 0:00:00.174525						;Just the loop and everything external

```

I have also updated the GIT with all the versions

[14:55:18](#yYQp_PyeKEuQakKj8c8Gvf1XFfTrCchgVV0LSn9OPEQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* These are the changes for each optimization:

```
;
;--- Results (Note, they are not cumulative, the reference of the next
;  one  is the FULL version)
;Full: 0:00:01.37004 						;The base function
;Typeset: 0:00:01.34702						;Changed parse of multiple datatypes with forall
;Typeset-type-forall: 0:00:01.276				;   As before + change of parse of for WORD! keys with a forall [word? key] 
;Typeset-type-passed-keys: 0:00:01.28894				;The keys are passed and not extracted
;Typeset-type-external-out-data-container: 0:00:01.04831		;The target container is created externally and reused. On exit you copy it
;extract-keys-no-contains: 0:00:01.00221				;No check if keys exists
;Fast: 0:00:00.174525						;Just the loop and everything external

```

I have also updated the GIST with all the versions

[18:33:48](#xZhIwGMlci14nM_aDCzYAsEfn1YHozcyY2-k4QjmwAk) <hiiamboris>:
A lot of code and I can't even tell what is its purpose. Or what these benchmarks were supposed to tell us. Given that the functions are very far from being optimized anyway.

[20:16:17](#1qXk9-6lE6U-cit0oOlLKFI_gwhvkr4CP-ENql5Gr_g) <greggirwin (Gregg Irwin)>:
I apprciate you sharing it GiuseppeChillemi (GiuseppeChillemi) , and that the benchmark can be copied and run, without needing other code. But it also has some logic very specific to implicit data structures (`extract/index keys 2 2`), so it's hard to see it as a general approach. 

[20:16:33](#BFEJKGcn32NLSBxHfXUuIp-isSOkzZunz-KDS9u0XiI) <greggirwin (Gregg Irwin)>:
* I appreciate you sharing it GiuseppeChillemi (GiuseppeChillemi) , and that the benchmark can be copied and run, without needing other code. But it also has some logic very specific to implicit data structures (`extract/index keys 2 2`), so it's hard to see it as a general approach.

[21:11:56](#CQXcnErQccFmkDcXgHRnam8lBhNLYXRoAQ21UQcE2X4) <GiuseppeChillemi (GiuseppeChillemi)>:
The code extract some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:
`#[a: 22 #b: 33 c: 44 .....]` 
and you request `a` and `b`, you must create a target container with these keys and their values.
The test aims to show that if you create the target container inside the function, your code goes at about 35% slower than passing the container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`. 
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function.

[21:12:09](#uqh4eZmemt-2-OemN_NdrzchLlUvEQurrv4QC7KBWRw) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:
`#[a: 22 #b: 33 c: 44 .....]`
and you request `a` and `b`, you must create a target container with these keys and their values.
The test aims to show that if you create the target container inside the function, your code goes at about 35% slower than passing the container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function.

[21:12:33](#hNstoY0xU4viFOQ9ji_hMcw3PcwLRrHnnC_uRVfSUlg) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 #b: 33 c: 44 .....]
``
`
and you request `a` and `b`, you must create a target container with these keys and their values.
The test aims to show that if you create the target container inside the function, your code goes at about 35% slower than passing the container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function.

[21:12:39](#RAER2CAZVX6ZWYQFJ_5Q9CrU1q6k3tjEugkHwfXE8Aw) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 #b: 33 c: 44 .....]
```
and you request `a` and `b`, you must create a target container with these keys and their values.
The test aims to show that if you create the target container inside the function, your code goes at about 35% slower than passing the container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function.
```

[21:12:49](#oc4TyG0m98JrpWm2ntXH6Sf0J6rgDDjgUFb9Ztb3lh0) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 #b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.
The test aims to show that if you create the target container inside the function, your code goes at about 35% slower than passing the container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function

[21:13:20](#9itKy3N6g7ERooWXdjHM0M18hUXc1Wa7Eyzv3PvxZ2Q) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 #b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.
```
#[a: none #b: none]
```

The test aims to show that if you create the target container inside the function, your code goes at about 35% slower than passing the container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function

[21:13:55](#XNMmYZe5f6Y9h3V4n_fUxmqFovEgme7pX-s7m-vM9I0) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code goes at about 35% slower than passing the container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function

[21:14:39](#MvOv3wJpAaXP0goXS6DiBrdpYqIulI_GgtWlRfAagrk) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is providing the container and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function

[21:15:18](#CkjXq8sm4DpnFHsoYIA0bFM4P3vshaBeMq_ePYSHLR0) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words `[source-key1 dest-key1 source-key2 dest-key2`, for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function

[21:15:47](#N-bg8WYi3DkscMM8sKaZz_ID_WbaXLfJYTjLrkSsUSw) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words 

```
[source-key1 dest-key1 source-key2 dest-key2
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function

[21:15:56](#1DLw_XLbDsxcWJ8jcmTQLOyEAcSp2CV7pBB24PUyGjg) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words

```
[source-key1 dest-key1 source-key2 dest-key2]
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container. This latter and the former code, take up to 70% of the CPU cycles. The correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function

[21:18:18](#Dzq-cAQDwZwGKzL1arQBLyxPpcg4NshPCnPD8Hqzx8k) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words

```
[source-key1 dest-key1 source-key2 dest-key2]
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container:
```
[dest-key1: none dest-key2: none]
```
Values will be take from the other keys.

This latter and the former code, take up to 70% of the CPU cycles. 

The conclusion is simple: the correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function. The Rebol3 way if the one to choose.

[21:19:30](#ewVd56RAzcvndkpJ3qDudl-d9G7XHFVOBg9Ea9hzC04) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words

```
[source-key1 dest-key1 source-key2 dest-key2]
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container:

```
#[dest-key1: none dest-key2: none]
```

Values will be take from the other keys.

This latter and the former code, take up to 70% of the CPU cycles.

The conclusion is simple: the correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function. The Rebol3 way if the one to choose.

[21:20:06](#tKj2TRc4xPSaCgfJP7AnN0wlVI1Q8Mg_beEwlxGVl9g) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words

```
[source-key1 dest-key1 source-key2 dest-key2]
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container:

```
#[dest-key1: none dest-key2: none]
```

Values will be take from the other keys.

This latter and the former code, take up to 70% of the CPU cycles.

The conclusion is simple: the correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function. The Rebol3 way is the one to choose.

[21:27:33](#46VbhNfWZXjJF-iwqWMbX_Mrp1ql7FjIFiAcJDbtHD0) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words

```
[source-key1 dest-key1 source-key2 dest-key2]
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container:

```
#[dest-key1: none dest-key2: none]
```

Values will be take from the other keys.

This latter and the former code, take up to 70% of the CPU cycles.

The conclusion is simple: the correct way of creating such functions is to put each container creation on the outside, until Red will not be able, like Rebol3, to accept an external context for the called function. The Rebol3 way is the one to choose.

[21:29:56](#RhQ8vOmHG6YDDM6pm5UcDM-AIja_nXSfdR9CiPpObtA) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words

```
[source-key1 dest-key1 source-key2 dest-key2]
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container:

```
#[dest-key1: none dest-key2: none]
```

Values will be take from the other keys.

This latter and the former code, take up to 70% of the CPU cycles.

The conclusion is simple: the correct way of creating such functions is to put each container creation on the outside, until Red will not be able, to accept an external context for the called function at each run using `apply` or a refinement. (Rebol 3 accepts the `SELF` context only at function setup)

[21:33:57](#owcmIYe4Jv1mT8tBV449er0o9kGxTxjoB1zgOOMgiqE) <GiuseppeChillemi (GiuseppeChillemi)>:
* The code extracts some keys from a `map!` or `object!` container, creating another one, the result, with just the key requested and their values. So, if you have:

```
#[a: 22 b: 33 c: 44 .....]
```

and you request `a` and `b`, you must create a target container with these keys and their values.

```
#[a: none b: none]
```

The test aims to show that if you create the target container inside the function, your code speed is  about 35% slower than passing the passing and reusing container at each function call. So, the correct style for function that needs strict loop optimization, is creating it externally and reusing it with `copy`.
Also, the function accepts couples of words

```
[source-key1 dest-key1 source-key2 dest-key2]
```

for creating asimetric keys. In this case, the function uses `keys-to-write: extract/index keys 2 2` to get the keys and create the target container:

```
#[dest-key1: none dest-key2: none]
```

Values will be take from the other keys.

This latter and the former code, take up to 70% of the CPU cycles.

The conclusion is simple: the correct way of creating such functions is to put each container creation on the outside, until Red will not be able, to accept an external context for the called function at each run using `apply` or a refinement. (Rebol 3 accepts the `SELF` context only at function setup)

[21:59:01](#gdgMi8zC6ea4j7GHX4DL2Mh1Ex6qlfaboAw99EHZP4A) <GiuseppeChillemi (GiuseppeChillemi)>:
Oldes: I have tested Rebol3. `Funct` accepts a `self` with default values, at creation and not at runtime. 

Here it is without function args
```
>> f: funct/with [] [probe a probe b] context [a: 22 b: 33]
>> f
22
33
== 33
```
Here with one arg set
```
>> f: funct/with [a] [probe a probe b] context [a: 22 b: 33]
>> f 44
44
33
== 33
```

[22:00:11](#rgtqYiUZYrLJt6_z6J1i51hI3PHpduvNvveuCFSwLNE) <GiuseppeChillemi (GiuseppeChillemi)>:
It would be nice if we can do:

```
>> f/with ctx-here

** Script error: f has no refinement called with
```


[22:00:22](#jJd6B9aK6Na_lh6S9I6QGqumfcsV0aHr20E8pa1EY3w) <GiuseppeChillemi (GiuseppeChillemi)>:
But as you can see it does not work

[22:49:50](#-ApCphypfgJ9tWx4i9lh8vWer7PSAUDPZddlmcdXIrw) <greggirwin (Gregg Irwin)>:
`funct` is a mezzanine in R3, so you can reimplement it in Red if you want.

[22:58:21](#caokiuM0bLwXLMH5gat_ZR2M8y8E-U1S-raoJfKqcl4) <GiuseppeChillemi (GiuseppeChillemi)>:
I am almost there but for speed it must be native

## 9-Feb-2025

[10:11:12](#A4bEHSmXWJEivIwtBGXKzeZIaNczfpU0YOZir30uQi8) <hiiamboris>:
I think if you want it optimize it you have to split its logic case by case, e.g. `object to object`, `map to map`, `object to map` and `map to object`, because of the profound differences in `make` behavior of these types.

[10:37:39](#rFzWQFtyIYWD7piecgfIIoIriFQx50RO3SPDhQwZ2uM) <hiiamboris>:
* I think if you want to optimize it you have to split its logic case by case, e.g. `object to object`, `map to map`, `object to map` and `map to object`, because of the profound differences in `make` behavior of these types.

[12:02:50](#p9NfSpGaXnav1jgEm4j63I3_qf8QQTptlh_FkTf0ucc) <GiuseppeChillemi (GiuseppeChillemi)>:
Which differences are you referring to? The collection of keys values and execution of code that happens with object or there are important others you want to mention? 

[12:15:10](#e2vYJ1TWb8kqNJj-nOvoKU3q4M04PeRU0yuDJ16rjPM) <GiuseppeChillemi (GiuseppeChillemi)>:
* Which differences are you referring to? The collection of keys values and execution of code that happens only with objects or are there important others you want to mention? 

[12:35:48](#lzMSWhgC89kwEH7z9vWW84SA0TPQr62P370_SaNQWUc) <hiiamboris>:
Yes, that and the collection of set-words, even by `costruct`.

[12:35:50](#VeZLi7POq_pxlYLSdkGLUW4j5efUqCm5xtG1UOEqg0k) <hiiamboris>:
* Yes, that and the collection of set-words, even by `construct`.

## 21-Mar-2025

[16:25:49](#QMmQw2Piis-yi41wtOXqh2sr3gDFl-So40CXw7KquT8) <GiuseppeChillemi (GiuseppeChillemi)>:
`none` as result limits me when selecting a key. I returns that informs me when there is no key, other when I have selected a key with `#(none)` as value. I have thought about using a container element with `none` and also additional information and how much times it takes to check this "powered" `none` as result. 
I have tried with `map` using different methods and datatypes. Do you have a suggestion for the best one to use? Or a similar approach? I would like some container datatype which is not so common to be used as `map!`, `block` or `object!`, so a low frequency one.

Here are my first tests:

```

f1: func [
] [
	x: select #[a: 22] 'b
	if none? x  [
		[none]
	]
]

f2: func [
] [
	x: select #[a: 22] 'b
	if none? x [
		[#none no-key]	
	]
]

f3: func [
] [
	x: select #[a: 22] 'b
	if none? x [
		#[#none no-key]	
	]
]

recycle/off 


times: 100000

probe dt [
	loop times [
	 	x: f1
	 	if none? x []
	]
]

probe dt [
	loop times [
	 	x: f2
	 	if block? x [if none? x/1 []]
	]
]

probe dt [
	loop times [
	 	x: f3
	 	if map? x [if find x #none []]
	]
]

probe dt [
	loop times [
	 	x: f3
	 	if map? x [if reason: x/#none []]
	]
]
```

[16:26:20](#awShgxdEL4hg5-D7kQEPtbzMvk5_NCUaiBwFxQdmIGY) <GiuseppeChillemi (GiuseppeChillemi)>:
Here are the timings:
```
0:00:00.145874
0:00:00.196482
0:00:00.180444
0:00:00.171704
```

[16:27:18](#QcUMQwoEK17phYXW783k25aHVYccgOsJadB5N9FRCw0) <GiuseppeChillemi (GiuseppeChillemi)>:
The  "extended" `none` aproach is about 30% slower than native `none!`. How could I get near it as speed?

[16:32:29](#rY5WInBO26oXbegHWYHoiAFkDjSZYJhpf4nEMXh7eBA) <hiiamboris>:
you can always use `find` to check if key is in the map or not

[17:02:31](#Sttr0M9QvrhC-q7SgomTTDz1AwvDEmNsj9qIflFqD7s) <GiuseppeChillemi (GiuseppeChillemi)>:
Here it is in F3 `if map? x [if find x #none []]` but I would like a sencondary low frequency datatype

[17:07:32](#K1Pd2Roamu_erWNGOcK_2Jxlp0ubbf0qkTMAd-xF2RM) <hiiamboris>:
that's not what I proposed

[17:17:34](#xZU40lA7GKWk0FhM5ZqvyZPGdzWr1ILXwM3Nw5Av4DA) <Oldes (@oldes.h:matrix.org)>:
For me the times are almost identical... here are results from R3:
```
Running 4 code blocks 1000 times.
----------------------------------------------------------------------------------------------------------
Time               | Evals  | S.made | S.expa | Memory      | Code
1.0x (1Œºs)         | 18     | 0      | 0      | 0           | [x: f2 if block? x [if none? x/1 []]]
1.13x (1Œºs)        | 20     | 0      | 0      | 0           | [x: f3 if map? x [if find x #none []]]
1.15x (2Œºs)        | 19     | 0      | 0      | 0           | [x: f3 if map? x [if reason: x/#none []]]
1.31x (2Œºs)        | 14     | 0      | 0      | 0           | [x: f1 if none? x []]
----------------------------------------------------------------------------------------------------------
```
When I consider how inefficient code you usually write....

[17:19:09](#vEgP0W_k9AiaVrhTPKCMn3wS9Z8P-Hj-sSQSBjhKBFE) <Oldes (@oldes.h:matrix.org)>:
Not to mention, that your `f*` functions are wrong.

[17:20:20](#8Af8RcNt1WVpOlg-ncOmef9It0tiRD6q7I9zQKNBk7U) <Oldes (@oldes.h:matrix.org)>:
For example `f1` never returns block with a `#(none)` value, but block with a `none` word.

[17:22:45](#dJe47qjCnj3OloTuOJJl7Q3zqbf6kgJjcpcZoIyD8tU) <Oldes (@oldes.h:matrix.org)>:
When I fix `f1` function, and don't use a debug build, my results are:
```
Running 4 code blocks 1000 times.
-------------------------------------------------------------------------------------------------------
Time               | Evals  | S.made | S.expa | Memory      | Code
1.0x (1Œºs)         | 14     | 0      | 0      | 0           | [x: f1 if none? x []]
1.06x (1Œºs)        | 18     | 0      | 0      | 0           | [x: f2 if block? x [if none? x/1 []]]
1.11x (1Œºs)        | 19     | 0      | 0      | 0           | [x: f3 if map? x [if reason: x/#none []]]
1.19x (1Œºs)        | 20     | 0      | 0      | 0           | [x: f3 if map? x [if find x #none []]]
-------------------------------------------------------------------------------------------------------
```

[17:23:26](#p5XNcpRMaUsYn_TaGNCeCaG6CZm8jesM3pMEFPqxgt4) <Oldes (@oldes.h:matrix.org)>:
Which is logical.. more evaluations means slower execution.

[17:30:49](#X2e9i2t001NWeQKzpYMZfzO3Knc_N7Vpj32K2WQSORo) <Oldes (@oldes.h:matrix.org)>:
GiuseppeChillemi (GiuseppeChillemi): in your code you should not do check on none in your `f` function, but instead test if key exists in the map only when the value is none. (if what you want is to differentiate none value from a non existing value)

[17:32:31](#S_CKXCJowOv5b15EGU0uBQaXZnPDf1fF2VpYtsHLmrc) <Oldes (@oldes.h:matrix.org)>:
Than you will save a lot of condition tests, because usually there will be some value.

[18:29:47](#GfCc_cprvjTy8Ft9ym76LrRkN3aNU1zHwZ7eOppWpDg) <gurzgri>:
GiuseppeChillemi (GiuseppeChillemi) Whatever hardcoded obfuscated `#(none)` replacement you decide on beforehand can't *logically* avoid that this value occurs in some future data, at best it can minimize probilities.

I'd suggest for an approach where the callee supplies a "miss-marker value" which is garanteed to not occur in the data. Using an object or a series value created outside of the data together with an test on sameness makes this easy:

```
make-retriever: func [miss] [reduce [
	func [value] compose [same? (miss) value]
	func [data key] compose/deep [any [
		select data key
		unless find data key [(miss)]
	]]
]]

stuff: #[one: [none] two: [#(none)] three: [#none no-key] four: #[#none no-key]]

set [miss? fetch] make-retriever miss: object []

foreach key [one three five] [probe pick [miss hit] miss? fetch stuff key]
```

[18:30:12](#ILQ9K4cvJSsndZ8cEfpLPLYydLPeMtlmIjaO7YAHReY) <gurzgri>:
* GiuseppeChillemi (GiuseppeChillemi) Whatever hardcoded obfuscated `#(none)` replacement you decide on beforehand can't _logically_ avoid that this value occurs in some future data, at best it can minimize _probabilities_.

I'd suggest for an approach where the callee supplies a "miss-marker value" which is garanteed to not occur in the data. Using an object or a series value created outside of the data together with an test on sameness makes this easy:

```
make-retriever: func [miss] [reduce [
	func [value] compose [same? (miss) value]
	func [data key] compose/deep [any [
		select data key
		unless find data key [(miss)]
	]]
]]

stuff: #[one: [none] two: [#(none)] three: [#none no-key] four: #[#none no-key]]

set [miss? fetch] make-retriever miss: object []

foreach key [one three five] [probe pick [miss hit] miss? fetch stuff key]
```

[18:30:36](#n6Nkpgx0p3uCiIl7e_5ffrFrRJxdJds8tpmJY4FqWEs) <gurzgri>:
* GiuseppeChillemi (GiuseppeChillemi) Whatever hardcoded obfuscated `#(none)` replacement you decide on beforehand can't _logically_ avoid that this value occurs in some future data, at best it can minimize _probabilities_.

I'd suggest an approach where the callee supplies a "miss-marker value" which is garanteed to not occur in the data. Using an object or a series value created outside of the data together with an test on sameness makes this easy:

```
make-retriever: func [miss] [reduce [
	func [value] compose [same? (miss) value]
	func [data key] compose/deep [any [
		select data key
		unless find data key [(miss)]
	]]
]]

stuff: #[one: [none] two: [#(none)] three: [#none no-key] four: #[#none no-key]]

set [miss? fetch] make-retriever miss: object []

foreach key [one three five] [probe pick [miss hit] miss? fetch stuff key]
```

[18:34:52](#ubP7lbcgw4TA6W-2DyLKZzw43PrNgCRIav8tDC5MQd4) <gurzgri>:
* GiuseppeChillemi (GiuseppeChillemi) Whatever hardcoded obfuscated `#(none)` replacement you decide on beforehand can't _logically_ avoid that this value occurs in some future data, at best it can minimize _probabilities_.

I'd suggest an approach where the callee supplies a "miss-marker value" which is garanteed to not occur in the data. Using an object or a series value created outside of the data together with an test on sameness makes this easy:

```
make-retriever: func [/local miss] [miss: make object! [] reduce [
	func [value] compose [same? (miss) value]
	func [data key] compose/deep [any [
		select data key
		unless find data key [(miss)]
	]]
]]
stuff: #[one: [none] two: [#(none)] three: [#none no-key] four: #[#none no-key]]
set [miss? fetch] make-retriever
foreach key [one three five] [probe pick [miss hit] miss? fetch stuff key]
```
(code simplified)

[18:39:43](#AzULBxoID0-PMM4jB2MvHSIvYayFmQa4HDoHqm6qMog) <greggirwin (Gregg Irwin)>:
Maps exist for this very behavior, to be forgiving in the face of missing data and "unseen" keys. Also why you can check for keys if needed.

[18:41:47](#5P-legOB7t7-qhfM0n1hbVRPd64VwZwuDdBEYUZhsds) <gurzgri>:
GiuseppeChillemi (GiuseppeChillemi) `none` not being able to discern between the legit value of an existing key and the answer when asking for an absent key btw is pretty much the same problem in the `error? try [...]` approach you do not know if an error returnd is the legit result of the try block execution or an error happing during excution.  

[18:42:15](#eNz__7q2p2a5db_trXLWnKr4d66vzQHs0InjdkxUHQo) <gurzgri>:
* GiuseppeChillemi (GiuseppeChillemi) `none` not being able to discern between the legit value of an existing key and the answer when asking for an absent key btw is pretty much the same problem as the `error? try [...]` approach has where you do not know if an error returned is the legit result of the try block execution or an error happing during excution.

[19:11:57](#L-ys4Mk_4tGksHkZ4qyGE79DFVzpaM34zj1gSdwlu94) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes and it is the problem I am trying to solve in the minimum number of cycles

[19:12:35](#O49n3WcdMpYyH_6ie1w0OaHiTJxsjco6fTDNQf3YJWI) <GiuseppeChillemi (GiuseppeChillemi)>:
(I am on mobile, I will read you later)

[21:01:05](#MsVhbPkoSo1WMVJIJaQwHMbgJh9r90xNxaJO6CskIks) <Oldes (@oldes.h:matrix.org)>:
You should be aware, that `try` and `attempt` are CPU expensive functions. Here is comparison of a selection from map and object which recognizes if the value really exists:
```
select-from-object: func[obj key][
	any [attempt [obj/:key] #NULL]
]
select-from-map: func[map key][
	any [map/:key either find map :key [none][#NULL]]
]

o: make object! [a: 1]
m: make map!    [a: 1]
```
With these results using R3's profile:
```
Time               | Evals  | S.made | S.expa | Memory      | Code
1.0x (2Œºs)         | 12     | 0      | 0      | 0           | [select-from-map m 'b]
7.34x (18Œºs)       | 8      | 2      | 0      | 832         | [select-from-object o 'b]
```

[21:02:13](#eM7mGLaVCYvyn9DQ3EQbsCWmkJ1bdorH4yl0-WWgj3U) <Oldes (@oldes.h:matrix.org)>:
And using an existing value:
```
Time               | Evals  | S.made | S.expa | Memory      | Code
1.0x (727ns)       | 5      | 0      | 0      | 0           | [select-from-map m 'a]
1.46x (1Œºs)        | 7      | 0      | 0      | 0           | [select-from-object o 'a]
```

[21:04:39](#8fhTysvT9xj8ItsUhzEYRgjjkCFLkDJzoIg8X6RnFEQ) <Oldes (@oldes.h:matrix.org)>:
In R3 I could make the object version a little bit faster with:
```
select-from-object-v2: func[obj key][
	try/with [obj/:key][#NULL]
]
```

[21:05:12](#_GwfyQFTUpwfxb9hFJysmHrvFLjyWzZZkQZc_ZOkDgU) <Oldes (@oldes.h:matrix.org)>:
```
1.0x (9Œºs)         | 7      | 2      | 0      | 800         | [select-from-object-v2 o 'b]
1.43x (13Œºs)       | 8      | 2      | 0      | 832         | [select-from-object o 'b]
```

[21:19:04](#-nOKq8kU0s2cO5HpnKuX3UZELdWvXsSwOF-Ux6IDMnQ) <gurzgri>:
Most likely a misinderstanding, I was nowhere near to suggesting to use `try` or `attempt` for Giuseppe‚Äôs use case but rather explaining the conceptual similarity of problematic ambigue return values.

[21:19:24](#IaH0ezRkOhfH7xrh3d2B-YkLoNEgDyQop1ouKYx6J1M) <gurzgri>:
* Most likely a misunderstanding, I was nowhere near to suggesting to use try or attempt for Giuseppe‚Äôs use case but rather explaining the conceptual similarity of problematic ambigue return values.

[21:20:00](#C8QnBHYUt0I1Itr6CRC8XHE0gCOENKXfoQGc3Gut8kM) <gurzgri>:
* Most likely a misunderstanding, I was nowhere near to suggesting to use try or attempt for Giuseppe‚Äôs use case but rather pointing out the conceptual similarity of problematic ambigue return values.

[21:27:13](#RrSkL_FXljcW8wnesTEjO6-EFATy2fcbJ4Vt560dUYQ) <Oldes (@oldes.h:matrix.org)>:
Yes... I just wanted to demonstrate, that these functions must be used with care!

[21:31:39](#DDP0kaatPXL8WqW6hUMqomLZrkn5eXRO2pV3SbsMZ1k) <Oldes (@oldes.h:matrix.org)>:
For completeness one can make also selection from object using:
```
select-from-object-v3: func[obj key][
	any [select obj :key either find obj :key [none][#NULL]]
]
```
which is on par with map in this very simple test where is just one key in map/object:
```
Time               | Evals  | S.made | S.expa | Memory      | Code
1.0x (1Œºs)         | 12     | 0      | 0      | 0           | [select-from-map m 'b]
1.3x (1Œºs)         | 14     | 0      | 0      | 0           | [select-from-object-v3 o 'b]
6.55x (7Œºs)        | 7      | 2      | 0      | 800         | [select-from-object-v2 o 'b]
7.12x (8Œºs)        | 8      | 2      | 0      | 832         | [select-from-object o 'b]
``` 

[21:35:35](#0ilb5AMVgJ6hb_o0yXLuBjYXxxeLf0PB_iyADjgOSLs) <Oldes (@oldes.h:matrix.org)>:
When HF will read this chat, he will write some blogs about his _antiforms_ which he can return directly from select instead of cheating with `#NULL` like in examples above :-)

[21:36:53](#s9h-1YYIFrLp60L82RVo2JS9D2hzV0qmD9R9lHcidus) <Oldes (@oldes.h:matrix.org)>:
But to be honest... one must detect and handle this not existing value anyway, so....

[23:29:59](#BsW7-d5-iSmsP2xcB2KVw3qhGTO3mqWkT_ZR4aMLZmA) <GiuseppeChillemi (GiuseppeChillemi)>:
Are you talking about this? `if find x #none []` The map is a return value and must be checked as it can be any other datatype. But if I have not understood correctly, please make me an example

[23:31:32](#sv1R4kkpdrFSI2pY-V6TYzKcigttbYF-N0VSHLxzpwM) <GiuseppeChillemi (GiuseppeChillemi)>:
I know you love my code but I write first to define a model then we can talk about speed.

[23:33:23](#EgrCvKwEqyB9ibxhR6fRIApm_gv1WBJY3HIHwNwiOQA) <GiuseppeChillemi (GiuseppeChillemi)>:
It has been made on purpose to see how different is having it on the first aliment of a block than as a key in a map. I forgot just to add the simple `none` without any block.

[23:34:34](#Js20SZmX_q_Te_9r47x8O_wgVfW26q9VPjny6EWhsP4) <GiuseppeChillemi (GiuseppeChillemi)>:
And that was the purpose of the test. Seen how many cycle each one it takes and which is the difference.

[23:47:13](#lXTk3NUmratTacsBGrAMW6XM_KUtXLk6Nc495ACtZj8) <GiuseppeChillemi (GiuseppeChillemi)>:
I need a multi state return. I want to shorten my code and I am experimentig.

[23:52:36](#xvZ8GNUMuvg6_JyI5S3Xzo6Xw0ZjpaeIPvgwJA4cp_c) <GiuseppeChillemi (GiuseppeChillemi)>:
Look at here:
```
vid-options: make object! [size 500x200 actors: [on-change [] on-resize []]
actors: key-select vid-options 'actors [block! object! map!]
```
This does a double check: key existence and key value datatype. I need to differentiate 4 states:
1) no key
2) wrong datatype
3) all the other values, including `none`


[23:53:41](#Kblg8zfkz7pHaKNJ0Yr84dwEGnvROrTC3dy0PLoS0_c) <GiuseppeChillemi (GiuseppeChillemi)>:
As you can see the code is really space efficient as in 1 line you make all the usual check steps for a key and its content.

[23:58:19](#_OP97-dPpBZ6zCZrgLPYnmW0pfQal1X662TwYKuDS_k) <GiuseppeChillemi (GiuseppeChillemi)>:
One usage is the following:
```
actors: key-select vid-options 'actors [block! object! map!]
switch actors [
  no-key [do something]
  wrong-dt [do something]
  all-the other [do something]
]
```

## 22-Mar-2025

[0:00:14](#GbYqmSRMwt32fy_3waWiNOm230xgk2AawDs78aOtiWo) <GiuseppeChillemi (GiuseppeChillemi)>:
Another usage is in all:
```
all [
  actors: key-select vid-options 'actors [block! object! map!]
   size: key-select vid-options 'size [block! object! map!]
]
```

[0:00:22](#pwQAJQzxNgO5LwMJBqOKaPMxrXkRyA8Skg-4LWJBAGA) <GiuseppeChillemi (GiuseppeChillemi)>:
* Another usage is in all:

```
all [
  actors: key-select vid-options 'actors [block! object! map!]
  size: key-select vid-options 'size [block! object! map!]
]
```

[0:00:54](#5uvvbLxXRR0Yz_II6atISCgOpimP14EJnazgdY7czug) <GiuseppeChillemi (GiuseppeChillemi)>:
But in this case , I can't use a MAP! as `none` meaning

[0:01:08](#77H6tH4CPXXT4qodUXCkmAUBkDpb-HeBD57oGCixqJc) <GiuseppeChillemi (GiuseppeChillemi)>:
So I am trying to find solutions

[0:02:02](#O94MzzHrrc35Kg5dYB9JL-xUj12KAHs9ZlPkzIFu5Tc) <GiuseppeChillemi (GiuseppeChillemi)>:
One could be a refinement to manage errors, like your `try/with`

[0:03:59](#MndVK285modewEb4AllAi5zexs3DPDh1qWXJ4QVgi0E) <GiuseppeChillemi (GiuseppeChillemi)>:
In fact I have written "low frequency values". I would like to not use MAP because it is an high frequency one, expecially if you group them in a block and select them.

[0:12:42](#_Yds9q8UwddAbVn5UMjHCgjJQDRjITmpS7hXkqRGTYU) <GiuseppeChillemi (GiuseppeChillemi)>:
The idea is correct. Check for none and then for key existence.


[0:15:10](#sQn36rEzZkyTnvUf2RLif-l9eQLFpBJNqBN0nDMttm4) <GiuseppeChillemi (GiuseppeChillemi)>:
Also, today I thought about an extendend `none`, one carring extra information. But thinking now about it, I can't embedd it in datatypes like `map!` or `object!` because they won't work in short circuit functions.

[0:16:52](#LGpxdBdLNmgQeyu93x3L_7gBiTzqqR77n7fWVRsmzAw) <GiuseppeChillemi (GiuseppeChillemi)>:
We would need an `none` container. Like `#[none extra-info]`. This would solve any problem.

[0:17:31](#6BmvDo1yeV0f7lUtLEr4CFIR1qwrKYoXoNfU5SNowKc) <GiuseppeChillemi (GiuseppeChillemi)>:
So `#[none no-key]` `#[none type-mismatch]`

[0:19:40](#mrIAQQaRki0lPD6ubzaGAocGWlymiYDZfRS7_bZfuL0) <GiuseppeChillemi (GiuseppeChillemi)>:
* We would need an `none` container. Like `#(none extra-info)`. This would solve any problem.

[0:19:56](#SzfI5La3RBJCCYoS-NDXLxtBwO4-jip3dip1GyYQr3E) <GiuseppeChillemi (GiuseppeChillemi)>:
* So `#(none no-key)` `#(none type-mismatch)`

[0:20:49](#Biw_ldKS_rN5Hm2Rc-_RN0F5clZ6w_qUkO5Ez7VA4Jk) <GiuseppeChillemi (GiuseppeChillemi)>:
So you can short circuit and have extra info too. In this way you can:

[0:23:34](#WBih7IfJPUa5d99qiPRyXKicOUY5uqwJ7Od9WsiC_dY) <GiuseppeChillemi (GiuseppeChillemi)>:
So you can: 
```
if none? result: key-select [print ["Reason: " x/1]
```

[0:24:15](#BI_Wgh9j6NzEqvN849Hco2gMPn_rii0YW124p-a3wc8) <GiuseppeChillemi (GiuseppeChillemi)>:
* So you can:

```
if none? result: key-select container key [types] [print ["Reason: " x/1]
```

[0:26:11](#dvt54D2H7cfY410akwSWWV-g9L9z0zENsehektTw85Y) <GiuseppeChillemi (GiuseppeChillemi)>:
* So you can:

```
if none? result: key-select container key [types] [print ["Reason: " result/1]];
;Where result/1 let you access the extra data
```

[0:26:52](#JWjHtBLb1LL5rZgb_xY6ZTc-YR5Fls5fjE1uL6wmbis) <GiuseppeChillemi (GiuseppeChillemi)>:
* The idea is correct. Check for `none` and then for key existence.


[0:37:27](#K62VmAsODisqqlZl3cYatp2X29UlhvcN978Rm_BalO0) <GiuseppeChillemi (GiuseppeChillemi)>:
* We would need a `none` container. Like `#(none extra-info)`. This would solve any problem.

[0:37:51](#VxYbK5GepmX8wb9GuQp_uk9yKH2aMOy6awhlPRmQojQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* For example:  `#(none no-key)` `#(none type-mismatch)`

[0:38:03](#2_4oMkjr3WeMnhBAXjfzKDM1ltUfjYzm38_J6g7VmxY) <GiuseppeChillemi (GiuseppeChillemi)>:
* This is a possible application

```
if none? result: key-select container key [types] [print ["Reason: " result/1]];
;Where result/1 let you access the extra data
```

[5:29:46](#XFDLeHe7Ii1meMwW3g_IcSSz01GEqVXkNDvNbO6BLfs) <hiiamboris>:
By the way, apart from the key existence check maps also allow you to put unset as the value, which you can interpret as a missing key marker.

[5:30:27](#iKpe0udfaGekcpctIFLotm_2L7LXYNKKonTiaLoYNWU) <hiiamboris>:
Note that this will not work with `false`

[9:02:16](#uKEDedE5wOA6l5rnoK7EJijQRhCxwPt9Vo4QEFGB8Xk) <GiuseppeChillemi (GiuseppeChillemi)>:
The problem remains for ANY and ALL that needs NONE to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let KEY-SELECT fail with error and wrap the whole ANY/ALL body in TRY/ERROR. 
2) Use a carrier: 
ALL [
  KEY-SELECT/STATUS MAP 'KEY1 TYPES CTX
  KEY-SELECT/STATUS MAP 'KEY2 TYPES CTX
]

[9:08:25](#sVKXITgWMO_X3CEYuLUWNL3NkCB1L9V0s1pskRGAkOc) <GiuseppeChillemi (GiuseppeChillemi)>:
So CTX will be set when NONE, if different than NONE the second command will notice it and act, or at the end of the ANY block you can check the CTX content to know if an error has happened.

[9:08:52](#mH4CzT6_GwAb0kg65NSDjFAfuWx69DqMbdaiBjg60JA) <GiuseppeChillemi (GiuseppeChillemi)>:
* The problem remains for ANY and ALL that needs NONE to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let KEY-SELECT fail with error and wrap the whole ANY/ALL body in TRY/ERROR. 
2) Use a carrier: 
ALL [
  KEY-SELECT/STATUS MAP 'KEY1 TYPES STATUS
  KEY-SELECT/STATUS MAP 'KEY2 TYPES STATUS
]

[9:09:20](#Btr2zRW6fKBdc71DoXSSczaxzjBFfxWFQUd8QozG1XU) <GiuseppeChillemi (GiuseppeChillemi)>:
* So STATUS will be set when NONE, if different than NONE the second command will notice it and act, or at the end of the ANY block you can check the STATUS content to know if an error has happened.

[9:09:45](#_o8Omwcix-pbQF4d_uVRaUjTutsSUQyTe3gH46JEwdU) <GiuseppeChillemi (GiuseppeChillemi)>:
* The problem remains for ANY and ALL that needs NONE to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let KEY-SELECT fail with error and wrap the whole ANY/ALL body in TRY/ERROR. 
2) Use a carrier: 
ALL [
  KEY-SELECT/STATUS MAP 'KEY1 TYPES 'STATUS
  KEY-SELECT/STATUS MAP 'KEY2 TYPES 'STATUS
]

[9:11:26](#ECrIeX2Q0qm4_jOFMKvf1gPcWsd43niVM0OLJIMKyFE) <GiuseppeChillemi (GiuseppeChillemi)>:
* So STATUS will be set when NONE, if different than NONE or to the error ID. The second command will notice it and act, or at the end of the ANY block you can check the STATUS content to know if an error has happened.

[9:54:59](#GLGJhIFAp31MBMeoxuCPivXCUjIPNbx2pqNBAeZBOKc) <GiuseppeChillemi (GiuseppeChillemi)>:
* The problem remains for ANY and ALL that needs NONE to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let KEY-SELECT fail with error and wrap the whole ANY/ALL body in TRY/ERROR. 
2) Use a carrier: 
ALL [
  KEY-SELECT/STATUS MAP 'KEY1 TYPES STATUS
  KEY-SELECT/STATUS MAP 'KEY2 TYPES STATUS
]

[9:55:24](#gl1vYYUVferb-uPX3NSA7qJ2qc_Fz0Eb13KbvGvx-6o) <GiuseppeChillemi (GiuseppeChillemi)>:
(i am on mobile, sorry for the bad text) 

[9:56:00](#Z9F69pc8JsYyM4ARlbA3lnjNf_Y4ZU1T9i1NU0vUnIg) <GiuseppeChillemi (GiuseppeChillemi)>:
* The problem remains for ANY and ALL that needs NONE to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let KEY-SELECT fail with error and wrap the whole ANY/ALL body in TRY/ERROR. 
2) Use a carrier: 
ALL [
'  KEY-SELECT/STATUS MAP 'KEY1 TYPES STATUS
  KEY-SELECT/STATUS MAP 'KEY2 TYPES 'STATUS
]

[9:56:17](#EKgXX2jwSHAMBOmi9iD6jB6ytAMWAWMq5fOqt8iNQik) <GiuseppeChillemi (GiuseppeChillemi)>:
* The problem remains for ANY and ALL that needs NONE to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let KEY-SELECT fail with error and wrap the whole ANY/ALL body in TRY/ERROR. 
2) Use a carrier: 
ALL [
   KEY-SELECT/STATUS MAP 'KEY1 TYPES 'STATUS
  KEY-SELECT/STATUS MAP 'KEY2 TYPES 'STATUS
]

[10:22:39](#e6vvx3oF8WOF9mVBGpgi7Rr6OPe40ZmtRunw8a25RvY) <GiuseppeChillemi (GiuseppeChillemi)>:
* The problem remains for ANY and ALL that need NONE to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let KEY-SELECT fail with error and wrap the whole ANY/ALL body in TRY/ERROR. 
2) Use a carrier: 
ALL [
   KEY-SELECT/STATUS MAP 'KEY1 TYPES 'STATUS
  KEY-SELECT/STATUS MAP 'KEY2 TYPES 'STATUS
]

[10:25:48](#1eoxp0fU1b8QkC5pMlF_e_z4-H2c0wZ6jAJaApLgRxM) <GiuseppeChillemi (GiuseppeChillemi)>:
Note: if STATUS if a context or any other container, you can avoid the LIT form as you need to set it inside the KEY-SELECT so the word is needed without other containers. 

[10:26:48](#H2xdVfUmoYCJfUTsmXONvKHhkaITqE8At9JiYOql_Ig) <GiuseppeChillemi (GiuseppeChillemi)>:
* Note: if STATUS is a context or any other container, you can avoid the LIT form as you need to set it inside the KEY-SELECT. The word is needed in absence of other containers to set.

[11:38:13](#8fUkohfmHF75cf9E2ttKFtINYiKeaQXjpOZzt5sN0do) <GiuseppeChillemi (GiuseppeChillemi)>:
* 
The problem remains for `ANY` and `ALL` that need `NONE` to work. You can't distinguish NO-KEY FROM from TYPE MISMATCH, so you can't break them. There are 2 solutions: 
1) let `KEY-SELECT` fail with error and wrap the whole `ANY/ALL` body in `TRY/ERROR`. 
2) Use a carrier: 
`
ALL [
   KEY-SELECT/STATUS MAP 'KEY1 TYPES 'STATUS
  KEY-SELECT/STATUS MAP 'KEY2 TYPES 'STATUS
]
`

[22:32:11](#Uj3WYYiWxXRhbMlwRiknDSrVQxUvh46g81Ahp8pJQso) <Oldes (@oldes.h:matrix.org)>:
I really don't know what you want to achieve... but have you consider return just `make error! "missing value"` or something like that, when there was no value?

[22:33:19](#QyxKJ2WAVhmdx3h33qlX07oYsJ8hsmJOPP0MUWsz-ao) <Oldes (@oldes.h:matrix.org)>:
I believe that you can do same tests with such custom error value like with any not existing null datatype.

[22:34:53](#OMcuzKggePDsSLM_XSraSXrgvciGY4ZkloOf91vpnR0) <Oldes (@oldes.h:matrix.org)>:
No need to use `try` or `attempt` when the error is just returned and not thrown.

[22:43:11](#n1qL3BQBqpnmK8U0g-H9oX-ilI7VZaHFpfku3dfdzgQ) <Oldes (@oldes.h:matrix.org)>:
* I believe you can perform the same tests with a custom error value as with any non-existing null datatype.

[22:46:09](#lxq4806QBWqxOIgQzqTDCXY0nfQxiLdWg7O-U-RH74I) <Oldes (@oldes.h:matrix.org)>:
Now the interesting question is whether an error should be considered a falsy value.

## 23-Mar-2025

[0:11:35](#mrqwhq9BkvKEiUqwXCGnI5poSQdMoSxh2XDd-e27VKw) <GiuseppeChillemi (GiuseppeChillemi)>:
If it can be used as the `none` container and be `falsy` we have solved my needing.

[0:11:50](#_pXypCDybNYsjz3Y8EC5p8T3XCWFB_Ug_BAsXa46Pb0) <GiuseppeChillemi (GiuseppeChillemi)>:
* If it can be used as the `none` container idea and be `falsy` we have solved my needing.

[0:22:54](#VwEMzy4VSCLfte6rQGxvurDlqtlFJ1AL7nfCL9NCSA0) <GiuseppeChillemi (GiuseppeChillemi)>:
I need just a powered `none` that carries extra information with it, so when `if none? result: []` with extra info inside. But if `make error!` could carry this information I can make some tests with its `truthy value

[9:17:09](#JqdoXjevYpt9JpZWd3kGiKI_JntAQjV6XkU6cnYlEj8) <rebolek (Boleslav B≈ôezovsk√Ω)>:
hm, what extra info should `none` carry?

[9:29:01](#pc2myeDyI3drv_DANYZafWKyDQCOEYr25fNOIIc4IkU) <GiuseppeChillemi (GiuseppeChillemi)>:
Info about what has caused the NONE event. It could be a missing key, or value type not corresponding to the allowed values. So you have a falsey container and the extra info needed to identify the cause. 

[10:54:31](#ll0D-21veFe0FQAuIHZNd3F8g1rpScTTCoC56_URhts) <rebolek (Boleslav B≈ôezovsk√Ω)>:
but it's not event, it's a value

[11:15:36](#RZ9qfiUI5e6AtwhbvwRqwBiHT53vZtjmWS9f2S8r31E) <GiuseppeChillemi (GiuseppeChillemi)>:
You are right. The "event" is the key miss or wrong type. It is what has happened during the selection you triggered. But id it is inappropriate to call event what has happened triggered by your query, lets call it result. So the idea is to have a NONE result with extra info. So you know  morr in detail what has caused the NONE result without new queries on data, like asking for the existance of the key or if the datatype was the cause of the NONE or any other reason. A NONE container will carry it.

[11:19:30](#IKmyHxpmGnFFgphwPD9za0EUTvMaQVH2kGEfd9Fzzyk) <GiuseppeChillemi (GiuseppeChillemi)>:
* You are right. The "event" is for me the key miss or wrong type. It is what has happened during the selection you triggered. But if it is inappropriate to call event what has happened triggered by your query, lets call it result. So the idea is to have a NONE result with extra info. So you know  morr in detail what has caused the NONE result without new queries on data, like asking for the existance of the key or if the datatype was the cause of the NONE or any other reason. A NONE container will carry it.

[11:23:11](#X1tfWGj54q0zGNcWj77O5GaXLoxniynIavpEGs9sbcc) <GiuseppeChillemi (GiuseppeChillemi)>:
* You are right. The "event" is for me the key miss or wrong type. It is what has happened during the selection you triggered. But if it is inappropriate to call event what has happened triggered by your query, lets call it result. So the idea is to have a NONE result with extra info. So you know  more in detail what has caused the NONE result without new queries on data. Info could be the KEY-MISS or DATATYPE mismatch or any other reason. A NONE container will carry it and be NONE at the same time for short circuit functions

[11:23:30](#jTDqL_ElMcwpUNM6bAkSGW1THumfK9SoQWGifjyi_8Q) <GiuseppeChillemi (GiuseppeChillemi)>:
(I have made a modification)

[16:23:27](#jYi3BFV7InuFImyaw7AxeMiD_LRzbHRajP5Kvz3SVS8) <Oldes (@oldes.h:matrix.org)>:
You can have the extra info with the error value. Right now wothout need to modify existing runtime.

[16:23:42](#v8ooxE0WCj12DSka1O_bPn2Bt7J3fA1MWaUn3R5t54s) <Oldes (@oldes.h:matrix.org)>:
* You can have the extra info with the error value. Right now without need to modify existing runtime.

[16:27:30](#UbuPfUpB8JGhMYLaZOT1CF7-XRurwTXC9txJz4F9e0c) <Oldes (@oldes.h:matrix.org)>:
Extending the none value with some extra info would just complicate and slow down every code where it is used, so you really cannot expect it.

[16:34:58](#9WqxRCSE3H2EXQeG9AVdJlT2_T-faQMNgOg-AB1OTi4) <hiiamboris>:
Ren-C should be your choice, with none, null, void, nihil, and god knows what other types of nothingness

[16:35:21](#52evYjtrcvNJIMEqYlxkBx4M3AloZ0aBLK1ijoHMLcI) <hiiamboris>:
* Ren-C should be your choice, with none, null, void, nihil, blank, and god knows what other types of nothingness

[16:54:37](#rvJ3clBneuJdPq3kkMgDrWpRlSSeg17EamuuTOiO3tI) <GiuseppeChillemi (GiuseppeChillemi)>:
Maybe a secondary datatype. As I have said, being too conservative stops the development of the language as being too revolutionary. The best solution is.in the middle. Otherwise we would nit have Rebol3.0 with func/ctx and all the other advancement.

[16:55:04](#EuaxouHJlEoF1w6hX_YbVoZ2Bku5pGm2lZADHxuV7XI) <GiuseppeChillemi (GiuseppeChillemi)>:
* Maybe a secondary datatype. As I have said, being too conservative stops the development of the language as being too revolutionary. The best solution is in the middle. Otherwise we would not have Rebol3.0 with func/ctx and all the other advancements.

[16:56:18](#4AxDEOjFFvcO1_0RZiA_3nZgm5VGUWU6bi7UBuOXeR4) <GiuseppeChillemi (GiuseppeChillemi)>:
And some time, you are have a really a too conservative attitude, with the risk of being stuck at Rebol2.0, comparing my ideas to Ren-C total revolution. 

[17:16:47](#GDg-l5BpR_u45lbSlkz1X8pZq3zI5FuG-Bm2wuXpTuE) <hiiamboris>:
We're not conservative, we're pragmatic ;)

[17:16:49](#Nq37aukszb5UlbffVHVmAxe-97RMujH3JjRAPyG-Tuk) <gurzgri>:
Call it conservative. But sticking to hopeless ad-hoc "imdeprovements" like none-containers or other none-on-(a)steroids-ideas lacking even the minimal amount of effort put in language design isn‚Äòt innovative either and for sure isn‚Äòt getting you things done. Especially not if there are available solutions galore to your problem. No offense.

[17:29:01](#sJsjH6qng8TlDqL9izt2taCZynimWGgqYFbnoDviN_E) <gurzgri>:
And as I pointed out earlier: How are going to discern between selecting a and b from the following fictional map in a language where (pretty much) everything is a value, even your none-container?
```
>> map: make map! [
    a: #(none 'no-key)
] ()
>> select map 'b
== #(none 'no-key)
>> select map 'a
== #(none 'no-key)
```
I guess we‚Äòll need `#(none 'really-no-key-believe-me)` pretty fast Ì†ΩÌ∏â


[17:39:13](#ibrVf5pNzYdvbby_KY5CMaqcJjyrITt9aN2cf82HIb0) <GiuseppeChillemi (GiuseppeChillemi)>:
If you read back you wll find the answer. The needing here is a falsey container with data. When you will need to use it as a value instead of its meaning, you can use a differment internal content and have it out of the used data in the dataset. (A solution you have written) 

[17:39:43](#_JHjfs2ZdfQu0QzLbd7lEQLAWtaT712Q0ttVtFFBHfs) <GiuseppeChillemi (GiuseppeChillemi)>:
In other words you are differentiating the container putting it out of band.

[17:42:09](#fZ0Ve66RYeFNqj98LSvfBKL0mIsNI0OOyxUiXzlPG2c) <GiuseppeChillemi (GiuseppeChillemi)>:
This is the purpose of having a none container: you don't have to invent a new datatype. Simply change the content you identify as meaning to data and use another none+content as NONE meaning.

[17:43:45](#zYq7PLzykfh7V83Jh9GRpoLHw7DAxRR2qMgp_TN23GY) <GiuseppeChillemi (GiuseppeChillemi)>:
We have plenty of possibilities with truthy do this but we have zero falsey containers.

[17:44:01](#fjj9koo7bUu6j3Odm-gcYTD7ZuygGtiDxjSzju_Qby0) <GiuseppeChillemi (GiuseppeChillemi)>:
* We have plenty of possibilities with truthy containers do this but we have zero falsey containers.

[17:48:09](#EjQQKTIeTNLPdHbjji7Gei0yv74G3npELhOuxx7-vps) <GiuseppeChillemi (GiuseppeChillemi)>:
* This is the purpose of having a NONE container: you don't have to invent a new datatype. Simply change the content you identify as meaning to data and use another none+content as NONE meaning.

[17:48:38](#JrGfY1EKvMECNp4xbKNYmM-8pYGfP7OZ_7qVQedAEfM) <GiuseppeChillemi (GiuseppeChillemi)>:
* This is the purpose of having a NONE container: you don't have to invent a new datatype. Simply change the content you identify as meaning to data and use another NONE+CONTENT as NONE meaning.

[18:03:33](#2LvGLNiU-Y1KcdnekWcM-AWC_3bN6QsNFHhQxQ4ugDA) <GiuseppeChillemi (GiuseppeChillemi)>:
* In other words you are differentiating the container putting it out of band of what is used an meant as none.

[18:26:18](#nADaIEtkM4TdA9-_8KLxMwwkKvIuF7nfAktYApFeL5A) <GiuseppeChillemi (GiuseppeChillemi)>:
* We have plenty of possibilities with truthy containers to do this but we have zero falsey containers.

[18:38:10](#oApd4VolMvTuneKFjGX9vn4Jgehs9zi8pAVayrN4yP8) <gurzgri>:
Sorry, I don't follow, I fail to understand how ‚Äûwith none-containers you don't have to invent a new datatype‚Äú and ‚Äûwe have zero falsey containers‚Äú go together. 

I promise you won‚Äòt ever get your none-container - not because I am against it, that doesn‚Äôt matter. But because no one except you will ever be convinced that it is the right thing to do - I‚Äòm betting the Ì†ºÌΩø on it I‚Äòm watching this discussion with. Ì†ΩÌ∏ú

[18:49:29](#Ya8-24Dq41gtyAcN0EoKQ1Y4JtMhPn5U80lXAlKebPY) <GiuseppeChillemi (GiuseppeChillemi)>:
Read the whole thread, it has been written. I also have written multiple times the need of side data with custom informations like /SKIP value requested by Boris. This is needed to extend or use existing structure for new uses, enrich them in specific coding areas. A falsey container has this purpose: having extra info in the case NONE Is returned. You can understand the idea with an open mindset instead of a popcorn one. Ì†ΩÌ∏û

[18:49:53](#i8q9aR6WIrrS-LsPvV-5ZUG_-czloZBKKbYtO2CMx7o) <GiuseppeChillemi (GiuseppeChillemi)>:
* Read the whole thread, it has been written why it is useful and when. I also have written multiple times the need of side data with custom informations like /SKIP value requested by Boris. This is needed to extend or use existing structure for new uses, enrich them in specific coding areas. A falsey container has this purpose: having extra info in the case NONE Is returned. You can understand the idea with an open mindset instead of a popcorn one. Ì†ΩÌ∏û

[18:59:16](#Xypxnbuwm_pjRRw6mIm1w2RvrQuq1c5cYFeXDVsDoQ0) <GiuseppeChillemi (GiuseppeChillemi)>:
* Read the whole thread, it has been written why it is useful and when. I also have written multiple times the need of side data with custom informations like /SKIP value requested by Boris. This is needed to extend or use existing structures in new ways, enrich them in specific coding areas. A falsey container has this purpose: having extra info in the case NONE Is returned. You can understand the idea with an open mindset instead of a popcorn one. Ì†ΩÌ∏û

[22:18:50](#_vbeKYXnjGvo5DgXCIo_ZC8CETFtyzCku2aBNuqIht8) <Oldes (@oldes.h:matrix.org)>:
I would really like to see your real life example. Code snippets above are not good enough. I don't remember when I ever needed to differentiate if none returned from a map is because the value is none or that there is no key. Simply none means none and one must treat it as none. And if I really need to know, if the key exists, I may use the `find` function as was noted above.

[22:25:21](#aH3OYZ81-dAPjjkGkaFpexDeNMkJ9bqFjPxM1o92VIE) <Oldes (@oldes.h:matrix.org)>:
I may ask again, if it is good, that error value is now truthy. Because I think, that it could be falsy instead.. but maybe I don't see all possibilities. Now there is:
```
>> true? error: try [1 / 0]
== #(true) ;; why not false?

>> type? all [error 1]
== #(integer!) ;; why not none?

>> type? any [error 1]
== #(error!) ;; why not integer?
```

[22:27:05](#X0HH2Z9l187gJgLBQSJ2iTqyZBjcD8LUCW-hSc9rwKc) <Oldes (@oldes.h:matrix.org)>:
* I may ask again, if it is good, that error value is now truthy. Because I think, that it could be falsy instead.. but maybe I don't see all possibilities. Now there is:

```
>> true? error: make error! "something failed" 
== #(true) ;; why not false?

>> type? all [error 1]
== #(integer!) ;; why not none?

>> type? any [error 1]
== #(error!) ;; why not integer?
```

[22:28:13](#Ys3RWUt8SBx85AmaVWqa3yFNROvZmDS1Is958UzhOYQ) <Oldes (@oldes.h:matrix.org)>:
Would not it be your dreamy _none container_?

[22:31:09](#SQtKb2atl2F4d_U3-4rh_CTOcxw9H3dBbSYdC7pDxbU) <Oldes (@oldes.h:matrix.org)>:
In Rebol2 there was not such an error value.. all errors had to be first disarmed first, so there was no reason to ask if error is true or false value. But now we can revisit it. It may be an easy change (not like extending none value or introducing new datatypes).

[22:31:29](#hzUk26gIAoDmditl0AJ_TiEnrTHLE-h_iyu_Kcm0Qw8) <Oldes (@oldes.h:matrix.org)>:
* In Rebol2 there was not such an error value.. all errors had to be disarmed first, so there was no reason to ask if error is true or false value. But now we can revisit it. It may be an easy change (not like extending none value or introducing new datatypes).

[22:48:00](#mZJGkuT7KQl-5zZ2gnC5Zm5oXb5x9K6DnWLtNSHvzlI) <Oldes (@oldes.h:matrix.org)>:
Here are GPTs opinions, if error should be true or false:

That‚Äôs a great philosophical question about the language‚Äôs design! Logically, making `error!` values falsy‚Äîlike `none` and `false`‚Äîcould make sense in certain cases, particularly when using logical expressions like `ALL` and `ANY`. Here‚Äôs why:

### **Arguments for Making `error!` Falsy**
1. **Consistency with `none` and `false`**  
   - Errors often indicate failure or the absence of a valid result.  
   - `none` is already falsy and often used to indicate "no valid value," which aligns with an error state.  

2. **Better Flow in Logical Expressions (`ALL` and `ANY`)**  
   - If `error!` were falsy, `ALL` would naturally short-circuit on an error, returning `none`.  
   - `ANY` would skip over errors, returning the first valid value.  

3. **More Intuitive Error Handling**  
   - In many cases, errors mean "stop processing," which aligns with falsiness.  
   - Logical expressions would not need explicit `error?` checks to prevent unintended results.  

---

### **Arguments for Keeping `error!` Truthy**
1. **Errors Are Real Values**  
   - Unlike `none`, an `error!` value **contains information** (error type, message, etc.), making it more than just "nothing."  
   - Treating it as falsy might imply that it‚Äôs "empty" rather than "something went wrong."  

2. **Explicit Error Checking Encourages Safer Code**  
   - Since `error!` is truthy, developers must **explicitly handle errors** rather than ignoring them in logical expressions.  
   - If errors were falsy, they could silently propagate through `ALL` or `ANY`, leading to unintended results.  

3. **Backward Compatibility**  
   - Changing `error!` to falsy would alter the behavior of existing Rebol code, potentially breaking logic that assumes `error!` values are truthy.  

---

### **Alternative Approach: Conditional Falsiness**
Would it be practical for `error!` to be **falsy in logical expressions** but **truthy elsewhere**?  
- Some languages (like JavaScript) allow certain objects to be falsy in conditionals but still behave as normal values in other contexts.  
- Rebol could adopt a special evaluation rule for `error!` in `ALL`, `ANY`, and `IF`.  



[22:57:29](#YZSj_AcZwB7tD7gQEoqV68GHJC5QrnfiwkwiUaba7js) <Oldes (@oldes.h:matrix.org)>:
What I can see as a problem is, that the error value used in `any` and `all` would be transparent.. you could have any extra info in it, but it would be invisible there.. because it was not thrown. So again GiuseppeChillemi (GiuseppeChillemi) , what is your use case? How you would work with such a falsy none-like value?

## 24-Mar-2025

[0:07:21](#0epCotngkXWGhKk1-cJhk6nZSQ5Htr_tRZl685QmuyY) <greggirwin (Gregg Irwin)>:
I agree with ChatGPT, as it just gave options, not a decision.

[0:32:26](#5vVOKRo4JFd63OCRmk0LXeYGGYhiE0Y5zAuUSw9WgSI) <greggirwin (Gregg Irwin)>:
> I am almost there but for speed it must be native

This is the first argument I will push back against. You cite a 30% difference. That tells me very little. If you're making a performance argument, faster/slower are meaningless. How many Xs do you need to process in Y time? How hard and critical is that number? How *much* too slow is it? How much of the *total* time taken does this account for? Those are more helpful metrics.

Then we can talk about how this changes the fundamental design of the language, including as a data format, and if there's no better way around it.

Other questions:
- What does the metadata syntax look like?
- Is a single word (or other) metadata value enough? Are you sure?
- If there's no metadata is it a `#(none #(none))` value?
- If metadata is a series or compound type, how does that affect GC? e.g. you set a value to `none` and it can be reclaimed, but not if it has metadata in this design, correct?
- What if there was a `result!` datatype? What would that look like? What are the use cases?
- Do all types with available slots support this? If so, that's a leaky implementation detail, and inconsistent.
- If all types could support this, we're back to a single compound type that has lots of overhead and is completely consistent and infinitely flexible. That is pretty much the antithesis of Red's design.

The little design advsior who sits on my shoulder says No to this idea, but I can't stop you from implementing it yourself and showing him that he's wrong.


[0:33:31](#wrgwMOh29sMqJVg8JBFRr1qMw3iyuVWMn0Z9i5qopIc) <greggirwin (Gregg Irwin)>:
* > I am almost there but for speed it must be native

This is the first argument I will push back against. You cite a 30% difference. That tells me very little. If you're making a performance argument, faster/slower are meaningless. How many Xs do you need to process in Y time? How hard and critical is that number? How _much_ too slow is it? How much of the _total_ time taken does this account for? Those are more helpful metrics.

Then we can talk about how this changes the fundamental design of the language, including as a data format, and if there's no better way around it.

Other questions:

- What does the metadata access syntax look like?
- Is a single word (or other) metadata value enough? Are you sure?
- If there's no metadata is it a `#(none #(none))` value?
- If metadata is a series or compound type, how does that affect GC? e.g. you set a value to `none` and it can be reclaimed, but not if it has metadata in this design, correct?
- What if there was a `result!` datatype? What would that look like? What are the use cases?
- Do all types with available slots support this? If so, that's a leaky implementation detail, and inconsistent.
- If all types could support this, we're back to a single compound type that has lots of overhead and is completely consistent and infinitely flexible. That is pretty much the antithesis of Red's design.

The little design advsior who sits on my shoulder says No to this idea, but I can't stop you from implementing it yourself and showing him that he's wrong.

[0:35:27](#q941p-tdaVjVItHb9ow5ON0SByGLfaOS6YoZnRt2BKI) <greggirwin (Gregg Irwin)>:
The main thing is that this can all be built in Red today, at the mezzanine level. If the only argument against doing that is performance and having to write helper funcs, that's not enough to warrant such a fundamental change.

[1:24:48](#8-PRirvjGf8j1tDsqpeCOY0yrGVpJUjVz1HwbNEE0Yo) <GiuseppeChillemi (GiuseppeChillemi)>:
What has started this needeing? The following function:

```
value: key-select container key [<datatype>]
```
It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.
* The command has returned a value
* The command has not found the key
* The value datatype is wrong
* The key value is #(none)
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
* Check if key exists
* Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of a container which `negative` logic, one interpreted as `none` by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function has returned a `none` value but with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`. 
In this way, ZERO user code must be changed, apart the internal one that manages short circuit functions.
 

[1:25:00](#ooJBD_UrHlL23-p9eKqTbaJcSTySyjWc0X-NJbMnrn8) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is #(none)
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of a container which `negative` logic, one interpreted as `none` by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function has returned a `none` value but with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, ZERO user code must be changed, apart the internal one that manages short circuit functions.

[1:25:33](#9T-kutB5TEmyjTon_HIy9aAE1kGwb7bQuHstjwZ6xuM) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of a container which `negative` logic, one interpreted as `none` by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function has returned a `none` value but with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, ZERO user code must be changed, apart the internal one that manages short circuit functions.

[1:27:02](#dAIzutk6DsN45DfFqX61srk9NYjHgwdc__Iz2hoVA7Y) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of **a container with `negative` logic**, one interpreted as `none` by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function has returned a `none` value but with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, ZERO user code must be changed, apart the internal one that manages short circuit functions.

[1:27:21](#LDPui3g-ag9jB1svvGE75MCyAZ4FBMjaYzzRxASR6Bg) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of **a container with negative logic**, one interpreted as `none` by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function has returned a `none` value but with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, ZERO user code must be changed, apart the internal one that manages short circuit functions.

[1:27:36](#MIhJ8JPIATqpHQA3hg9yybZVB8yJkNsYfMzLBIV39fM) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of **a container with negative logic**, one interpreted as FALSEY by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function has returned a `none` value but with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, ZERO user code must be changed, apart the internal one that manages short circuit functions.

[1:29:21](#z1a2kDXCbZbPa49jLmiXjSNmZBxwzkMuGBRb7kTYQW4) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of **a container with negative logic**, one interpreted as FALSEY by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, ZERO user code must be changed, apart the internal one that manages short circuit functions.

[1:35:18](#L9uvU1l-DrN5iuz3__NGMGAk33--7DJj53toPIGMznk) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time.
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. So came the idea of **a container with negative logic**, one interpreted as FALSEY by such functions.
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
To emplement it, you only need the following:
1) Duplicating one of the container datatype we actually have as `block` or `map!` and mark it as falsey
or
2) Add a flag to our actual container values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic
and
3) Instruct `any` and `all` to break on none container and return it instead of generating none

The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, **ZERO user code must be changed**.

[1:36:31](#Br1HD2qw5nnb8exnx9u6BflLNCf713HMs1horm-7-8M) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. *So came the idea of* **a container with negative logic**, *one interpreted as FALSEY by such functions.*
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
Without a logically `none` or FALSEY contaiener, you must do multiple checks again, loosing a lot of time, complicating the code. The other solution would to split the command but in this way you loose the power of it: conciseness and expressiveness.
To emplement it, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and mark it as falsey
or
2. Add a flag to our actual container values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic
and
3. Instruct `any` and `all` to break on none container and return it instead of generating none

The only change needed would be that `any` and `all` should pass the last logically `none` container instead of auto generating `none`.
In this way, **ZERO user code must be changed**.

[1:42:25](#nMsEuOra9w87Jytyfj7RryrnmWb7AUl28ZruOarBy2o) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
* conciseness 
* expressiveness
* CPU cycles saving
* Having the data information returned by the function with you in case of `falsey` values.
To emplement it, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and mark it as falsey
or
2. Add a flag to our actual container values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic
and
3. Instruct `any` and `all` to break on none container and return it instead of generating none

In this way, **ZERO user level code must be changed**.


[1:44:41](#o6g-r_Lv5X63bvtYHBst1AOZtDuw027enGIIljixukw) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

- conciseness
- expressiveness
- CPU cycles saving
- Having the data information returned by the function with you in case of `falsey` values.
To emplement it, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag with a `!` (or any other usable character).
or
2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic
and
3. Instruct `any` and `all` to break on none container and return it instead of generating none

In this way, **ZERO user level code must be changed**.

[1:45:43](#cMyRp6rYRbMiiMpvxZosLEhDGII69b39AVl3OxCfito) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
To emplement it, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag with a `!` (or any other usable character).
or
2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic
and
3. Instruct `any` and `all` to break on none container and return it instead of generating none

In this way, **ZERO user level code must be changed**.

[1:46:14](#riL_YFgYA8FiAcjqzskSU43S1MPxoN3SmlgBdaN1nuM) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag with a `!` (or any other usable character).
or
2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic
and
3. Instruct `any` and `all` to break on none container and return it instead of generating none

In this way, **ZERO user level code must be changed**.

[1:48:19](#LwubMdw9qYdli80AoSjlnDLazyHYT3N40PP0ZvOk-Hw) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).
or
2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic
and
3. Instruct `any` and `all` to break on none container and return it instead of generating none

In this way, **ZERO user level code must be changed**.

[1:50:41](#bHgu-tjzX0e8ebOfqhT5t9txLl34N3bAxIWAoJMWims) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**
- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).
or
2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could make falsey existing ones
and
3. Instruct `any` and `all` to break on none container and return it instead of generating none

In this way, **ZERO user level code must be changed**.

[1:51:35](#MfBZh4FGc4MfV2irnRyhQ_JvcQ7OJRPgvFoeSVtYyUI) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could make falsey existing ones

and

3. Instruct `any` and `all` to break on none container and return it instead of generating none

In this way, **ZERO user level code must be changed**.

[1:52:19](#1nD3dESaDPG0sDSp64Gvwdc33AgkR2wLB5RX9HSt9LQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could make falsey existing ones

and

3. Instruct `any` and `all` to break on falsey container and return it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[1:53:55](#LMSqgk-WKiblQvYbt2aHflKm9zHlRoVyjTPmgJt6w0g) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual containers values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could make falsey existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[1:54:30](#Y8eZhXG0XPsunKS1_rcDqczTgc7pTc9DPzSaDZD6y2U) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could make falsey existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[1:55:07](#iALIbeZieett3EFVuZhH8B78kFY71BcXa10-MRDtGkQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, it returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you and so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (any value?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[1:59:40](#OrRWgG2CDkBLoV6l3GmeSqSZbxCVW0V1utUELD16J0o) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[2:01:26](#lNUL_Tt5NqMjtEJatWeau_MEFdJSVvjlj2L2vP9Y_Bc) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks. So a function state can be retuned in case we must return a falsey result for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[2:02:11](#IZP0jCmMx5ifugABncfOu64vkhKGSWeJATaQbaXEeW8) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks. In  this way function state can be retuned in case we must return a falsey result for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[2:03:18](#g7roGfimk2uZH-hEFFys4lE93QbdvK2RWyLvUozJFuA) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks. 
- In  this way, function internal states and flags can be retuned in case we must return a falsey result for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[2:06:27](#DK3fewqS0mltsXk4dYSP1s9hG-5cjnvN0Dj6usV7Gc4) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
- In  this way, function internal states and flags can be retuned when a falsey should be returned for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[2:07:03](#XqMuMmqTraorrznWIkakvtREQRJo9Itf9sWXruhX7cs) <GiuseppeChillemi (GiuseppeChillemi)>:
* What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
- In  this way, function internal states and flags can be retuned when a falsey value should be returned for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[2:08:10](#SPMPsiR2uZX-aGiRk_B9c2BZ6CegngY8LbGfDez6cP8) <GiuseppeChillemi (GiuseppeChillemi)>:
* The ideas has been evolved a little.
What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
- In  this way, function internal states and flags can be retuned when a falsey value should be returned for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.

[2:09:04](#w4GljU1MUjBp4M9VTAjHwQEje7SKGk8exAX3Zo-ThMU) <GiuseppeChillemi (GiuseppeChillemi)>:
* The ideas has been evolved a little.
What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
- In  this way, function internal states and flags can be retuned when a falsey value should be returned for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.
I ask to you, how this idea is now compared with all the question you have expressed above? 

[2:11:08](#0uclN7BgWUvnxf2nGEzh8J94rS2q9z4fPfh_N5-MipE) <GiuseppeChillemi (GiuseppeChillemi)>:
* The ideas has been evolved a little.
What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
- In  this way, function internal states and flags can be retuned when a falsey value should be returned for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.
I ask to you, how this idea is now compared with all the question you have expressed above? I is only now just a flag more. Do we have space for it?

[2:11:40](#XQ60USYuaMnRxpdcvU2vFQoMwAK7ZIZD1cwh3swAuI0) <GiuseppeChillemi (GiuseppeChillemi)>:
* The ideas has been evolved a little.
What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicaning an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
- In  this way, function internal states and flags can be retuned when a falsey value should be returned for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.
I ask to you, how this idea is now compared with all the question you have expressed above? Now it is only just a flag more. Do we have space for it?

[2:13:52](#0PF-RHV4Ijdm1uvW2aC7HizBvuIU2lVFucHVcOZfz6c) <GiuseppeChillemi (GiuseppeChillemi)>:
* The ideas has been evolved a little.
What has started this needing? The following function:

```
value: key-select container key [<datatype>]
```

It is very handy when you want to select a value and check its datatype at the same time (that is what it does).
But I having such compact code, you have a problem: there are a some of return state that must be checked but there is just only a `none`.

- The command has returned a value
- The command has not found the key
- The value datatype is wrong
- The key value is `#(none)`
When `none` if returned you are not able to distinguish what has really happened. So you must do other 2 things:
- Check if key exists
- Check if type is correct
Both would take multiple lines and cycles, so we would loose performance and expressiveness (most important). The operation has already been done, the function had it, so why we should perform it again? So I thought, why not returning the state of the checks in a container value?
My first idea was a special forged `object!` or `map!` but as soon I have tried, a problem arose: short circuit functions. They would never be interrupted because such containter are truthy. _So came the idea of_ **a container with negative logic**, _one interpreted as FALSEY by such functions._
While initially I have thought about about extending `none`, now I think that any container could be a negative one using a flag, or a special one could be implemented duplicating an existing one. So the idea is to have a logically `negative` carrier and `any` and `all` pass it instead of `none`.
The advantage?
Think about this container `#![reason: no-key key: "surname" type: string!]`
(Please note the exclamation mark  at the start, to denote the `map!`, it is an idea of container)
The function would have returned `none` value but instead, implementing the idea it would returns now a **falsey container** with all the information it has already gathered. So you really don't need to do all the checks again. It already knows what has happened!!! Why do it all the checks again? I repeat: **why do all the checks agains?**

The adavantages of the solution are:

- conciseness
- expressiveness
- CPU cycles saving
- Having the information returned by the function with you, so you must not do again the function internal checks.
- In  this way, function internal states and flags can be retuned when a falsey value should be returned for logic.
.
To implement the idea, you only need the following:

1. Duplicating one of the container datatype we actually have as `block` or `map!` and use it to create and identical with falsey flag. A falsey marker as `!` could be added to the syntax of the container like  a `#![key value]` (or any other usable character).

or

2. Add a flag to our actual container values (all values?) to mark them falsey. A `!` added to their syntax somewhere could do the magic. Also a command like `to-falsey container` could change the flag and make as falsey the existing ones

and

3. Instruct `any` and `all` to break on falsey container returned and pass it instead of generating `none` value.

In this way, **ZERO user level code must be changed**.
I ask to you, how this idea is now compared with all the question you have expressed above? Now it is only just a flag more. Do we have space for it?

[2:18:38](#ez0ppRqz1U1xj6zEzfvy3QJPEyf2a8k9v4L9aAo3ikc) <greggirwin (Gregg Irwin)>:
It's not fair to change your plan, rather than addressing my questions, pose a new one, and say "What problems to do you see with this?"

So I will just say that this new idea makes no sense to me.

You know I like and respect you, so keep that in mind when I say that you are saying "*I* want this, and I want *you* to do all the hard work and deep thinking, changing fundamental things about the language." I did that once for this chat. I went back and read all your messages, asked questions, and then you changed your plan. The little guy on my shoulder says this is *also* a bad design idea, for many reasons, but he will patiently wait for you to implement your ideas and then ask if they should be incorporated into Red.

Still friends. :^)

[2:36:20](#FGcWfbZFeo1iJYIramPl9EaV1m_JCdpbp7BsX9KdYXI) <greggirwin (Gregg Irwin)>:
I do understand how hard it is. You're building real-world apps, and the time it takes to step back and think about the big picture language design isn't there. We all struggle with this, and that *does* lead to conservative thinking *because* so *such* of Red(bol) is a really, really, really**3, solid design. 

[2:36:47](#cP3SV3S957-jiVLbyHNoN1JVfIHWTi2oKtyhqUVaM6s) <greggirwin (Gregg Irwin)>:
* I do understand how hard it is. You're building real-world apps, and the time it takes to step back and think about the big picture language design isn't there. We all struggle with this, and that _does_ lead to conservative thinking (on our part) _because_ so _such_ of Red(bol) is a really, really, really\*\*3, solid design.

[2:37:06](#DEB2nXCYD2ZIGjjlSliKmVC2cwcNdB0amIrcoAXEyHo) <GiuseppeChillemi (GiuseppeChillemi)>:
The plan was already there, and I have evolved it THANKS to your questions. Why having a `none` container when `falsey` could be encoded in every container as a flag? 

Here are your questions:

* What does the metadata access syntax look like?
The use of a flag on actual container keeps the actual access  syntax on everything

* Is a single word (or other) metadata value enough? Are you sure?
No, just use the existing containers, `none` is not touched

* If there's no metadata is it a #(none #(none)) value?
Don't know if it applies here

* If metadata is a series or compound type, how does that affect GC? e.g. you set a value to none and it can be reclaimed, but not if it has metadata in this design, correct?
I think only unset could make the GC reclaim it here
* What if there was a result! datatype? What would that look like? What are the use cases?
I have never thought about a RESULT datatype. But I don't see th needing here 
* Do all types with available slots support this? If so, that's a leaky implementation detail, and inconsistent.
Working on existing containers, I think everything is already supperted
* If all types could support this, we're back to a single compound type that has lots of overhead and is completely consistent and infinitely flexible. That is pretty much the antithesis of Red's design.
Nota applicable

[2:39:15](#hHkejdkcwaNaVQ6wEZ4VC_fstI1r92yd08hcVVXoxR4) <greggirwin (Gregg Irwin)>:
`!` does not mean `not` in Red. 

[2:39:45](#v5Qpwz6wbxD9IPGLfd-2j8owrlI2hr5QB-uAWpJin-A) <GiuseppeChillemi (GiuseppeChillemi)>:
I have written "this or any available character"


[2:40:29](#SD0muOm_GLpM3_9pzWw0YGfOSnqTX18z8FiHX2RzYVE) <GiuseppeChillemi (GiuseppeChillemi)>:
I must confess since times I felt the needing of a table with free characters but we have not one

[2:40:35](#W4-RHRN6z_agQfPgq2Hd9lmoFEgy1lL2af1TSaE1D-U) <GiuseppeChillemi (GiuseppeChillemi)>:
* I must confess since time I felt the needing of a table with free characters but we have not one

[2:40:42](#sfLE9fNVyzJrMVgrv0_RvbluUmatR4VnDY5bwCe0LsQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* I must confess since time I feel the needing of a table with free characters but we have not one

[2:40:54](#hwaSh0zVQAtjNjnWYmWC7DEs9l6YRA6_i8tSl_kNPvY) <GiuseppeChillemi (GiuseppeChillemi)>:
* I must confess since time I feel the needing of a table with free characters but we do not have one

[2:41:09](#gq9iEl9Z0RJ4hak2oeoDpQoHG9ccrXCOGktT_IWZ_Jw) <greggirwin (Gregg Irwin)>:
Sadly, I have to let this go. Good luck with it.

[2:41:25](#l9iPt1vkbDOs7ifdilP-W0bP6mhT0zcWxy_-wa2sn8Q) <GiuseppeChillemi (GiuseppeChillemi)>:
```
Here is an example code with and without the `falsey` container flag implemented

With
```
either result: any [other---checks---here key-select ctx key [datatypes]] [
	do something
] [
	Print ["reason:" result/reason]
]
```
Without
```
either result: any [other---checks---here key-select ctx key [datatypes]] [
	do something
] [
	either in ctx key [
		if not find to typeset [datatypes] type? select ctx key [Print "datatype not found"]
		] [
			Print "Key not found"
		]
	]
]
```


[2:41:40](#1SuFFQUAxffIOXE7NAsaf0ZPtmTrrzhs7zrcV5eNvHo) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here is an example code with and without the `falsey` container flag implemented

With
```

either result: any \[other---checks---here key-select ctx key \[datatypes\]\] \[
do something
\] \[
Print \["reason:" result/reason\]
\]

```
Without
```

either result: any \[other---checks---here key-select ctx key \[datatypes\]\] \[
do something
\] \[
either in ctx key \[
if not find to typeset \[datatypes\] type? select ctx key \[Print "datatype not found"\]
\] \[
Print "Key not found"
\]
\]
\]

[2:42:05](#ZXyDTicMDjVDXoVpR6Mlh1upo79OSfKuo_ZbxtHe7sE) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here is an example code with and without the `falsey` container flag implemented

With

```
either result: any [other---checks---here key-select ctx key [datatypes]] [
	do something
] [
	Print ["reason:" result/reason]
]
```
Without
```
either result: any [other---checks---here key-select ctx key [datatypes]] [
	do something
] [
	either in ctx key [
		if not find to typeset [datatypes] type? select ctx key [Print "datatype not found"]
		] [
			Print "Key not found"
		]
	]
]
```

[2:43:28](#KirY4gjti2nGMw_haLDJKgUFSKiWF6VhKnZjb6gYJEI) <GiuseppeChillemi (GiuseppeChillemi)>:
Answered, I did the homework you have requested! ;)

[2:46:11](#6-RpuP7XlNnParUk5xJ64Pvy6x-tgULwX1UIplxM3Zw) <GiuseppeChillemi (GiuseppeChillemi)>:
* Here is an example code with and without the `falsey` container flag implemented

With

```
either result: all [other---checks---here key-select ctx key [datatypes]] [
	do something
] [
	Print ["reason:" result/reason]
]
```

Without

```
either result: all [other---checks---here key-select ctx key [datatypes]] [
	do something
] [
	either in ctx key [
		if not find to typeset [datatypes] type? select ctx key [Print "datatype not found"]
		] [
			Print "Key not found"
		]
	]
]
```

[3:09:41](#QVGe3_7LHCMTs9AGG_CHnvf6_qoJO9nGmH6HIbrsXkI) <GiuseppeChillemi (GiuseppeChillemi)>:
To be precise, if we chose to  loose the possibility of having a direct value returned, a solution could be a wrapper:

```
result: key-select ctx key [datatype]
;result is now #(value: value-here state: state-here)
either result/state/falsey [
	Print ["reason:" result/state/reason]
] [
	result: result/value
	do something
]
```


[3:14:05](#a8UX7D1GZq2M5yd0OU-T4XRIf6x3YP851HUy2EiPuLY) <GiuseppeChillemi (GiuseppeChillemi)>:
I have made a variation. `none` container is now `falsey` existing container, so it is just a flag to implement. 
About your question on transparency, the idea is simple:  `all` and `any` should break at falsey container and return it instead of returning just `none`

[3:14:45](#0KaWtTq_El26il8FZbZCpNwbJO6PtsUrfXZXIDRF_0E) <GiuseppeChillemi (GiuseppeChillemi)>:
* As you have read, I have made a variation. `none` container is now `falsey` existing container, so it is just a flag to implement.
About your question on transparency, the idea is simple:  `all` and `any` should break at falsey container and return it instead of returning just `none`

[5:36:45](#IYQNTGcuDbKnmQGSzlkEMjr-whUX-m6VImmaM55lMYU) <Oldes (@oldes.h:matrix.org)>:
No.. it is not _just a flag to implement_. And we cannot continue until you will understand that. Changing the `none` value would be an incredible amount of work. And changing all values to add them _some result flag_ is even harder. So you are out of luck.

[5:39:30](#9RLquDy3kmwJNfM--VL2-G9TmkzcGfO6h2DKyZ1gxnw) <Oldes (@oldes.h:matrix.org)>:
Not to mention that you still don't understand, that although it could make your code to look shorter, inside the runtime it would be flooded with exceptions which would be necessary everywhere and every time.

[5:46:56](#zUyOXSNYJ3smDJVq7WkPY_WauTDM_KkNfM-2efUb_nc) <Oldes (@oldes.h:matrix.org)>:
And `any` returns `none` only when there were no truthy values in the block, so it cannot _break at falsey container_.

[5:50:38](#ziBRctEASyw89CAsU94eZmcAZiYii5_s0m2R1IzqMQ0) <Oldes (@oldes.h:matrix.org)>:
And `any` returns `none` only when there were no truthy values in the block, so it cannot _break at falsey container_.

[7:39:52](#iiwogNeocblq12OHByqSn-ljhV-ZAGYIIuZ6kZhxueU) <hiiamboris>:
Ì†æÌ¥¶‚Äç‚ôÇÔ∏è This whole notion of changing the language for the sake of getting one function right reminds me of the old joke *'how many persons are needed to change a light bulb near the ceiling?'

[7:40:00](#Vxie4h5V-Mxh_Zn5k4o9iuJSV0ekeDUS1iNyA0ktPFw) <hiiamboris>:
* Ì†æÌ¥¶‚Äç‚ôÇÔ∏è This whole notion of changing the language for the sake of getting one function right reminds me of the old joke *'how many persons are needed to change a light bulb near the ceiling?'*

[9:02:05](#0mTzSBN--c4F2pRIKSmFhzO6_9H2FrGFSTbFF7e3B9A) <Oldes (@oldes.h:matrix.org)>:
This is my last chance to get you on the right track GiuseppeChillemi (GiuseppeChillemi) 
```
safe-select: function[container key][
	any [
		value: select container :key
		either find container :key [
			value
		][	make error! "Key not found!" ]
	]
]
select-with-check: function[container key types [typeset!]][
	value: safe-select container key
	either error? :value [
		print ["Something went wrong for reason:" value/arg1]
		;; do something with this situation?
	][
		unless find types type? :value [
			return make error! "Not expected type of value!"
		]
	]
	value
]

obj: [a: 1]
select-with-check obj 'a number! ;==  1
select-with-check obj 'b number! ;== ** User error: "Key not found!"
select-with-check obj 'a any-string! ;== ** User error: "Not expected type of value!"

```

[9:07:44](#5il8sFoSitGwdXr0KvuRkRWk_uhFfy1_f3yyHc8qu7o) <Oldes (@oldes.h:matrix.org)>:
* This is my last chance to get you on the right track GiuseppeChillemi (GiuseppeChillemi)

```
; Function to safely select a value from a container.
; If the key is not found, it returns an error.
safe-select: function [
    container [object! block! map!] ; The container to select from.
    key [word! string!] ; The key to select.
][
    any [
        ; Attempt to select the value using the provided key.
        value: select container :key
        
        ; Check if the key exists in the container.
        either find container :key [
            ; If the key exists, return the selected value.
            value
        ][
            ; If the key does not exist, return an error.
            make error! "Key not found!"
        ]
    ]
]

; Function to select a value from a container with type checking.
; If the value is not of the expected type, it returns an error.
select-with-check: function [
    container [object! block! map!] ; The container to select from.
    key [word! string!] ; The key to select.
    types [typeset!] ; Optional set of expected types.
][
    ; Use safe-select to get the value, handling potential errors.
    value: safe-select container key
    
    ; Check if an error occurred during selection.
    either error? :value [
        ; If an error occurred, print the error message.
        print ["Something went wrong for reason:" value/arg1]
        ; You might want to add additional error handling here.
    ][
        ; If no error occurred, check if the value is of an expected type.
        unless find types type? :value [
            ; If not, return an error.
            return make error! "Not expected type of value!"
        ]
    ]
    
    ; If all checks pass, return the selected value.
    value
]

obj: [a: 1]
select-with-check obj 'a number! ;==  1
select-with-check obj 'b number! ;== ** User error: "Key not found!"
select-with-check obj 'a any-string! ;== ** User error: "Not expected type of value!"

```

[9:19:02](#5YPrOIpCDnH63NPzIoryfN5qRpIPnshz04u4Z86-7ag) <Oldes (@oldes.h:matrix.org)>:
`safe-select` should be pretty fast as in the most cases the `find` call wouldn't be needed, because the key would usually exist and its value will not be `none`.

[9:19:34](#YpV_jQcCKMu6Qv5TaaP4_ZCqXa9IqAeVS0c8dX2Y1c0) <Oldes (@oldes.h:matrix.org)>:
You can merge these functions if needed and or extend with other tests.

[14:01:47](#tfe9ZCkPXnshNrFBmqvE_jTnR_tuIzbgubwVC8e4_zY) <GiuseppeChillemi (GiuseppeChillemi)>:
I see clear advantages for this new logic and because I had the idea, it is normal I am the only one actually seeing an use of it. 
About the function you have written Oldes you are right, it can be done this way but you are missing one important point that your have already aknowledged with your observation on truthy errors:

```
all [
  a: select-with-check container key types
  b: select-with-check container key2 types
  c: select-with-check container key3 types
  f: select-with-check container key3 types
]
```
In this situation, only an additional `error? try` could break the loop. But in this case you loose the reason why it has happened and also where it has happened.
Instead, if having a negative falsey container and short circuit returning it, you have the information and ZERO ADDITIONAL CODE is needed.

[14:02:05](#0NFaXWYThpY0OKEg8TDmHvJ4ZWuP6WnxRPjUxRRY7bA) <GiuseppeChillemi (GiuseppeChillemi)>:
* I see clear advantages for this new logic and because I had the idea, it is normal I am the only one actually seeing an use of it.

About the function you have written Oldes you are right, it can be done this way but you are missing one important point that your have already aknowledged with your observation on truthy errors:

```
all [
  a: select-with-check container key types
  b: select-with-check container key2 types
  c: select-with-check container key3 types
  f: select-with-check container key3 types
]
```

In this situation, only an additional `error? try` could break the loop. But in this case you loose the reason why it has happened and also where it has happened.
Instead, if having a negative falsey container and short circuit returning it, you have the information and ZERO ADDITIONAL CODE is needed.

[14:02:33](#_ppyP0mCvanlPpu2veh68qmVEPkIAy-EbxlHBB5D-bE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I see clear advantages for this new logic and because I had the idea, it is normal I am the only one actually seeing and projecting an use of it.

About the function you have written Oldes you are right, it can be done this way but you are missing one important point that your have already aknowledged with your observation on truthy errors:

```
all [
  a: select-with-check container key types
  b: select-with-check container key2 types
  c: select-with-check container key3 types
  f: select-with-check container key3 types
]
```

In this situation, only an additional `error? try` could break the loop. But in this case you loose the reason why it has happened and also where it has happened.
Instead, if having a negative falsey container and short circuit returning it, you have the information and ZERO ADDITIONAL CODE is needed.

[14:09:20](#rRl8mMUk6NfwCGZxg68SPQ6FqFl4qDqAgp6VjRdKDNs) <GiuseppeChillemi (GiuseppeChillemi)>:
You have talked about falsey `error!`s. I don't like it because you need additional data together with the error, like the internal checks.

Just one container can be implemented: a copy of `map!`, a falsey `map!` and modifications on `any` and `all` to return the falsey map! instead of `none` when the return value is it. 

[14:09:43](#oJanEuri3AqpZvR4AgxVnGdMQCU5JxdPKl91rj44hwI) <GiuseppeChillemi (GiuseppeChillemi)>:
* You have talked about falsey `error!`s. I don't like it because you need additional data together with the error, like the internal check flags

Just one container can be implemented: a copy of `map!`, a falsey `map!` and modifications on `any` and `all` to return the falsey map! instead of `none` when the return value is it.

[14:10:18](#D2y-0I49ejt03nZfZhIcUmnNVESOld8X0xCPbQi4AVI) <GiuseppeChillemi (GiuseppeChillemi)>:
* I see clear advantages for this new logic and because I had the idea, it is normal I am the only one actually seeing and projecting an use of it.

About the function you have written Oldes you are right, it can be done this way but you are missing one important point that your have already aknowledged with your observation on truthy errors:

```
all [
  a: select-with-check container key types
  b: select-with-check container key2 types
  c: select-with-check container key3 types
  f: select-with-check container key3 types
]
```

In this situation, only an additional `error? try` and an internal `cause-error` could break the loop. But in this case you loose the reason why it has happened and also where it has happened.
Instead, if having a negative falsey container and short circuit returning it, you have the information and ZERO ADDITIONAL CODE is needed.

[14:10:20](#DPWO5O5qX0hTGKZF9bVeqeCgQtdxCcTFC1K3guXI5Qg) <rebolek (Boleslav B≈ôezovsk√Ω)>:
so you want for every map a copy of it that would be used only by `any` and `all`?

[14:11:22](#kbwtsZGbSbLyniZuYCSirCvp7lsqNTUzuGri8VkhoXg) <GiuseppeChillemi (GiuseppeChillemi)>:
No, I am proposing a falsey map that pass thru `any` and `all` as reasult when they break because of a falsey value.

[14:11:33](#2Y1omcXtAB0a6NHrg5DtAkf_MqkCVOnwAPgRd5HSCyM) <GiuseppeChillemi (GiuseppeChillemi)>:
* No, I am proposing a falsey `map!` that pass thru `any` and `all` as reasult when they break because of a falsey value.

[14:12:52](#OedAX1nJJghuLRvwvlvzOHAllKJLt0otABKfxiS52As) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I can't see any advantage, can you describe a real world example how it would be used?

[14:22:20](#smGNFQUPfLadf-862fi4OU__xPMfUIBrMtaXnLkj2P8) <GiuseppeChillemi (GiuseppeChillemi)>:
I have written before but I can repeat: having a rich return container that could have all the information you need.
In this case, if `select-with-check` fails the function would return:
`#[key: a-key cause: 'type-mismatch container: container-here]`

The above example over all:

```
result: all [
  a: select-with-check container key types
  b: select-with-check container2 key2 types
  c: select-with-check container3 key3 types
  f: select-with-check container3 key3 types
]
```
You would have the exact cause of the failure on RESULT.

You can use it everywhere you need to a short-circuit or having 
```
either result: >function< [normal-return] [check result and
 do something based on content]
```
Actually we have no way of having a FALSEY result and at the same time the result without passing a container via refinement like [function/state ... state-container`. In my solution, the state/data container is the result

[14:22:55](#QmSiQE8JroxXcFaIbYlJtSEwcfGige54wWGYsfRWaAE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have written before but I can repeat: having a rich return container that could have all the information you need.
In this case, if `select-with-check` fails the function would return:
`#[key: a-key cause: 'type-mismatch container: container-here]`

The above example over all:

```
result: all [
  a: select-with-check container key types
  b: select-with-check container2 key2 types
  c: select-with-check container3 key3 types
  f: select-with-check container3 key3 types
]
```

With a falsey contaienr, you would have the exact cause of the failure on RESULT.

You can use it everywhere you need to a short-circuit or having

```
either result: >function< [normal-return] [check result and
 do something based on content]
```

Actually we have no way of having a FALSEY result and at the same time the result without passing a container via refinement like \[function/state ... state-container\`. In my solution, the state/data container is the result

[14:23:40](#FRhKDQJIqo5PMPNaS7bvydLL0lyP7lVOqSnAUIPvMMA) <GiuseppeChillemi (GiuseppeChillemi)>:
* I have written before but I can repeat: having a rich return container that could have all the information you need.
In this case, if `select-with-check` fails the function would return:
`#[key: a-key cause: 'type-mismatch container: container-here]`

The above example over all:

```
result: all [
  a: select-with-check container key types
  b: select-with-check container2 key2 types
  c: select-with-check container3 key3 types
  f: select-with-check container3 key3 types
]
```

With a falsey contaienr, you would have the exact cause of the failure on RESULT.

You can use it everywhere you need to a short-circuit or having

```
either result: >function< [normal-return] [check result and
 do something based on content]
```

Actually we have no way of having a FALSEY result and at the same time DATA without passing a container via refinement like [function/state ... state-container`. In my solution, the state/data container is the result

[14:23:58](#MUAMrA4nbJtkb-ZV9sv-YQklKlh9Jfruoa0NfLoFy84) <GiuseppeChillemi (GiuseppeChillemi)>:
(Or having a combined return to extract from)

[14:24:08](#wJ-51eWN3BQ5AaiqebJ1nLvNbnAeOzOW_KWwjMtP0Ic) <rebolek (Boleslav B≈ôezovsk√Ω)>:
> having a rich return container that could have all the information you need

need for what? 

[14:25:07](#3GhyRHq1_VFpMPcdPTx1TpmxUm98UaA_T7uZ06mv1rk) <GiuseppeChillemi (GiuseppeChillemi)>:
Knowing the failed key, the failed datatype, having a pointer of a row in database. The fantasy is the limit

[14:25:22](#RnsqmtmfAeGuDkq16ZRe6v6NVxHCCdUdG151m-UzNrw) <rebolek (Boleslav B≈ôezovsk√Ω)>:
But how is the key failed? `map!` returns `none` for non-existing keys by design. If it's a problem, there are other data structures that don't do it.

[14:25:41](#yBh3As7sQLBqTuny0wumMXa_YnNlyUkaSUMn9kQo-fE) <rebolek (Boleslav B≈ôezovsk√Ω)>:
just use the right tool for the job

[14:26:48](#zWk219OzkC3oBGJGU-5iWKX12wmcEiDdd5bL4r6-ODM) <GiuseppeChillemi (GiuseppeChillemi)>:
You are mixing things: `select-with-check` is the one returning the falsey map, and not a direct `map!` selection.

[14:27:52](#EQQvWxxnWDQRP7qbmoviTI0NxSKYtOeAAzcdcfbm5Fo) <GiuseppeChillemi (GiuseppeChillemi)>:
You select a key in a container with a function and `select-with-check` will return you the falsey `map!` with all the information you need in case of failure of any of the tests

[14:36:24](#SzlbTAkR8d_qoxGWUH3rVoRXyscQ-ACQQQmcl0z2irk) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I was curious at some real-world example, but this is just too abstract to understand why it's useful

[14:39:58](#lMqrzfB1oox7zVA54ZIbWEiNT1Am1T1eFd4P_sOiOFE) <GiuseppeChillemi (GiuseppeChillemi)>:
Check this block:

```
[
  a: 22
  b: 33
  c: "string"
]
```
Using these specs
```
[
  a: [integer!]
  b: [integer!]
  c: [integer! string!]
]
```
It is just an `all` and you have full fail information on the returned falsey `map!`

[14:48:13](#0IXXJJy4Yzsk9sqDDNxXbFXveHPEcKNMau4UNJOzA4A) <rebolek (Boleslav B≈ôezovsk√Ω)>:
so you want typed blocks?

[14:55:16](#whogTYLCFJs4cNnsqyaOOw3XOp_Dld_D3kChFLG50WU) <GiuseppeChillemi (GiuseppeChillemi)>:
What you mean for typed block? Because for me it has another meaning: a block with a datatype associated but free content.

## 25-Mar-2025

[7:58:49](#3nXdXdKwmzru9qtKBzoJTpp49PqKH0pNr713sZVTasc) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I have to answer with a counter-question. What do you mean with above specs?

[9:16:12](#ZAAr84u7lUi2rgoME8vtPkOokB6sbFQm99M_MdIHhho) <GiuseppeChillemi (GiuseppeChillemi)>:
Specify the possibile datatypes of the values of a key 

[11:15:55](#_eVXK1_7dqCdQhT_A4wkQXqZPHn090F4gqbif1KqACU) <rebolek (Boleslav B≈ôezovsk√Ω)>:
yeah, but there are no keys in `block!`. It makes sense for `object!`or `map!` though

[11:21:10](#YNu1CYyOBCXYqMIx5opi86HTDam_Xjv_U9r2t1tTuh0) <GiuseppeChillemi (GiuseppeChillemi)>:
The second one is the specs block to validate the first. In fact it has born to parse both datatypes you have mentioned. 

[11:26:59](#w8I2e_7OjESaZ3ua9WoyTdOBt8UdZh2tUBqlni7re7o) <GiuseppeChillemi (GiuseppeChillemi)>:
and also blocks organized as key/values

[13:18:04](#62nLm8_2Te0l-APiI6Gvmfjvf4fgVLyyjwMCnTAr5p4) <GiuseppeChillemi (GiuseppeChillemi)>:
I am working to unify the selection of keys/values on different containers. Too many manipulation methods when the coder has structured data with characteristic common to every container. When your read just KEYS-OF and PUT- PAIR or SELECT-PAIR, SET-ALL while working on a vid actors block becoming objects, or converting them to map or checking keys, you use always the same words. Instead now you must EXTRACT data 2  for blocks, PUT FIND/SKIP, SELECT, SELECT SKIP, CLEAR ... WORDS OF. Its is too much excessive mental fatigue. You are forcing the brain to infeer the structure the data is referring too, using different visual symbols (the set of words and different code phrase). It is a NO NO for people like me with creative mind and intense mental activity.

[13:19:21](#VYitHQRrHVxp2eUlGoo8MowfmF1MsIzmyog5Mmt1pbE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I am working to unify the selection of keys/values on different containers. Too many manipulation methods when the coder has structured data with characteristic common to every container. When your read just KEYS-OF and PUT- PAIR or SELECT-PAIR, SET-ALL while working on a vid actors block becoming object, or converting them to map or checking keys, you use always the same words. Instead now you must EXTRACT data 2  for blocks, PUT FIND/SKIP, SELECT, SELECT SKIP, CLEAR ... WORDS OF. Its is too much excessive mental fatigue. You are forcing the brain to infeer the structure the data is referring too, using different visual symbols (the set of words and different code phrase). It is a NO NO for people like me with creative mind and intense mental activity.

[13:21:02](#E-e_ZUXX24Oxd5QXtA_D4Q49QfuQ-IWFeCK6bsvjVhE) <GiuseppeChillemi (GiuseppeChillemi)>:
* I am working to unify the selection of keys/values on different containers. Too many manipulation methods when the coder has structured data with characteristic common to every container. When your read just KEYS-OF and PUT- PAIR or SELECT-PAIR, SET-ALL while working on a vid actors block becoming object, or converting them to map or checking keys, you use always the same words. Instead now you must EXTRACT data 2  for blocks, PUT FIND/SKIP, SELECT, SELECT SKIP, CLEAR ... WORDS OF. Its is too much excessive mental fatigue. You are forcing the brain to infeer the structure the data is referring too, using different visual symbols (the set of words and different code phrase). It is a NO NO for people like me with creative minds and intense mental activity. (or also called ADHD, which is an hillness for someone or a blessing when you love the creativity you have and use it in your daily life)

[13:32:41](#PXeaOABn5wBULnheV3PtOPGe8qbWSfyfJFaZruZFTog) <GiuseppeChillemi (GiuseppeChillemi)>:
* I am working to unify the selection of keys/values on different containers. Too many manipulation methods when the coder has structured data with characteristic common to every container. When your read just KEYS-OF and PUT- PAIR or SELECT-PAIR, SET-ALL while working on a vid actors block becoming object, or converting them to map or checking keys, you use always the same words. Instead now you must EXTRACT data 2  for blocks, PUT FIND/SKIP, SELECT, SELECT SKIP, CLEAR ... WORDS OF. Its is too much excessive mental fatigue. You are forcing the brain to infeer the the data structure the code is referring too, using different visual symbols (the set of words and different code phrase). It is a NO NO for people like me with creative minds and intense mental activity. (or also called ADHD, which is an hillness for someone or a blessing when you love the creativity you have and use it in your daily life)

[13:57:09](#0efBGGevxSZ-_no08pNhc5bAnrFm_Yt82bzQMGpER28) <GiuseppeChillemi (GiuseppeChillemi)>:
* I am working to unify the selection of keys/values on different containers. Too many manipulation methods when the coder has structured data with characteristic common to every container. When your read just KEYS-OF and PUT- PAIR or SELECT-PAIR, SET-ALL while working on a vid actors block becoming object, or converting them to map or checking keys, you use always the same words. Instead now you must EXTRACT data 2  for blocks, PUT FIND/SKIP, SELECT, SELECT SKIP, CLEAR ... WORDS OF. Its is too much, it causes excessive mental fatigue. You are forcing the brain to infeer the the data structure the code is referring too, using different visual symbols (the set of words and different code phrase). It is a NO NO for people like me with creative minds and intense mental activity. (or also called ADHD, which is an hillness for someone or a blessing when you love the creativity you have and use it in your daily life)

[14:19:58](#bs-NdpVmFn7K7U1pVCSebGMkj434UnBP3pbj3WcOTE8) <rebolek (Boleslav B≈ôezovsk√Ω)>:
but that's not guaranteed. `block!` is free-form and *may* be used as key/value storage but it's not one. It's a foolish endeavour to treat it as one and ignore its other properties.

[14:23:54](#q5-8ZrxQJRIGxpqec_nzXTI3JEnHyhZJQvrtN-GMR5E) <rebolek (Boleslav B≈ôezovsk√Ω)>:
> I am working to unify the selection of keys/values on different containers.

And I think this is the main problem. Different types have different access methods precisely because they are different. The datatypes exist for a reason. Trying to put them all in place is wrong approach and will fail.

[14:27:17](#41u-x2Lj3U-NEvnWtCyaWsYN2LkZp7rAtbnmYcbBWak) <rebolek (Boleslav B≈ôezovsk√Ω)>:
Maybe you should take a look at Lua. It's a nice little language with just one structure, `table` (ok and `meta-table`); which is more or less like `map!`; so the access is unified. I guess it would fit your fit your model more than the wild west of redbol datatypes.

[14:28:13](#0LeeLTWWu0j-8C1BDPa6bJsuDjSw7QlmZXKbdjzsQXs) <rebolek (Boleslav B≈ôezovsk√Ω)>:
* Maybe you should take a look at Lua. It's a nice little language with just one structure, `table` (ok and `meta-table`); which is more or less like `map!`; so the access is unified. I guess it would fit your model more than the wild west of redbol datatypes.

[14:30:39](#91NI3cSCsj2WV1ohH1VgBRJ3M_6yfbkx-1Q2dyGRTJc) <GiuseppeChillemi (GiuseppeChillemi)>:
In have written a specific phrase for this: "when the coder has structured the data with characteristic common to every container". I do not mean that we must have ALWAYS an unique function which does the same thing in all container.  It is needed ONLY when you are working with data compatibile to alla containers. Actors are a good example: they have all ANY-WORD as keys. 

[14:31:24](#OXDO3-eJJ3hQGMDQ9IQv5R5TpW0PMVRZhHp90eY7G_Q) <GiuseppeChillemi (GiuseppeChillemi)>:
* In have written a specific phrase for this: "when the coder has structured the data with characteristic common to every container". I do not mean that we must ALWAYS have an unique function which does the same thing in all container.  It is needed ONLY when you are working with data compatibile to alla containers. Actors are a good example: they have all ANY-WORD as keys. 

[14:31:40](#6B_gTN7egbwfwuElsW-Y7mwQV2EwoVsaZL-qcsC1T9M) <GiuseppeChillemi (GiuseppeChillemi)>:
* In have written a specific phrase for this: "when the coder has structured the data with characteristic common to every container". I do not mean that we must ALWAYS have an unique function which does the same thing on all containers.  It is needed ONLY when you are working with data compatibile to alla containers. Actors are a good example: they have all ANY-WORD as keys. 

[14:31:55](#1nj2JfinZN-2hNaBpObguhLmyIvPEVyxf9i6uek1Xqw) <GiuseppeChillemi (GiuseppeChillemi)>:
* In have written a specific phrase for this: "when the coder has structured the data with characteristic common to every container". I do not mean that we must ALWAYS have an unique function which does the same thing on all containers.  It is needed ONLY when you are working with data compatibile to all containers. Actors are a good example: they have all ANY-WORD as keys. 

[14:32:23](#iS4Haqcp-NfRLcMLYoga6ZXvHkLAklDJG_TkwkVRfg4) <GiuseppeChillemi (GiuseppeChillemi)>:
* In have written a specific phrase for this: "when the coder has structured the data with characteristic common to every container". I do not mean that we must ALWAYS have an unique function which does the same thing on all containers.  It is needed ONLY when you are working with data compatibile to all containers. Actors are a good example: they have all ANY-WORD! as keys.

[14:33:19](#7PeX4XRYxmQMFrVTq-rX98HQF0vDY5R_e-wl955Gm28) <GiuseppeChillemi (GiuseppeChillemi)>:
(I mean during creation/access you are in the same datatypes family, because words must be converted to set words for object proto)

[14:34:32](#eD4v0BRIG20Gjlu3Hv_7iRpN-Nen0_MLI-b7R5w64Cc) <rebolek (Boleslav B≈ôezovsk√Ω)>:
> It is needed ONLY when you are working with data compatibile to all containers.

yet, you want to add stuff that would slow down operation in  every situation just for this one edge case

[14:37:20](#CdU2ZA3TxgXWIp_C0O5Y606lCXFnI-ffboLPtxDcTks) <GiuseppeChillemi (GiuseppeChillemi)>:
You are right, but as hiiamboris: would say, first create, then optimize. I am in the creation phase, when the commands and phrasing will be complete I will optimize converting everything in R/S or maybe a KEYPAIR datatype.

[14:37:36](#MsbIW3vSTlic9mx0HRgoxcF-9BiZfeMoPywY2rebuSU) <GiuseppeChillemi (GiuseppeChillemi)>:
* You are right, but as 
@hiiamboris:tchncs.de: would say, first create, then optimize. I am in the creation phase, when the commands and phrasing will be complete I will optimize converting everything in R/S or maybe a DUO datatype.

[14:38:41](#YxPMWgq0YoXsk7SpO6MUIehiUvA-LPjUcg8az-Z4xIk) <rebolek (Boleslav B≈ôezovsk√Ω)>:
good luck then!

[14:40:42](#mRDWswcRNnztm_eeEPD5fkOPdXTMrn3bpP10mG-3-vw) <rebolek (Boleslav B≈ôezovsk√Ω)>:
but I think that the main trouble with key/value pairs is not accessing individual key or value but to find the key among millions of them 

[14:41:26](#CJ24KCprVkc1TAIc50-q1A6czBP9IbVxUG1sLWYWNtk) <GiuseppeChillemi (GiuseppeChillemi)>:
In which sense? 

[14:41:54](#q-u98vlNswUFCJcR5jwEhZu89bioaRyZuTjMjQrUHHY) <GiuseppeChillemi (GiuseppeChillemi)>:
Don't we already have FIND/SKIP?

[14:45:38](#O8mwcPZwDxiAxAAK400jlMN8jA65pu3mKVFXnRt0Z1s) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I mean at low level. 

[15:34:31](#CH8kP-epqxAtIS6ZYzxe6LXXbHkMVtLWyjGMoCVjeUk) <GiuseppeChillemi (GiuseppeChillemi)>:
Do you mean with large datasets of key/valuesin a block?

[15:34:38](#sUv-p2ooN7URjKuylL16qAT6qoRsUkOyctJjg9-Jtq4) <GiuseppeChillemi (GiuseppeChillemi)>:
* Do you mean with large datasets of key/values in a block?

[15:35:41](#LxHHrQL7RMfahsMiyfsWs8czohrj21ohjA1D2192aNw) <rebolek (Boleslav B≈ôezovsk√Ω)>:
yes

[15:35:52](#svxE2WS8k9CUXtufVRFYvIoiCRX0C63ae7alaVv0Too) <GiuseppeChillemi (GiuseppeChillemi)>:
In this case you are right but it is not the target use. For million of key/values we need rows, block of maps, hash.. 

[15:36:10](#qW_DzqCWM7TjYpglMq2tToM9KFWg02E0NwPGK-EaCeI) <GiuseppeChillemi (GiuseppeChillemi)>:
It is just for trasformations of small containers. 

[15:36:12](#Dqa4OR9IZ6KxSGJRfaytVGwqgCX4GR2rZRTXnk_YaiE) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I still don't get what is the target use.

[15:39:04](#yS96jHkVIPMJvy040hH-68dN7Ygn015Z-tCEEfIHllc) <GiuseppeChillemi (GiuseppeChillemi)>:
I will show you when my work will be complete in the specific task I am working onto. It is a simple one but I admit it has generated me a lot of confusion changing from a way to express things to another. My code was a puzzle for me and I have often ended in confusion trying to refocus on the task. 

[15:39:53](#dsPpt4TGihSrmu1I-3T5W8qJ9o4RrB5jZgAtJw1dAqA) <rebolek (Boleslav B≈ôezovsk√Ω)>:
OK, I'll wait, but I guess the solution could be simpler than this

[15:43:21](#Y-rk40EC7Naz8bJF5Bp7I-HTrn8wyxh5SgtxBVJE21g) <GiuseppeChillemi (GiuseppeChillemi)>:
Yes but not mentally. Too many symbols overload the focus system, reading continuously switching from a phrasing with a set of words to another that do the same task with another set. Yesterday I have finally had a small set of commands and I have regained the focus. It is a symbol overload.

[15:43:29](#riQf0j1weyPwCeAPqnDxdiYLr29uZ3h8o28CFOc_w-Y) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes but not mentally. Too many symbols overload the focus system, reading continuously switching from a phrasing with a set of words to another that do the same task with another set. Yesterday I have finally had a small set of commands and I have regained the focus. 

[15:44:25](#0eaieBnZB6t-3KR8nzl969ziAECQfUXRvFmdkdViUHs) <GiuseppeChillemi (GiuseppeChillemi)>:
* Yes but not mentally. Too many symbols overload the focus system, reading and continuously switching from a phrasing with a set of words to another that do the same task with another set. Yesterday I have finally had a small set of commands and I have regained the focus. 

[15:45:01](#nznuYayJLwopGvLrzvnntpXxZhsxFRVLuf6guQAmM-g) <rebolek (Boleslav B≈ôezovsk√Ω)>:
As I said, look at Lua, it's a very nice minimalistic language that won't cause any cognitive overload (maybe when dealing with stack, but if you're not writing C extensions, you can happily forget about it).

[15:46:18](#BgUgf-YoPg-ykdvjS-MJoPAFGd9qLV5bxBtgOwUVAbY) <GiuseppeChillemi (GiuseppeChillemi)>:
It is on my plan but I love Red. For the next years we must stay together! :D

[16:19:44](#hyZnCoSBw3LPZDVhX6hestJimefC1yhk101zIwTONfc) <GiuseppeChillemi (GiuseppeChillemi)>:
Please, look at here: isn't it easier to read?

[16:20:26](#KYTzh8IGg4lPRgx6cJdaLSwkB1aU12nTiaSwoMlkYW8) <GiuseppeChillemi (GiuseppeChillemi)>:
Please, look at here: isn't it easier to read?

[16:22:48](#hLy1_Za_2_tOREHCbYJhznxGrUb0ZfcWBxKMAUZ_7S4) <GiuseppeChillemi (GiuseppeChillemi)>:
![](https://gitter.ems.host/_matrix/media/v3/download/gitter.im/63d05c0a3f43126acfafbfb193efa5ba85cd72e71904569664273383424)

[16:23:28](#2EsX7xbK0qzMqxKp7qJNzZ271LhidZTKQi6deEHWKVs) <rebolek (Boleslav B≈ôezovsk√Ω)>:
easier to read compared to what?

[16:25:21](#R0RJzMMw-VKHMoxLi70p_yhGZx-Q-MSNht0VNmCzd-Y) <GiuseppeChillemi (GiuseppeChillemi)>:
Think about getting all the keys, either coming from `block` or an `object`, checking the values datatypes or the values options. Four linesthat covers all the containers and combinations.

[16:25:40](#SMwO8zt7MTpyx-vGyAzj-uZyy_3cQp7kGvl1BrqRM_I) <GiuseppeChillemi (GiuseppeChillemi)>:
* Think about getting all the keys, either coming from `block` or an `object`, checking the values datatypes or the values options. You have just four lines that covers all the containers and combinations.

[16:25:48](#GxhXgrS2WufGA_3Ro5pCr-u9B43QeR4_lV4QFtcTme4) <GiuseppeChillemi (GiuseppeChillemi)>:
* Think about getting all the keys, either coming from `block` or an `object`, checking the values datatypes or the values options. You have just four lines that cover all the containers and combinations.

[16:26:05](#wHWkDDXMbxZokO5Rvwi0tBAox_6EFhZSzRABUf5-ug4) <rebolek (Boleslav B≈ôezovsk√Ω)>:
I can't think about getting all keys from `block!` as there are none.

[16:27:44](#EohWoArsSOG44rtqyynai-HkBC7wM3OBz137ELjcaF0) <GiuseppeChillemi (GiuseppeChillemi)>:
If you have: 

```
   [
      on-change []
      on-resize []
      on-select []
    ]
```

And write `select/skip ... .. 2` it has keys


[16:28:02](#oMYybAGqo6WkOn6Nmq_iynJBa4jf7-NLDIvsgrRrrVQ) <GiuseppeChillemi (GiuseppeChillemi)>:
* If you have:

```
   [
      on-change []
      on-resize []
      on-select []
   ]
```

And write `select/skip ... .. 2` it has keys

[16:29:28](#2uXOUxLBAZzntgdfZ2Po1BXH4m2txPfCRkfWAo10qYQ) <GiuseppeChillemi (GiuseppeChillemi)>:
And it is the proto that will have its keys converted to `set-word` and then will become an object or a map, depending on the use

[16:30:58](#GZHeetPuS4nsDKxKUI5B-gKYCyVd5T0O0peUlBu8lw8) <GiuseppeChillemi (GiuseppeChillemi)>:
Obviusly they are not real keys but apparent keys, created by the `select/skip` command.

[16:31:01](#8nALevl0kXWA2-p1ZEZUQlQEBK7_TDS3w0JbiDA35XM) <rebolek (Boleslav B≈ôezovsk√Ω)>:
in this special case, yes. and if I decide to write 
```
[
    john age 35 instrument guitar vocalist
    paul age 33 instrument bass guitar vocalist spouse linda
]
```
I also have keys. And your tool wouldn't identify them.

[16:33:47](#z9wGo8e5Hrg9oFVXaD4QH9OMsP7JU77Pey4qaT8JVXc) <GiuseppeChillemi (GiuseppeChillemi)>:
Their are not pairs. The target use is on couples `key/value`
But if you want to cover your case, I have a `find-column` which could find John even if you put in third position and return the start of the row.

[16:34:43](#G77_ayjJIgSsZDJxnKShqwJh9N9jtvxYR4Q_OL4IVWw) <rebolek (Boleslav B≈ôezovsk√Ω)>:
If I want to use `key/value` pairs, I would use `map!` which is made exactly for that use-case.

[16:38:18](#PpdMdVdDi6O6s6vT7QpYB5Y2jkMTyJWvZmQ3rCVO49E) <GiuseppeChillemi (GiuseppeChillemi)>:
I would use it too! But as I often convert and map to block, because we dont have  a direct to-object command, and I need to manipulate it in the middle, I find those little commands useful using an unique commands set.


[16:38:52](#F8NK1OpPXDccXOdA0rpK_GgBe96BBzRsXsjWKYuv7DU) <rebolek (Boleslav B≈ôezovsk√Ω)>:
Ok, I'm getting lost now. Why do you need so much conversions? 

[16:39:43](#bJfsWwiqcHVooLQuvIuRh2OWEOEB_dKRMUs8yudy_AY) <GiuseppeChillemi (GiuseppeChillemi)>:
The next task will be adding a `/SHAPE` refinement to `key-select` and all the other functions.

[16:39:57](#JMSwwFv0ZbT3jojdW7PJg5U1NT1pkKWXie_mdAl0gbo) <GiuseppeChillemi (GiuseppeChillemi)>:
So it will cover your block too

[16:40:08](#eFJ-r-viD3X-H3iCdAJB5Sqe6Rr7LXAoJkgbHWC5r-Q) <GiuseppeChillemi (GiuseppeChillemi)>:
(and all the others)

[16:40:26](#EhFA1YK45GYIPr46hEegnBQpPeJCjDcBe82Yg1rLiVs) <rebolek (Boleslav B≈ôezovsk√Ω)>:
please notice that in my block records have variable length

[16:43:31](#7WVix78JqXsYVKWmam3hovEt3VGj1CGKusNmxFJ4clM) <GiuseppeChillemi (GiuseppeChillemi)>:
I hand't notice, thanks. In fact your is a specific `MAP` use case. i work mostly with fixed size rows that can't be covered without having a rows containers with key/values pairs on another block per line with keys matching by pos.

[16:46:12](#OMjvNxWd0aHafxjE7YC5dyPYstHh39JpMXTZlXmXDus) <GiuseppeChillemi (GiuseppeChillemi)>:
It is a taske of `/shape` manger to let you see this structure in a common way. But we are moving to the wider datatypes manager topic and I am still not there. It would be highly inefficient in this case but that is the idea in mind.

[16:46:23](#Pa7_otCwXbHeXMInzttB2fFAEfKouKrxpbh6yVY_HmI) <GiuseppeChillemi (GiuseppeChillemi)>:
* It is a task of `/shape` manger to let you see this structure in a common way. But we are moving to the wider datatypes manager topic and I am still not there. It would be highly inefficient in this case but that is the idea in mind.

[16:49:22](#IBhuU8OaO3Arlvcg_MrEEuhoMAW3U6DMksaM_A3x8PM) <rebolek (Boleslav B≈ôezovsk√Ω)>:
Anyway, I certainly would welcome tools that would make it easier to work with block that 's basically a sheet, no doubt about that. But I'm not at all convinced there's need to change the language to handle some edge cases which I actually still haven't learned about. 

I understand your motivation and I guess those functions may be of some use but I still haven't got an answer to my question, why change the language.

[17:00:07](#EtPoEtq4pt45xpLxD3cxjuqaApAGjZZHn9293kg_2zM) <GiuseppeChillemi (GiuseppeChillemi)>:
I don't want to change the language. I would like to add a limited subset of commands for this kind of data. 
More generally, I would like to add Red custom types using a an upper level shape manager. 
There are 2 solutions: 
1) Make an enourmous low level change
2) Using upper level `shape` manager with minimal footprint. 
To implement #2 without cluttering the core data, is the reason why I have recently asked for a sidecar for Red container, or PAIR! (Datatype) like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by miself the the "sidecar" approach.

[17:00:31](#X3CAEJNLJLzH_WwEwHeSVllyg0rPGgSycNNfEdggXuI) <GiuseppeChillemi (GiuseppeChillemi)>:
* I don't want to change the language. I would like to add a limited subset of commands for this kind of data.
More generally, I would like to add Red custom types using a an upper level shape manager.
There are 2 solutions:

1. Make an enourmous low level change
2. Using upper level `shape` manager with minimal footprint.

To implement #2 without cluttering the core data in a container is the reason why I have recently asked for a sidecar for Red container, or PAIR! (Datatype) like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by miself the the "sidecar" approach.

[17:00:41](#FY-LDnuknLTQz1NmRHiuqZQj9o0Y_DBW0sMpwu7edr8) <GiuseppeChillemi (GiuseppeChillemi)>:
* I don't want to change the language. I would like to add a limited subset of commands for this kind of data.
More generally, I would like to add Red custom types using a an upper level shape manager.
There are 2 solutions:

1. Make an enourmous low level change
2. Using upper level `shape` manager with minimal footprint.

To implement #2 without cluttering the core data in a container is the reason why I have recently asked for a sidecar for Red data containers, or PAIR! (Datatype) like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by miself the the "sidecar" approach.

[17:00:56](#vB4MqQ51jurO7KdP7nJ_lS_5W5ARAW3KG963ed5CEug) <GiuseppeChillemi (GiuseppeChillemi)>:
* I don't want to change the language. I would like to add a limited subset of commands for this kind of data.
More generally, I would like to add Red custom types using a an upper level shape manager.
There are 2 solutions:

1. Make an enourmous low level change
2. Using upper level `shape` manager with minimal footprint.

To implement #2 without cluttering the core data in a container is the reason why I have recently asked for a sidecar for Red data containers, or PAIR! like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by miself the the "sidecar" approach.

[17:01:13](#woyKXrDSKsdCFZL-gT6bS419salZEs9QNlFm3yzJFv4) <GiuseppeChillemi (GiuseppeChillemi)>:
* I don't want to change the language. I would like to add a limited subset of commands for this kind of data.
More generally, I would like to add Red custom types using a an upper level shape manager.
There are 2 solutions:

1. Make an enourmous low level change
2. Using upper level `shape` manager with minimal footprint.

To implement #2 without cluttering the core data in a container is the reason why I have recently asked for a sidecar for Red data containers, or PAIR! like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by myself the the "sidecar" approach.

[17:01:36](#0oi8GAfp--zQ96pEAhCfIQlii-e0D1pumFoZYcDigqU) <GiuseppeChillemi (GiuseppeChillemi)>:
* I don't want to change the language. I would like to add a limited subset of commands for this kind of data.
More generally, I would like to add Red custom types using a an upper level shape manager.
There are 2 solutions:

1. Make an enourmous low level change
2. Using upper level `shape` manager with minimal footprint.

To implement #2 without cluttering the core data in a container is the reason why I have recently asked for a sidecar for Red data containers, or PAIR! like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by myself the the "sidecar" low level change.

[17:02:03](#MqRtAAXlspwfB8M8vuGSM8I_nC8j6oU-jW9lTNGY5Gk) <GiuseppeChillemi (GiuseppeChillemi)>:
* I don't want to change the language. I would like to add a limited subset of commands for this kind of data.
More generally, I would like to add Red custom types using a an upper level shape manager.
There are 2 solutions:

1. Make an enourmous low level change
2. Using upper level `shape` manager with minimal footprint.

To implement #2 without cluttering the core data in a container is the reason why I have recently asked for a sidecar for Red data containers, or PAIR! like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by myself the the "sidecar" low level datatype addition.

[17:06:07](#jerdRMVV-Zb6Q7wrAfUYd12an8kfTnyzDosEXJNm_oQ) <GiuseppeChillemi (GiuseppeChillemi)>:
I forgot to mention my idea is having custom paths manager too supporting DSL. But it still to early for all this. Maybe the next year.

[17:07:55](#wwoEJY_CNp5-FA1S9jgA4zLtLa67siUHXaaKXmswRhY) <GiuseppeChillemi (GiuseppeChillemi)>:
* I don't want to change the language. I would like to add a limited subset of commands for this kind of data.
More generally, I would like to add Red custom types using a an upper level shape manager.
There are 2 solutions:

1. Make an enourmous low level change
2. Using upper level `shape` manager with minimal footprint.

To implement #2 without cluttering the core data in a container is the reason why I have recently asked for a sidecar for Red data containers, or PAIR! like datatype functionality where in one end you have the data container, on the other end the shape info and data manager.  Then the `on-change` actor, `on-set` , `on-get` will do all the work. I am preparing for when such actors will be here and eventually implement by myself the "sidecar" low level datatype addition.

## 21-Aug-2025

[16:53:27](#5CpXjL5VxVF24cLuaDFcgOwnA_00-I_MF9yvrt_pmMs) <hiiamboris>:
Funny, I didn't know of this project: https://github.com/rsheehan/Remix

[17:05:11](#C2-MrBRPHD68Te8100-nu2mLZFxF_mUbjPUO_Yiz1Yw) <hiiamboris>:
Standard library is fun: https://github.com/rsheehan/Remix/blob/main/standard-lib.rem

[17:18:04](#ViW6gfvS9uNpkn5rjGw4KHGCWcZZiicrBNAwYMChf6w) <hiiamboris>:
Nice presentation as well: https://github.com/rsheehan/Remix/files/7551327/IntroToRemix.pdf

[17:18:17](#6Gi4Qe2MGLIutNN3AcmnlFTuYZ-nX54cGrh-hU4ZD0Q) <hiiamboris>:
I guess a graduation project or something

