# Example of dynamic rule creation in Parse dialect using the Red language. The code can be copy/pasted directly into a Red console.

**Gist ID:** 7830815
**Created:** 2013-12-06T19:34:11Z
**Last updated:** 2016-12-08T17:47:55Z

## File: `dyn-rule.red`

```Red
Red [
    Author: "Nenad Rakocevic"
    Date: 06/12/2013
    Note: {
        This short Red program demonstrates the use of dynamically built Parse rules.
        It parses an imaginary external DSL with variables, and detects if a variable has
        been used before been properly declared and initialized.
		
        The detection works by comparing found variables against a list of declared
        variables. The list starts empty, and it grows as new variables are collected.
        The list is constructed as a rule, and used in the parsing grammar from the 
        beginning, so that we get the checking almost for free.
    }
    Site: "http://red-lang.org"
]

;-- Example A of a DSL with correct variables initialization
prog-A: {
    a = 1
    b = 2 - a
    c = a + b
}

;-- Example B of a DSL with variable `d` used before being initialized
prog-B: {
    a = 3
    b = 8 + a
    c = a + d - b
    d = 12
}

variables: none					;-- declare 'variables as global word
letters:   charset [#"a" - #"z"]
digit:     charset "0123456789"
blank:     charset reduce [space tab cr lf]

store: func [name [word!]][
    either variables/1 = 'fail [                ;-- is it the first collected variable?
        variables: reduce [name]	   	;-- then create a list with that variable (dropping [fail])
    ][
        append variables reduce ['| name]	;-- else append a pipe marking alternate rule and the new variable
    ]
]

validate: function [prog /extern variables][    ;-- use /extern [variable] if compiled (pending bug to fix)
    variables: [fail]				;-- default, make the rule fail

    res: parse prog [
        some [
              blank
            | pos: copy var some letters any blank "=" (store var)
            | variables
            | ["+" | "-"]
            | some digit
        ]
    ]

    either res [				;-- check the result of the parsing
        ?? variables				;-- parsing succeeded, show the dynamic rule
    ][
        print ["** Undeclared variable:" pos/1]	;-- parsing failed because of undeclared variable
    ]	
]

validate prog-A
;-- will output: variables: ["a" | "b" | "c"]

validate prog-B
;-- will output: ** Undeclared variable: d

```

## Comments

No comments.
