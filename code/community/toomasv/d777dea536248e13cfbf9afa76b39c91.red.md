# 

**Gist ID:** d777dea536248e13cfbf9afa76b39c91
**Created:** 2017-11-30T18:27:46Z
**Last updated:** 2017-12-01T19:23:55Z

## File: `tree.red`

```Red
Red []
make object! [
	label: none
	parent: none
	root: does [
		either self/root? [self][
			first self/ancestors
		]
	]
	children: copy []
	siblings: does [
		exclude parent/children reduce [self]
	]
	; NB! needs to be copied as `descendants-list: copy node/descendants` 
	; otherwise crashes
	descendants: func [/into list /local child][
		list: any [list copy []]
		if not empty? children [
			append list copy children
			foreach child children [
				child/descendants/into list 
			]
		] copy list
	] 
	; NB! needs to be copied `ancestors-list: copy node/ancestors` 
	; otherwise crashes
	ancestors: has [list ancestor][
		list: copy []
		ancestor: parent
		while [ancestor][
			insert list ancestor
			ancestor: ancestor/parent
		] copy list
	] 
	root?: does [not parent]
	external?: leaf?: does [empty? children]
	internal?: branch?: does [not leaf?]
	; e.g. node/count/condition node/children 'internal?
	count: func [what /condition cond /local n][
		either condition [
			n: 0
			forall what [if what/1/:cond [n: n + 1]]
			n
		][
			length? what
		]
	]
	degree: does [length? children]
	depth: does [length? ancestors]
	level: does [depth + 1]
	paths: func [/with out out2 /local child child2][
		out: any [out copy []]
		out2: any [out2 copy []]
		if not empty? children [
			append out self
			foreach child children [
				either empty? child/children [
					append/only out2 append copy out child
				][
					child/paths/with copy out out2
				]
			]
		]
		out2
	]
	list-paths: has [labs x y labs2][
		labs: copy [] 
		foreach x copy paths [
			labs2: copy [] 
			foreach y x [append labs2 y/label] 
			append/only labs labs2
		] 
		probe labs
	]
	heigth: func [/local heigths][
		h: 0
		foreach path paths [
			h: max h (length? path) - 1
		]
		h
	]
	set 'node func [label parent /local me my][
		me: my: make object! self
		my/label: copy label
		if parent [
			my/parent: parent
			append parent/children me
		]
		me
	]
]
comment {
n1: node "1" none
n2: node "2" n1
n3: node "3" n2
n4: node "4" n2
n5: node "5" n3
n6: node "6" n4
n7: node "7" n4
n8: node "8" n7

           1
           |
           2
          / \
         3   4
        /   / \
       5   6   7
               |
               8
}
```

## Comments

### @toomasv on 2017-11-30T18:33:05Z

Try e.g.
```
n1: node "1" none
n2: node "2" n1
n3: node "3" n2
n4: node "4" n2
n5: node "5" n3
n6: node "6" n4
n7: node "7" n4
n8: node "8" n7
>> n7/depth
== 3
>> n4/depth
== 2
>> foreach d copy n2/descendants [probe d/label]
"3"
"4"
"5"
"6"
"7"
"8"
== "8"

"1"
"2"
"4"
== "4"
>> n4/root?
== false
>> n1/root?
== true
>> n5/leaf?
== true
>> n2/leaf?
== false
>> n7/internal?
== true
>> n8/external?
== true
```

