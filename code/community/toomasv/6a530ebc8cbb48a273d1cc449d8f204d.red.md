# 

**Gist ID:** 6a530ebc8cbb48a273d1cc449d8f204d
**Created:** 2017-12-12T15:23:51Z
**Last updated:** 2019-11-15T11:33:07Z

## File: `ring.red`

```Red
Red [
	Author: "Toomas Vooglaid"
	Date: 2017-12-12
]
set 'ring function [ser [series!]][
	context [
		series: ser
		circle: function [/at aval /skip sval /next /back /part pval][
			case/all [
				at [
					case [
						aval > 0 [
							val: (aval - 1) % (length? series) + 1 
							move/part series tail series val - 1
						]
						aval < 0 [
							val: aval % (length? series) 
							move/part system/words/skip tail series val head series absolute val
						]
					]
				]
				skip [circle/at either sval > 0 [sval + 1][sval]]
				next [circle/at 2]
				back [circle/at -1]
				part [
					either pval >= 0 [
						either pval > len: length? series [
							out: make (type? series) copy []
							append/dup out series pval / len
							append out copy/part series pval % len
							return out
						][
							return copy/part series pval
						]
					][
						either (pv: absolute pval) > len: length? series [
							out: make (type? series) copy []
							append/dup out series pv / len
							insert out copy/part system/words/skip tail series l: pval % len absolute l
							return out
						][
							return copy/part system/words/skip tail series pval absolute pval
						]
					]
				]
			]
			series
		]
		return :circle
	]
]

```

## Comments

### @toomasv on 2017-12-12T16:42:27Z

# Ring series structure
`ring` is created by e.g.
```
do %ring.red
  ...
rng: ring [1 2 3 4 5]
```
created `rng` can act as a normal block
```
>> rng
== [1 2 3 4 5]
>> at rng 3
== [3 4 5]
>> append rng 6
== [1 2 3 4 5 6]
>> reverse rng
== [6 5 4 3 2 1]
>> sort rng
== [1 2 3 4 5 6]
```
## `/at`, `/skip`, `/next`, `/back`
However, it is not a `block` (nor any `series!`), but a function, returning series value given initially to `ring` function. This series can be traversed in .. surprise .. ring manner:
```
>> rng/at 3
== [3 4 5 6 1 2]
>> rng/at 3
== [5 6 1 2 3 4]
>> rng/at 3
== [1 2 3 4 5 6]
>> rng/skip 3
== [4 5 6 1 2 3]
>> rng/skip 3
== [1 2 3 4 5 6]
>> rng/next
== [2 3 4 5 6 1]
>> rng/back
== [1 2 3 4 5 6]
>> rng/back
== [6 1 2 3 4 5]
```
And also backwards:
```
>> rng/skip -5
== [1 2 3 4 5 6]
>> rng/at -1
== [6 1 2 3 4 5]
>> rng/at -5
== [1 2 3 4 5 6]
```
These can be combined
```
>> rng/at/skip/next 3 3
== [1 2 3 4 5 6]
```
## `/part`
One feature more - `/part` refinement. As ring is circular, `series!` held in a ring is only "definitional" subseries of unbounded ring-structure. So, "part" of this endless structure can be smaller or bigger than "definitional" substructure:
```
>> rng/part 3
== [1 2 3]
>> rng/part 15
== [1 2 3 4 5 6 1 2 3 4 5 6 1 2 3]
```
And also counting from tail with negative values:
```
>> rng/part -3
== [4 5 6]
>> rng/part -15
== [4 5 6 1 2 3 4 5 6 1 2 3 4 5 6]
```
## Finally, `ring` supports all types of series (I haven't tried all, though)
### String!
```
>> strng: ring "abcdefghijklmnopqrstuvwxyz"
   ...
>> strng/at 10
== "jklmnopqrstuvwxyzabcdefghi"
>> strng/back
== "ijklmnopqrstuvwxyzabcdefgh"
>> strng/skip -9
== "zabcdefghijklmnopqrstuvwxy"
>> strng/next
== "abcdefghijklmnopqrstuvwxyz"
>> strng/part 5
== "abcde"
>> strng/part 50
== {abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwx}
```
### Path!
```
>> path-ring: ring 'a/b/c/d/f
   ...
>> path-ring/part 10
== a/b/c/d/f/a/b/c/d/f
>> path-ring/at -2
== d/f/a/b/c
```
### Paren!
```
>> paren-ring: ring to-paren [a + b = c]
   ...
>> paren-ring
== (a + b = c)
>> paren-ring/at 4
== (= c a + b)
>> paren-ring/at/part 3 10
== (a + b = c a + b = c)
```
### Binary
```
>> birng: ring #{0099FF}
  ...
>> birng
== #{0099FF}
>> birng/at 2
== #{99FF00}
>> birng/at 2
== #{FF0099}
>> birng/part 6
== #{FF0099FF0099}
```

