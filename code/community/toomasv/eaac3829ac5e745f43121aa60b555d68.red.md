# To get info about any function

**Gist ID:** eaac3829ac5e745f43121aa60b555d68
**Created:** 2017-09-01T14:17:49Z
**Last updated:** 2021-04-20T06:13:54Z

## File: `info.red`

```Red
Red []
context [
    get-function: function [path] [
        if path? path [
            path: copy path 
            while [
                not any [
                    tail? path 
                    any-function? attempt [get/any either last? path [path/1] [path]]
                ]
            ] [
                clear back tail path
            ] 
            return either empty? path [none] [path]
        ] none
    ] 
    set 'info func ['fn /local intr ars refs locs ret arg ref typ irefs rargs rf fnc] [
        intr: copy "" ars: make block! 10 refs: make block! 20 locs: copy [] ret: copy [] irefs: copy [] typ: ref-arg: ref-arg-type: none 
        if path? fn [
            either fnc: get-function fn [
                irefs: copy skip fn: to-block fn length? fnc 
                either 1 = length? fnc [fn: fn/1] [fn: fnc]
            ] [return none]
        ] 
        if lit-word? fn [fn: to-word fn] 
        unless all [value? fn any [word? fn path? fn] any-function? get fn] [
            return none
        ] 
        out: make map! copy [] 
        specs: spec-of get fn 
        parse specs [
            opt [set intr string!] 
            any [set arg [word! | lit-word! | get-word!] 
                opt [set typ block!] 
                opt string! 
                (put ars arg either typ [typ] [[any-type!]])
            ] 
            any [set ref refinement! [
                if (not find [/local /extern] ref) (put refs r: to-word ref make block! 10) 
                opt string! 
                any [set ref-arg [word! | lit-word! | get-word!] opt [set ref-arg-type block!] 
                    (put refs/:r ref-arg either ref-arg-type [ref-arg-type] [[any-type!]])
                ] 
                opt string! 
                | any [set loc word! (append locs loc) opt string!] 
                opt [set-word! set ret block!]
            ]]
        ] 
        rargs: extract ars 2 
        foreach rf irefs [append rargs extract refs/:rf 2] 
        make object! [
            name: either path? fn [last fn] [to-word fn] 
            intro: intr 
            args: ars 
            refinements: refs 
            runtime-refs: irefs 
            locals: locs 
            return: ret 
            spec: specs 
            type: type? get fn 
            arg-num: (length? args) / 2
            arg-names: extract args 2 
            arg-types: extract next args 2 
            ref-names: extract refinements 2 
            ref-types: extract next refinements 2 
            ref-num: (length? refinements) / 2 
            runtime-args: rargs 
            arity: length? runtime-args ;/ 2
        ]
    ]
    set 'arity-of func ['fn /local inf][
        if inf: info :fn [inf/arity]
    ]
    set 'args-of func ['fn /local inf][
        if inf: info :fn [inf/runtime-args]
    ]
]

```

## Comments

### @toomasv on 2017-09-01T14:30:44Z

Usage:
```
probe info split

info '+ 

select info reverse 'refinements

fn: info reduce
fn/ref-types

arity-of find/skip  ;3
args-of find/skip  ;[series value size]

w: words-of system/words
forall w [if all [value? i: first w i: info :i][print rejoin [i/name ": " i/arity]]]
```


