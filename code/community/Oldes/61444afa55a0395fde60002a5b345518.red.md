# Red/System libjulia binding

**Gist ID:** 61444afa55a0395fde60002a5b345518
**Created:** 2017-06-08T14:30:15Z
**Last updated:** 2017-06-09T14:26:34Z

## File: `julia.reds`

```Red
Red/System [
	Title:   "Red/System libjulia binding"
	Author: "Oldes"
	File: 	%Julia.reds
	Tabs: 	4
	Rights: "Copyright (C) 2017 Oldes. All rights reserved."
	License: {
		Distributed under the Boost Software License, Version 1.0.
		See https://github.com/red/red/blob/master/BSL-License.txt
	}
	Comment: {
		This script needs external library, which can be downloaded from this site:
		https://julialang.org/downloads/
	}
]

#enum jl-image-search! [
	JL_IMAGE_CWD
	JL_IMAGE_JULIA_HOME
	;JL_IMAGE_LIBJULIA
]

#define jl-value! int-ptr!
jl-tagged-value!: alias struct! [
	header [int-ptr!]
	next   [int-ptr!]
	type   [int-ptr!]
	whatever [int-ptr!]
]	
	

julia: context [

	#switch OS [
		Windows   [ #define libjulia "libjulia.dll" ]
		MacOSX    [ #define libjulia "libjulia.dylib" ] ;@@ FIXME: use real file name
		#default  [ #define libjulia "libjulia.so" ]    ;@@ FIXME: use real file name
	]


	#import [
		libjulia cdecl [
			julia_init: "julia_init" [
				ret [jl-image-search!]
			]
			jl_init: "jl_init" [
				julia_home_dir [c-string!]
			]
			jl_init_with_image: "jl_init_with_image" [
				julia_home_dir [c-string!]
				image_relative_path [c-string!]
			]
			jl_is_initialized: "jl_is_initialized" [
				return: [integer!]
			]
			jl_atexit_hook: "jl_atexit_hook" [
				status [integer!]
			]
			jl_eval_string: "jl_eval_string" [
				str [c-string!]
				return: [jl-value!]
			]
			
			jl_unbox_int32: "jl_unbox_int32" [
				v [jl-value!]
				return: [integer!]
			]
			jl_unbox_voidpointer: "jl_unbox_voidpointer" [
				v [jl-value!]
				return: [byte-ptr!]
			]

			jl_string_type: "jl_string_type" [integer!]

		]; libjulia
	]; #import 

	probe-jl-value: func[
		jval [jl-value!]
	][
		print-line [
			"VAL " jval " has: " as int-ptr! jval/1 " " as int-ptr! jval/2 " " as int-ptr! jval/3
			 " " as int-ptr! jval/4 " " as int-ptr! jval/5 " " as int-ptr! jval/6 " " as int-ptr! jval/7
			 " " as int-ptr! jval/8]
	]
] ; context julia


main: func [
	/local
		argument  [str-array!]
		home-dir  [c-string!]
		ret       [jl-value!]
][
	switch system/args-count [
		1 [ home-dir: "c:\dev\Julia-0.5.2\bin\"]
		2 [
			argument: system/args-list + 1
			home-dir: argument/item
		]
		default [
			print-line "Invalid number of arguments!"
			quit 0
		]
	]

	print-line ["Julia home dir: " home-dir]

	with julia [
		print-line "Starting Julia..."
		jl_init home-dir ;julia's home dir (bin folder)
		if 1 <> jl_is_initialized [
			print-line "Initialization failed!"
			quit 0
		]
		;jl_eval_string "versioninfo()"
		
		;this is print from Julia:
		ret: jl_eval_string {println(string("sqrt(2.0) = ",sqrt(2.0)))}
		;ret will be something like `unset` julia type in this case
		
		;this will create string in Julia:
		ret: jl_eval_string {string("sqrt(2.0) = ",sqrt(2.0))}
		if ret/0 = jl_string_type [
			print-line ["returned string:  "  as c-string! jl_unbox_voidpointer as int-ptr! ret/1]
		]
		
		ret: jl_eval_string {a = 2;b = 3; c = a * b}
		print-line ["returned integer:  "  jl_unbox_int32 ret]
		
		ret: jl_eval_string {c}
		print-line ["c is:  "  jl_unbox_int32 ret]

		jl_atexit_hook 0
	]
]

main

```

## Comments

No comments.
