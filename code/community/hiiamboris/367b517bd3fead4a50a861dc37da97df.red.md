# 

**Gist ID:** 367b517bd3fead4a50a861dc37da97df
**Created:** 2018-04-03T03:11:38Z
**Last updated:** 2018-04-03T03:14:21Z

## File: `dot-chaining.red`

```Red
Red []

; WOW! chain expressions with a dot to make them more readable!

; an inline transformation of a chain of function applications into a lisp-like pyramid of braces ;)
; (expr) . func args... => (func (expr) args...)
; e.g. [1 2 3 4 5] . skip 1 . change/part '- 3 . head => (head (change/part (skip ([1 2 3 4 5]) 1) '- 3))
#macro [skip '. [word! | path!]] func [[manual] s e /local a r p p2] [
	p: s/3
	a: either word? p [
		preprocessor/func-arity? spec-of get :p
	][
		p2: as path! clear head []
		until [
			append  p2  pick p 1 + length? p2
			any-function? get either 1 = length? p2 [p2/1][p2]
		]
		preprocessor/func-arity?/with  (spec-of get either 1 = length? p2 [p2/1][p2])  (at p length? p2)
	]

	e: at e a
	r: as paren!  append/part  reduce [s/3 s/1]  skip s 3  (a - 1)
	change/part/only s r e
	s
]

;-- examples:
; colors: exclude sort extract load help-string tuple! 2 [transparent glass]
; becomes:
; colors: (help-string tuple!) . load . extract 2 . sort . exclude [transparent glass]
; or
; colors: (load help-string tuple!) . extract 2 . sort . exclude [transparent glass]

; and just for fun:
; probe [1 2 3 4 5] . skip 1 . change/part '- 3 . head


```

## Comments

No comments.
