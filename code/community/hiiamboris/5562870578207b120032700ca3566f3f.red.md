# 

**Gist ID:** 5562870578207b120032700ca3566f3f
**Created:** 2018-04-03T06:10:14Z
**Last updated:** 2019-06-29T16:32:36Z

## File: `piping.red`

```Red
Red []

; WOW! dialectic version of function piping!
; . with a cutest dot!
;  . to make expressions more readable! 
;   . can be invoked recursively (pipe [ pipe [...] . ... ])

; e.g. [1 2 3 4 5] . skip 1 . change/part '- 3 . head
; => head change/part skip [1 2 3 4 5] 1 '- 3

; can only process simplest of chains
; but that makes it fast! - no reason to look up the arity

; transformation rule:
;   stuff...  .  func args... => func stuff... args...
;   i.e. func is just placed at the beginning
; => func must accept stuff as it's 1st argument and
; => stuff... must yield a single result

; examples:
; [1 2 3 4 5] . skip 1 . change/part '- 3 . head  -- is OK
; copy [1 2 3 4 5] . skip 1 . change/part '- 3 . head  -- OK
; 123 [1 2 3 4 5] . skip 1 . change/part '- 3 . head  -- is NOT OK
; [1 2 3 4 5] . skip 1 . change/part '- 3 . probe head  -- NOT OK
; [1 2 3 4 5] . skip 1 . change/part '- 3 . head 123  -- NOT OK


; can't have local vars here (ideally :D)
pipe: func [code [block!]] [
	do pipe-parse code
]

pipe-parse: function [code [block!]] [
	symbol: ['.]		;-- . or | ?  it's easier to visually tell subexprs apart with .
	left: copy []		; have to copy to allow recursion =O
	right: clear []

	parse code [
		any [
			rexp: to symbol
			dlm: skip
			lexp: [word! | path!]
			(	append/only left lexp/1
				append/part right rexp dlm )
			| some skip (append right rexp)
		]
	]

	head append reverse left right
]


probe equal?
	(exclude sort extract load help-string tuple! 2 [transparent glass])
	pipe [ (help-string tuple!) . load . extract 2 . sort . exclude [transparent glass] ]
probe equal?
	(head remove/part skip sort split form now charset "+-:/" 3 2)
	pipe [ form now . split charset "+-:/" . sort . skip 3 . remove/part 2 . head]

; recursive test!
pipe [
	probe	pipe [ copy [1 2 3 4 5] . skip 1 . change/part '- 3 . head]
	. equal? (head change/part skip [1 2 3 4 5] 1 '- 3) . probe
	;. copy . reverse . probe
]


```

## Comments

No comments.
