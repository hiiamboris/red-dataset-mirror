# an attempt to compose parse rules in the same way that lisp compose expressions with macros. e.g unquote splice etc...

**Gist ID:** 9898ce704ac70ddb35083baf207046a5
**Created:** 2018-05-12T12:27:06Z
**Last updated:** 2018-05-12T12:28:07Z

## File: `rules-unquote.red`

```Red
;; impl ---------------------------------------------------

traverse: func [x f /only /deep dive?][
    until [
        x: case [
            all [deep dive? x/1] [traverse/deep x/1 :f :dive? next x]
            all [not deep not only series? x/1] [traverse/deep x/1 :f :series? next x]
            'else [f x] 
        ]
        tail? x
    ]
    head x
]

;; main --------------------------------------------------

compile-rules: func [rules][
    rules: traverse rules func [e][
        case [
            equal? e/1 '! [back change/only remove e do e/1]
            equal? e/1 '..! [insert remove e do take e]
            'else [next e]
        ]
    ]
]

parse+: func [data rules] [parse data compile-rules rules]

;; example -----------------------------------------------

;;defining a function that output a rule
string-of-length: func[n][    
    compose/deep [ahead string! into [(n) skip]]
]

rules: compile-rules [
    ;; call the function and append the block into the current rule
    ..!(string-of-length 3)
    ;; same but append/only
    some !(string-of-length 2)
]

parse ["aze" "ab" "ba"] rules


```

## Comments

No comments.
