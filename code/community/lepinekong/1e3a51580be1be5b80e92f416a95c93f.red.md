# Code your flowchart (ReAdABLE Human Format to Chartmage)

**Gist ID:** 1e3a51580be1be5b80e92f416a95c93f
**Created:** 2018-05-04T20:27:42Z
**Last updated:** 2018-05-05T08:23:23Z

## File: `ReAdABLE.Flowchart.to.Chartmage.red`

```Red
Red [
    Title: "ReAdABLE.Flowchart.to.Chartmage.red"
    Description: {Example to convert a Flowchart from ReAdABLE Format https://medium.com/@lepinekong/readable-human-format-md-8fda1869ef75
    to Chartmage http://chartmage.com/index.html
    copy result to clipboard}    
    Github-Url: https://gist.github.com/lepinekong/1e3a51580be1be5b80e92f416a95c93f
    Requirements: [
        Redlang: https://www.red-lang.org 
        {or paste this oneliner in powershell: https://gist.github.com/lepinekong/d895d64528ee85e6aac4b13bdf3437bc}
        VSCode: https://code.visualstudio.com/
        VSCode-Extension: https://marketplace.visualstudio.com/items?itemName=red-auto.red
    ]
    ReAdABLE-Human-Format: https://lepinekong.github.io/
    Redlang-Tutorials: [
        https://dev.to/lepinekong/red-for-hopeless-programmers---part-i-3g0
        https://dev.to/lepinekong/red-for-hopeless-programmers---part-ii-258
    ]
    Version: {alpha works with "normalized" format}
    Todo: {Syntax simplification}
]

;for do-trace debugging utility
;do read https://gist.githubusercontent.com/lepinekong/7574892bfefe7e53e7bd4dd4759f30f8/raw/96a7e9345212a7b24fabc643d380268d10235cdd/.github.lib.red

flowchart: [
    Main: [
        Jot -> Jot-already-launched? [
            Yes: [Set-Jot-to-Foreground -> Jot-Launched] 
            No: [Launch-Jot -> load-note-file -> Jot-Launched] 
        ]
    ]
    Jot-Launched: [
        Jot-Launched -> Save? [OnActivate: [Save-note-file -> Jot-Launched]]
        Jot-Launched -> Stamp? [OnActivate: [Append-Date-Stamp -> Jot-Launched]]
        Jot-Launched -> Close? [OnActivate: [Save-note-file -> End]]
    ]
]





labels: extract flowchart 2
sub-flows: extract/index flowchart 2 2

chartmage: copy ""

process-word: function[.element .next-element .previous-element .parent 
    /local ancestors
][

    ancestors: [] ; static variable
    either empty? ancestors [
        if not none? .parent [
            append/only ancestors .parent
        ]  
    ][
        if not find ancestors/1 .parent [
            if not none? .parent [
                ancestors/1: .parent           
            ]
        ]
    ]

    either word? .next-element [
        next-element: form .next-element
    ][
        next-element: .next-element
    ]
    
    either word? .previous-element [ ; examples Jot, -> 
        previous-element: form .previous-element
    ][
        previous-element: .previous-element
    ]

    if set-word? .element [ ; examples YES:, NO:

        ancestors-1: ancestors/1
        question-candidates: copy [] ; example [Save? Stamp? Close?]
        parse-rule: [
            some [
            set ancestor word! 
            '-> 
            set question word! 
            set block block!
            (append question-candidates question)]
        ]
        parse ancestors-1 parse-rule
        forall question-candidates [
            question: question-candidates/1
            if (previous-element = form question) [
                break
            ]
        ]

        append chartmage question

        element: rejoin [ " - " form .element " ->> "]

        append chartmage element

        return .element
    ]

    element: form .element

    if element = "->" [

        replace element "->" " ->> " 
        append chartmage element
        return .element      
    ]

    ; other cases: element of type word
    append chartmage element 

    if previous-element = "->" [
        append chartmage newline
        
        if next-element = "->" [
            append chartmage element
        ]

        return .element
    ]

    if set-word? previous-element [

        append chartmage newline

        if next-element = "->" [
            append chartmage element
        ]
        
        return .element        
    ]


    return .element
]

process-block: function[.block .next-element .previous-element .parent][

    block: .block
    forall block [
        i: index? block
        element: block/1   
        next-element: block/2
        previous-element: .previous-element
        if i > 1 [
            previous-element: pick (head block) (i - 1)
        ]
        either block? element [
            process-block element next-element previous-element .parent
        ][
            process-word element next-element previous-element .parent
        ]

    ]

]

forall sub-flows [
	sub-flow: sub-flows/1
	i: index? sub-flows
	append chartmage rejoin [
		"subgraph " labels/(i)
		newline
	]
	
	forall sub-flow [

        element: sub-flow/1
        j: index? sub-flow
        next-element: sub-flow/2
        previous-element: none

        if j > 1 [
            previous-element: pick (head sub-flow) (j - 1)
            
        ]
        either block? element [
            process-block element next-element previous-element sub-flow
        ][
            process-word element next-element previous-element sub-flow
        ]
	]
	
	append chartmage rejoin [
		"end"
        newline
	]	
	
	append chartmage newline
]

print chartmage
write-clipboard chartmage	

```

## Comments

No comments.
