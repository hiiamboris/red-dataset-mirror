# Small GUI experiment for showing datatype information.

**Gist ID:** b3604f2acd6ac70c70691bd54d8a814b
**Created:** 2017-03-25T21:57:15Z
**Last updated:** 2017-03-28T06:41:06Z

## File: `datatype-help.red`

```Red
Red []

form-all: func [blk][
	forall blk [blk/1: form blk/1]
	blk
]

types-of: function [value [typeset!]][
	; typesets don't support reflection
	third load mold value
]

get-sys-words: func [test [function!]][
	collect [
		foreach word words-of system/words [
			if test get/any word [keep word]
		]
	]
]

list-of-sys-words: func [test [function!]][form-all sort get-sys-words :test]
list-of-types-of: func [typeset [typeset!]][form-all sort types-of typeset]

;-------------------------------------------------------------------------------

type-map: [
	any-type! [
		event!
		unset!
		
		any-function! [native! action! op! function! routine!]
		
		any-object! [object! error!]
		
		series! [
			
			any-block! [
				any-list! [block! paren! hash!]
				
				any-path! [path! lit-path! set-path! get-path!]
			]
			
			any-string! [string! file! url! tag! email!]
			
			binary!
			image!
			vector!
		]
		
		immediate! [
			any-word! [word! set-word! lit-word! get-word! refinement! issue!]
			
			scalar! [
				number! [integer! float! percent!]
				
				char!
				pair!
				tuple!
				time!
			]
			
			datatype!
			none!
			logic!
			typeset!
		]
	]	
]

;-------------------------------------------------------------------------------

datatypes: [
	action! [
		desc "Used for common, fixed functions all datatypes MAY support."
		examples [add copy pick round]
		notes {Actions are written in Red/System code.}
	]
	binary! [
		desc "Series of bytes, in base 2, 16, or 64."
		examples [#{FF} 2#{11111111} 64#{SGVsbG8=}]
		notes {Base 16 is the default. May include whitespace.}
	]   
	bitset! [
		desc "Space efficient set of logic values."
		examples {make bitset! 1000
charset "0123456789"
charset [#"A" - #"Z"  #"a" - #"z"]
		}
		notes {There is no literal form for bitsets. You create them with
`make bitset!` or the `charset` function. The arg for `make
bitset!` can be one of `[integer! string! char! binary! block!]`.
If a block is used, you can define ranges of chars using the
`[char! - char!]` sequence, one or more times. You can access
individual bits using path notation or `pick/poke`.

	>> bs: make bitset! 4
	== make bitset! #{00}
	>> bs/1
	== false
	>> bs/1: on
	== true
		}
	]
	block! [
		desc "An ordered group of Red values enclosed in square brackets."
		examples {[1 2 3]
[a b c]
[1 b #3 (4) 5x5 "six" %seven http://8.com ten@11.dom]
		}
		notes {Blocks are heterogeneous, so can contain any Red value.
They have an intrinsic order, and values be accessed using path
notation or with functions that operate on `series!` values.
They have an implicit offset independent of the underlying
group of values referenced, which can be used for iteration
among other things.

Blocks, along with words, are a fundamental datatype in Red.
To use Red effectively, it helps greatly to understand how 
these two types work, and work together.

NOTE: Values in blocks are not automatically evaluated.
		}
	]
	char! [
		desc "Character. Atomic elements strings are made of."
		examples [#"A" #"^(tab)" #"^(CEB9)" #"‰ªÅ"]
		notes {}
	]
	datatype! [
		desc ""
		examples []
		notes {}
	]
	email! [
		desc ""
		examples []
		notes {}
	]
	error! [
		desc ""
		examples []
		notes {}
	]
	event! [
		desc ""
		examples []
		notes {}
	]
	file! [
		desc ""
		examples []
		notes {}
	]
	float! [
		desc ""
		examples []
		notes {}
	]
	function! [
		desc ""
		examples []
		notes {}
	]
	get-path! [
		desc ""
		examples []
		notes {}
	]
	get-word! [
		desc ""
		examples []
		notes {}
	]
	hash! [
		desc ""
		examples []
		notes {}
	]
	image! [
		desc ""
		examples []
		notes {}
	]
	integer! [
		desc ""
		examples []
		notes {}
	]
	issue! [
		desc ""
		examples []
		notes {}
	]
	lit-path! [
		desc ""
		examples []
		notes {}
	]
	lit-word! [
		desc ""
		examples []
		notes {}
	]
	logic! [
		desc ""
		examples []
		notes {}
	]
	map! [
		desc ""
		examples []
		notes {}
	]
	native! [
		desc ""
		examples []
		notes {}
	]
	none! [
		desc ""
		examples []
		notes {}
	]
	object! [
		desc ""
		examples []
		notes {}
	]
	op! [
		desc ""
		examples []
		notes {}
	]
	pair! [
		desc ""
		examples []
		notes {}
	]
	paren! [
		desc ""
		examples []
		notes {}
	]
	path! [
		desc ""
		examples []
		notes {}
	]
	percent! [
		desc ""
		examples []
		notes {}
	]
	point! [
		desc ""
		examples []
		notes {}
	]
	refinement! [
		desc ""
		examples []
		notes {}
	]
	routine! [
		desc ""
		examples []
		notes {}
	]
	set-path! [
		desc ""
		examples []
		notes {}
	]
	set-word! [
		desc ""
		examples []
		notes {}
	]
	string! [
		desc ""
		examples []
		notes {}
	]
	tag! [
		desc ""
		examples []
		notes {}
	]
	time! [
		desc ""
		examples []
		notes {}
	]
	tuple! [
		desc ""
		examples []
		notes {}
	]
	typeset! [
		desc ""
		examples []
		notes {}
	]
	unset! [
		desc ""
		examples []
		notes {}
	]
	url! [
		desc ""
		examples []
		notes {}
	]
	vector! [
		desc ""
		examples []
		notes {}
	]
	word! [
		desc ""
		examples []
		notes {}
	]
]

;-------------------------------------------------------------------------------


ts: list-of-sys-words :typeset? 
dt: list-of-sys-words :datatype?

move find ts "any-type!" head ts	; Put any-type! at the top of the list

list-cur-text: func [face "text list"] [pick face/data face/selected]
list-cur-word: func [face "text list"] [to word! list-cur-text face]

lay: copy [
	style label: text font-size 12
	style text-list: text-list 125x450 font-size 12 
	style _typeset:  text [] blue
	style _datatype: text [] navy
	below
	label "Typesets:" lst-typesets: text-list "Typesets"  data ts select 1 [
		; We have to form data to put it in a list, but convert it back
		; to a word to extract its value.
		lst-datatypes/data: list-of-types-of get list-cur-word face
		lst-datatypes/selected: none
	] return
	label "Datatypes:" lst-datatypes: text-list "Datatypes" data dt [
		rec: select datatypes list-cur-word face
		f-type/text: list-cur-text face
		f-desc/text: rec/desc
		f-exam/text: either block? rec/examples [mold/only rec/examples][rec/examples]
		f-note/text: rec/notes
	] return
	button "Type Map" [view compose [text 500x400 (mold type-map)]]
	panel [
		label "Type:"	  f-type: label 450 return
		label "Desc:"     f-desc: label 450 return
		label "Examples:" f-exam: text  450x60 font-size 12 font-name "Fixedsys" return
		label "Notes:"    f-note: label 425x300 
	]
	return
	button "Quit" [quit]
]


view lay

```

## Comments

No comments.
