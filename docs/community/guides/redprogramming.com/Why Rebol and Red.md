Original URL: <https://redprogramming.com/Why Rebol and Red.html>

# Why Rebol and Red

* * *

[![HEADER IMAGE](https://redprogramming.com/header.png)](https://redprogramming.com/index.html)

[Home](https://redprogramming.com/Home.html) : Why Rebol and Red

Why Rebol and Red

## Contents:

[1. Why use Rebol or Red? What's the point, what makes it different?](#section-1)  
[2. Basic Language Features](#section-2)  
[3. Dialects](#section-3)  
[4. The End Result - Unmatched Simplicity](#section-4)

## 1. Why use Rebol or Red? What's the point, what makes it different?

> These days, it seems that every programming language, library, and framework claims to "increase productivity" in some way. And of course, Javascript's popularity is soaring. That constant noise makes it difficult to put into perspective Rebol's achievements. You may be familiar with Clojure, Python, Ruby, Lua, frameworks like Ruby on Rails, or any of the multitude of Javascript frameworks which are purpose-built to "ease" particular types of development work. Such languages/tools/environments are certainly productive compared to traditional tools like plain old C++, Java, etc., but they are absolute behemoths when compared to Rebol. Virtually every other well known development tool in popular use is built upon bloated layers of existing technology, and encumbered by mainstream language syntax and development procedures which introduce an extraordinary volume of unnecessary complexity at many levels. Most developers have just never experienced the sort of self dependent architecture, lightweight tooling, bare language and data structure syntax, composability, and reduced code volume, which Rebol prioritizes as its most important purposes.
> 
> Take a look at [http://re-bol.com/short\_rebol\_examples.r](http://re-bol.com/short_rebol_examples.r) to get a quick idea of how much can be accomplished with just tiny bits of Rebol code.
> 
> Those introductory examples just scratch the surface. Take a look through [http://business-programming.com](http://business-programming.com/) for a deeper look.
> 
> For even more perspective, see what [Atronix Engineering](http://www.atronixengineering.com/) has accomplished, and watch [this video by Atronix's founder](https://www.youtube.com/watch?v=jIw7aRP6JPU) to understand how Rebol's productive capabilities have enabled their large commercial projects.
> 
> You may also want to see the [study on the well respected redmonk.com site](http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/) which ranks Rebol as *\*the most productive\** of all general purpose programming languages.

## 2. Basic Language Features

> Here are some of Rebol's basic features which help to simplify all levels of code structure:
> 
> - An enormous number of built in data types which are automatically recognized and handled appropriately by the interpreter. Not just numbers and text, but dates, times, money values, coordinate pair values, IP addresses, and many more can all be calculated, sorted, evaluated, etc. without any special code formatting, library functions, or tooling. This helps simplify the process of working with the fundamentally useful and common types of data which make up the world around us (and which will be forever dealt with in computing systems of all types). The automatic recognition of common complex data types, and the ability to perform appropriate calculations upon them, is also fundamentally helpful in designing dialect rules (it's easier to define simple parsing rules, when any word in a given syntax is automatically recognized as a specific type of data). The ability to create new complex data types will be added as a feature in Red.
> - A complete lack of all unnecessary syntax (semicolons, commas, indentation, quotes, etc.), so that code and data can be read more naturally and without clutter. It's hard for experienced programmers, steeped in knowledge about traditional data format guidelines, to grasp immediately, but a lack of unnecessary syntax is typically much more intuitive for the human mind to comprehend and work with productively. This topic is often met with resistance, but several great articles have been written which demonstrate this truth well (take a quick look at [http://blog.hostilefork.com/arity-of-rebol-red-functions](https://redprogramming.com/_%22http://blog.hostilefork.com/arity-of-rebol-red-functions%22), or that entire blog history, if you're really interested). Reduced syntax in data structures also requires less processing power to parse, less network bandwidth to transfer, less space to store, etc.
> - The ubiquitous "series" structure used to manage lists of all types: files, strings, email accounts, data in network ports, values returned from database systems, graphic screen layouts, etc., all use the same functions and way of thinking about/interacting with the organization and manipulation of grouped values. This reduces language overhead and the number of code constructs needed to manipulate data and code in Rebol. Arrays, linked lists, strings, and code patterns themselves, etc. are all treated the same way, as series.
> - Rebol provides native language access to network ports, files, and other data sources - all treated the same way, as series. These Rebol language capabilities work exactly the same on every OS. Native Rebol language access to Internet protocols such as TCP, UDP, HTTP, FTP, email, etc., also work exactly the same across every OS, and like every other feature of Rebol, they are natural, built in, easily composable pieces of the \*language, in much the same way that the broad range of native data types are built in. These computing components are fundamental building blocks in any type of application, and the way they are built into the fabric of the Rebol architecture makes it childs play to use existing protocols, to compose new protocols, and to combine features with virtually no code overhead.
> - Native ability to parse data formats such as .csv, HTML, XML, etc., as well as unformatted data, using dedicated high level functions, as well as lower level 'parse rules. Functions are easily composable, 'parse code can be easily composed into new functions, and 'parse code itself is much more human readable than regex - and it performs faster. Parse alone is a reason that some developers choose to use Rebol. It provides a solution which is useful in many of the most common data processing activities for which computer systems are implemented. Most developers have no idea that something as powerful and readable as Rebol's parse even exists...
> - Simple data persistence features such as read, write, save, and load which, along with all the standard series functions, eliminate the need for 3rd party database systems in many cases (see [http://re-bol.com/rebol-multi-client-databases.html](http://re-bol.com/rebol-multi-client-databases.html)). Most Rebol developers rarely need to touch 3rd party DBMSs. This helps to dramatically reduce or entirely eliminate a tremendous variety of upgrade, maintenance, porting, implementation, integration, and other difficulties, and provides more fine grained control of system performance, in ways which can be easily understood and tuned by Rebol developers, using only basic language skills. (Integration with 3rd party DBMSs is nevertheless very simple in Rebol, and even included as a native feature in some distributions).
> - Built-in low level native abilities to draw graphics, display and manipulate images, attach events, timers, etc. to interface elements, etc. This "View" level is lower than GUI and graphic manipulation dialects, but still kept separate from the lowest level rendering engine layer. When R3 was released as an open source project, a single person was able to port the entire system to Android (not just the core language, but also the GUI, graphics drawing, IO, network features, etc.) in just a few weeks. This is because only the lowest level rendering and IO layers of native code needed to be ported. All the layers above consisted of pure Rebol code built upon those layers. It's the way that these layers of language technology are composed in Rebol, which sets it apart from other language technologies.
> - Useful built-in help, source, and other introspection features for all available functions, language constructs, and interpreter internals. Once you learn how to explore the built in support features, external documentation is rarely necessary.
> - Unmatched tiny binary size and ease of deployment. Rebol requires no installation, and it runs exactly the same on more than 40 modern and legacy OS platforms. If you're building web apps, upload a single 200k executable file, set permissions, and you're up and running not only with a production deployment environment, but with a full development environment too. One script can provide full control of file, OS, and other server features, and all those features can be manipulated using the exact same code, regardless of OS platform. The same is true for desktop apps. Install a single executable of less than a megabyte (or don't even install, if you don't need integrated file extension association support), and your entire development environment, all batteries included (UI, graphics, network, IO, protocols, OS tools, etc.), is set up. Using some other development tools, it can take multiple days to fully set up a development machine with updates to all required infrastructure - and deploying applications to different platforms, or just to new machines, can become a complicated and time consuming ordeal, often requiring serious bandwidth and manpower to support server installations for multiple users. For growing businesses, especially those with time sensitive operations requirements, such support tasks can become overwhelming. Just getting users to access features of an app can sap tremendous support time and energy from development work. Installing, deploying, testing, and updating features in Rebol apps literally takes just a few seconds. There is no other development tool on the planet which embodies Rebol's broad range of capability in such a tiny, portable, and simple to use package. In practice, this ends up dramatically reducing real support requirements, user difficulties, and costs.
> - No third party browser, library, or server incompatibility issues to deal with. User interfaces, IO, and all infrastructure requirements are all completely contained in the single Rebol interpreter binary. Nearly all Rebol legacy code, made to run in the very first Rebol interpreters in the 1990's, still runs exactly the same today, without any changes. Just download any version of the tiny Rebol interpreter, and your app works as expected. That sort of consistency is extremely rare among other development platforms.
> - The ability to compose and manipulate data and code constructs with equal freedom. Rebol's code=data nature is a metaprogramming facet which fits naturally with dialect design, and generally helps to enable a powerfully malleable language structure. Again, it's the way that all of Rebol's malleable and flexible language design elements work \*together* which really makes it a pleasurable and a productive powerhouse to work with.
> 
> Natural, native, easy interactivity is designed between all these fundamental computing capabilities, from the ground up. Developer productivity is made a priority in Rebol, at every level and in every facet of the language and tooling design, using simple mental models, language design and syntax choices (even such basic decisions as using square brackets, because they require fewer key strokes). The end result is a dramatically noticeable lack of friction and pain, compared to the work routines typical of nearly every other software development stack in common use (yes, even compared to Python, Ruby, Lua, Clojure, Javascript, etc.). This effect may be initially offset for experienced developers, because Rebol does look and feel different from other mainstream languages, but in many cases, those differences are actually design choices which work *objectively* more *effectively*. In order for something to be better, it needs to be different - unfortunately, those differences are often initially perceived as off-puttingly unnecessary, perhaps "rebellious" or trite choices, which appear to have no basis. But, if you perform anything more than simple work in Rebol, you begin to see how all those choices actually work together to create a language and tooling design which is objectively and intentionally simpler and more productive than other traditional choices.
> 
> If you doubt any of this is true, start by taking the 70+ examples at [http://re-bol.com/short\_rebol\_examples.r](http://re-bol.com/short_rebol_examples.r) and try to recreate that set of apps using \*any other language or tool set. Expect at very least a 2x-3x increase in code size, and a much more complicated development and deployment experience, likely necessitating multiple layers of tooling and other requirements to be installed in order for the created apps to run. Take a look through Rosettacode.com, and compare the overwhelming number of Rebol examples to those of any other language, and see how much simpler they are. Or take a look at any larger app example created with Rebol, and you'll see that the code size, development environment needs, and deployment requirements are reduced exponentially when compared to those of other tools. Look at case studies in which both large and small companies have switched to Rebol and dramatically cut the size of their development staff, as a result. Long time users of Rebol will gladly share their [success stories](https://www.youtube.com/watch?v=jIw7aRP6JPU).
> 
> Rebol works, but not only because of the features described above. The real untapped potential of Rebol's approach lies in its purpose-built ability to create language dialects.

## 3. Dialects

> Modern programming languages mostly make use of functions (methods) and objects to structure code, along with various different types of data structures to manipulate information. To simplify high level coding activities, Rebol adds the powerful ability to create domain specific "dialect" syntax structures. When combined with all of Rebol's basic language features, dialects provide a way to simplify the code needed to achieve any conceivable computing task, in ways which are simply unheard of in most modern programming languages.
> 
> The code used to create GUI layouts (view layout \[]), for example, is a Rebol dialect which makes use of a specially designed syntax that eases the complexity required to create user interfaces. Compared to using object structures, drawing routines, event management functions, etc., this simple to read/write mini language is often *orders of magnitude easier to use*.
> 
> Rebol's built in GUI dialect allows for easy layout of widgets, but it doesn't stop there. One little feature of the GUI dialect, for example, lets users create new widget objects using the 'style word. Here's how you create and display 2 new button objects (tan, 400x50 pixels), derived (inherited) from the native 'btn object, which each alert the user whenever they've been clicked (the new objects here are called 'tanbtn):
> 
> ```
> REBOL []
view layout [
    style tanbtn btn tan 400x50 [alert "clicked"]
    tanbtn "button 1"
    tanbtn "button 2"
]
> ```
> 
> That code is really as concise as could possibly be created for the task - much simpler than structuring and interacting with object definitions, methods, properties, etc., but still providing the benefits which OOP and other approaches *claim as their reason for being*. The stark simplicity of Rebol's approach to reducing code complexity regularly succeeds in ways which other entire paradigms and ecosystems have failed.
> 
> Internally, the GUI dialect parsing function ('layout) converts the specialized simple GUI syntax into more complex lower level object, function, and variable constructs, which the interpreter puts to use (you can still access that functionality manually with the lower level constructs, if you want). The dialect just gives users control over salient properties of the underlying code structure, using a succinct syntax which is much more direct and clear to work with. It's an entire little language made specifically to build GUIs. The idea that composing functionality via higher layers of language structure, in this way, is the interesting take-away from this topic.
> 
> The 'VID' dialect built into Rebol has a default style which is blatantly old and ugly (it's been the same since the late 1990's), but that look can be easily updated - even the entire underlying rendering engine can be neatly swapped out. It is the substance of that whole topic which is still valid, useful, and eye-opening. It's important to note that VID isn't the only possible GUI dialect available to Rebol developers. Other people in the Rebol community have in fact come up with entirely different GUI dialects which support various other low level features, visual looks, design concepts, and totally different language interfaces for end users.
> 
> It's interesting to recognize that all of Rebol's native and 3rd party GUI dialects are so simple to read and write, that it's typically much faster to layout screens using them, than a visual drag and drop ("WYSIWYG") tool in a graphical IDE. *The code itself*, without any heavy third party tools used to aid complex code creation, provides the simplest possible solution to the problem.
> 
> Although Rebol's VID GUI is old looking (it's design was originally implemented to be just a simple example of how GUI dialects might be created), seeing it work in practice can lead to powerful realizations. The idea that complex layers of computation can be \*composed via layers of concise language constructs\*, as opposed to layers of brittle functions, objects, libraries, and other traditional "machine centric" code structures, is an unusual technique which most programming languages do not yet use to encapsulate functionality. Traditionally, heavy and complex tools such as IDEs are required to deal with code complexity. Rebol's goal is instead to eliminate code complexity from the beginning. All potential computing goals can be achieved by composing higher and higher levels of more powerful and specialized, simple code dialects, instead of introducing complex external tooling which is not integrated with the code.
> 
> Rebol was designed with dialect creation in mind as a fundamental approach to writing all types of code (the "relative expressions" in Rebol's acronym refer to dialects). Rebol provides the unique 'parse function and a set of key language features which make it simple to build dialects. But the GUI idea is just one potential use of dialects, and unfortunately it's often immediately dismissed because Rebol is lacking in visual design acumen. You can find existing dialects for 2D and 3D graphics and animation, tools which aid in the layout of HTML, CSS, PDF and other formats, graphic chart layout, tools which aid in code composition, manipulation and compilation for other languages (check out the powerful Flash dialect!), complex console printing and interaction, and many other domains. Designers of dialects can create specialized code structures to drastically reduce the complexity of syntax patterns needed to solve many other domain specific problems. Rebol is still ripe for creating dialects related to any new conceivable problem domains which may come in the future. Dialects are powerful not just because they provide another way to leverage the power of language, but because that method is so intuitive for the human mind to grasp and work with naturally. That approach is also infinitely variable according to setting, style, and taste. The ability to create languages which are structured as needed or desired to complete any specific category of tasks, is the key to dramatic productivity, when compared to the contrived methods which programming languages have used up until this point.

## 4. The End Result - Unmatched Simplicity

> The broad and deep capability embodied by the tiny Rebol interpreter (which weighs in at less than 1 megabyte, for even the fullest distributions with graphics, GUI, network, sound, database, math, compression, email, CGI, security, and other complex features included) is a testament to just how orders of magnitude of size and complexity can be reduced by implementing the language solutions which Rebol makes available. You will find that Rebol examples nearly universally consist of only a small fraction of the code volume needed in any other language, even in frameworks intended to "boost productivity" in more bloated environments. The small differences in code complexity demonstrated in short examples are magnified exponentially in larger apps.
> 
> That's because Rebol was designed relentlessly from the ground up to cut that bloat and code complexity - and it succeeds better than any tool that this author has ever witnessed (43 years old, actively coding since age 7, with decades of varied software development experience).
> 
> Many ideas in Rebol are common to all mainstream programming languages: functions, objects, conditional expressions, etc. It can be difficult to see beyond those details immediately, especially for experienced developers who are trained to look only for those constructs, so Rebol's greatest features are often missed completely. Rebol's entire reason for being is to eliminate the underpinning complexities wrought by building software upon layer after layer of existing bloated infrastructure. Read that again - Rebol builds the layers of technology needed to create any type of application, using layers of Rebol language, internally, wherever possible. Third party requirements are virtually non-existent.
> 
> Although not a marketing success, Rebol has been an enduring technical success. Rebol has been used in production environments for more then a decade and a half, and it represents a uniquely successful, readable and writable approach which has been sorely missed by the designers of nearly every other programming language. In a way that's different from other development tools, Rebol was created to be a virtual language toolkit, enabling simple language interfaces to be created which can handle complex coding problems easily. Its other "nice" features, the single unified series data/code structure, consistent and unified native interfaces to data sources, the readable 'parse syntax, numerous native data types, etc., all work together with simple code constructs, tiny deployment size, etc., to deal with complex programming endeavors, much more easily and more concisely than can be achieved by other paradigms.

Copyright � 2000-2015 Nick Antonaccio. All rights reserved.
