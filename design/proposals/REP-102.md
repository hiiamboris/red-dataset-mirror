
#102: WISH: replace class-of with a word-matching routine
================================================================================
Issue is open, was reported by hiiamboris and has 32 comment(s).
<https://github.com/red/REP/issues/102>

`class-of` has proven itself to be a design you can't rely on, see https://github.com/red/red/issues/4396
```
>> class-of a: object [x: 1]
== 1000444
>> class-of b: make a []
== 1000444
>> class-of b: make a [y: 2]
== 1000445            ;) once you add smth, it's a new class
```
It will still work for objects you never expect to be extended, but I like much more Python's "if it quacks like a duck, it must be a duck" philosophy because it's reliable. It boils down to this:
```
child-of: func [model [object!] child [object!]] [
    find/match words-of child words-of model
]
```
It works because `make proto new` adds `new` words after the words of the `proto`.

Problem with this mezz is that both `words-of` calls allocate new blocks, so one can easily overload the GC.
Another problem is that this operation is supposed to be lightning fast like, because it may be used in `on-deep-change*`, in timers, in event filters - time critical places.

I suggest we implement a routine version of it and ship it with Red runtime.

There can be naming variants though.. 
- funcs `parent-of child parent` vs `child-of parent child`
- vs ops `child child-of parent` vs `parent parent-of child`
- vs names `parent-of?` or `child-of?`
- vs shorter `parent?` and `child?`
- vs other words, e.g. `based-on`, `descendant-of`, `prototype-of`, `model-of` etc.

What name and type (func/op) should work better?



Comments:
--------------------------------------------------------------------------------

On 2021-03-26T14:30:31Z, loziniak, commented:
<https://github.com/red/REP/issues/102#issuecomment-808264980>

    > What name and type (func/op) should work better?
    
    Perhaps `made-from`, since we use `make` to create a child/descendant?
    I'd also count only `any-function!` words, to not relay on internal fields.

--------------------------------------------------------------------------------

On 2021-03-26T15:06:32Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-808291502>

    `any-function` won't do
    what if you're testing if `object [x: 1 y: 2 z: 3]` is a descendant of `object [x: 4 y: 5]`?

--------------------------------------------------------------------------------

On 2021-03-26T15:25:38Z, loziniak, commented:
<https://github.com/red/REP/issues/102#issuecomment-808307477>

    If we talk about duck-typing, we only care about functionality, not data/state, don't we? In the case you provided, I'd say object 1 is a functional descendant of object 2, because it includes it's functionality, which is NO functionality :-)

--------------------------------------------------------------------------------

On 2021-03-26T16:27:16Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-808353347>

    OK ;) But think about the data model. object 1 extends data model of object 2.
    Anyway, I don't know a use case for checking functions only. If you have any, let's consider it as an option.

--------------------------------------------------------------------------------

On 2021-03-26T16:36:07Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-808359084>

    Another more flexible option would be to check presence of all words of one object in the second object (regardless of their order), but this will be slower due to comparisons becoming hash lookups. It's more into the field of multiple-inheritance than just `make A [stuff]`.

--------------------------------------------------------------------------------

On 2021-03-28T04:03:17Z, greggirwin, commented:
<https://github.com/red/REP/issues/102#issuecomment-808840710>

    Seems there are conflicting goals: 1) flexible, 2) lighting fast. 
    
    I agree that Duck Typing means we care about compatibility, not what prototype(s) might have been used. This also plays against speed. Wording is tricky too, and I lean toward `made-from`, but even that may not be informative or complete enough. It's also a lie if we're talking about ducks that came from different bloodlines.
    
    Two thoughts:
    
    1) I have old set op funcs whose names might work, and be useful beyond this case.
    
    ```
    subset?: func [
    	"Returns true if A is a subset of B; false otherwise."
    	a [series! bitset!]
    	b [series! bitset!]
    ][
    	empty? exclude a b
    ]
    
    superset?: func [
    	"Returns true if A is a superset of B; false otherwise."
    	a [series! bitset!]
    	b [series! bitset!]
    ][
    	subset? b a
    ]
    ```
    
    Since all they return is a `logic!` result, in theory we could do it at the R/S level and optimize copies away. That's a lot more work, without knowing how useful it will be in general. I would have to scour my brain to remember why I needed them in the past, though I know I did. This is going to be extremely limited from a feature standpoint, but can be fast for what are common cases with small objects. 
    
    2) A powerful spec matcher, which is not going to be light or fast. I've had this on my list for a long time, and draft notes and code to go with it. I think this will be great to have, even if as an optional module.

--------------------------------------------------------------------------------

On 2021-03-28T11:13:58Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-808881950>

    > Seems there are conflicting goals: 1) flexible, 2) lighting fast.
    
    True. 
    After some more study of the code, I think that flexible version will be fast enough for the task.
    
    Objects already possess a hash table. Setup code may be done only once:
    https://github.com/red/red/blob/9d91cdd273a9c9f7851d7a3a70750a3b77b22f71/runtime/hashtable.reds#L1723-L1746
    
    Lookup code should be repeated for every word, but they're pretty light - should be 1-2 iterations on average, no hashing done. Plus it will iterate until the first failed lookup, making negative cases even quicker:
    https://github.com/red/red/blob/9d91cdd273a9c9f7851d7a3a70750a3b77b22f71/runtime/hashtable.reds#L1748-L1766
    
    Red's baseline speed (on my laptop) is about 40-50ns per token.
    Thing as simple as `in obj 'word` takes about 250ns.
    `class-of face!` - 240ns.
    `find/match [a b c] [a b]` - 350ns.
    `find/match set-of-30 set-of-25` - 800ns (success), 300ns (early failure). That's the top throughput we can count on: ~1.2M ops per sec. So if timer fires at 60 FPS, it's 20k ops per one timer iteration max. If timer manages to keep it under 2k ops per iteration, slowdown is acceptable, under 400 ops - negligible. Divide op count by 5-10 for old machines.
    Benchmarks will tell for sure, but just from the looks of the code I don't see why ~25 lookups (count of words in a face) should take up total to more than 1000ns if lookups are made in one batch. In fact, I don't see why it can't be done in 500ns (considering that `find` has to account for a lot of other stuff, this routine may be faster than `find`).

--------------------------------------------------------------------------------

On 2021-03-28T18:17:36Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-808936110>

    On `subset?` & `superset?`.. hopefully the algorithm can be generalized to support also these two cases.
    Super duper spec matching is for another day though ;)

--------------------------------------------------------------------------------

On 2021-03-28T18:19:57Z, greggirwin, commented:
<https://github.com/red/REP/issues/102#issuecomment-808936544>

    Thanks for the numbers, which are like candy to me. Actually, better because I don't eat much candy. 
    
    The most important thing is correctness in the context of use. @dockimbel needs to weigh in on his original design goal for `class-of`, or if it was just a placeholder. These new approaches seem to augment that, not replace it though. In looking at my old object lib collection, there are a number of things that we can consider in letting people play with objects in different ways. Super-spec is bigger, yes. 

--------------------------------------------------------------------------------

On 2021-03-28T18:21:29Z, greggirwin, commented:
<https://github.com/red/REP/issues/102#issuecomment-808936792>

    The great thing about code that *might* be too slow is that we'll find out when it is, and can optimize it then. As long as we don't botch the interface to things too badly, I'm all for slow code. 

--------------------------------------------------------------------------------

On 2022-10-06T08:45:43Z, qtxie, commented:
<https://github.com/red/REP/issues/102#issuecomment-1269604452>

    Related issue https://github.com/red/red/issues/4269.

--------------------------------------------------------------------------------

On 2022-10-17T12:30:24Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-1280783010>

    Work on Spaces has opened a new dimension to this topic.
    
    Yes, as a user of the object, duck-typing is enough for me to interact with it.
    But I implemented per-class type & value checking and on-change handlers. Per-class for two reasons:
    - per-object creation of needed infrastructure would be too slow to be of use
    - there would also be significant RAM usage needed to hold this infrastructure in every object
    
    For this resource economy use case, two seemingly identical ducks may belong to different classes and vary in their checks or on-change handlers. For example, general `list` is different from a specialized `list` belonging to `list-view` widget (mainly to support infinite dimensions). What I do is tell Red that "this object belongs to that class" at construction time. Often I reclassify it multiple times, a simplistic illustration:
    ```
    ascendant-template: [
        classify-object self 'ascendant
        x: 1  #type [integer!]
    ]
    descendant-template: append copy/deep ascendant-template [
        classify-object self 'descandant
        x: 1x1   #type [pair!]
    ]
    ```
    If we had language (R/S) support for features of #132 then I suppose it could be fast enough and not require too much RAM as long as on-change body is referenced, not copied. Then it could be supported on per-object granularity, and there would be no need for such non-duck-like classes. It would still require though per object word: a typeset and a few references to checking code, and the checking code itself, so still a few times the RAM a simple hash-backed object takes, so doesn't seem like a sound option. Maybe if we had both simple and typed objects as different types, or if simple object would be promoted to typed one on demand, so users would have a choice, that would be more acceptable. Still doesn't grab me yet. Having a hidden class name or reference seems like a better solution.
    
    So this is deeper than I thought. Basically it comes down to two interpretations: "does it behave like 'class?" or "does it work internally as 'class?" (is this duck live or robotic?).

--------------------------------------------------------------------------------

On 2022-11-06T16:44:49Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-1304841812>

    Also a bit of an issue here is that `system/words` will qualify as any other duck, because it has all the words :)
    ```
    >> face? system/words
    == true
    ```

--------------------------------------------------------------------------------

On 2025-06-15T06:34:52Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-2973535145>

    Since there's now a chat about this issue and classes, let me outline my proposed single-inheritance solution:
    1. `make` spec block may optionally contain type constraints (for runtime type checking), value constraints (for stricter checking - ranges, sets...), equality type (for change detection control), and docstrings for both the class and each value (for runtime reflection and documentation generation)
    2. It should convert the spec block into a *class* spec which should contain all the above info as a table, including the defaults where the user didn't specify anything. 
    3. *Class* must be a first class citizen (maybe just a reference to its spec). We don't want to copy typechecks/equality/docstrings into every new object - it all belongs to the class. Then one may be able to name a class (reference it by a word) for convenience (e.g. `face!`).
    4. We should be able to convert such class into a text table using `form` and back into its spec block using `mold`. If class is more than just its spec, `spec-of` must be able to get the spec. `source my-object` may be an alias for `print mold class-of my-object`, so that we may inquire into the object's class directly given the object.
    5. We must be able to build more objects from just a class: in this case, since the spec is already processed, it's just a fast operation of spawning an object and attaching a class reference to it. And the new object's class should the the same class we have provided.
    6. A class must not be modifiable. Its words must be fixed, its constrains and values be read-only (otherwise such modification would undermine all the existing objects compatibility with it).
    7. Any object may be *classified* as an object belonging to some class, named or indirectly passed from another object, at runtime: `classify my-object my-class` (if the object is modified) or `as my-class my-object` (if only the cell is modified). This operation must fail if any of the class words are missing in the object or if existing words type constraints are not met. It should not take into account any object words not present in the class. It can be repeated any number of times, including changing the object class from one to another. A `classify/force` variant may be useful: when a word typecheck fails, it would set its value to its class default, without erroring out.
    8. Class belonging may be tested in a straightforward manner by comparing `(class-of object1) = (class-of object2)` (assuming all manners of equality for classes mean sameness). This is enabled by (3).
    9. Class belonging may also be tested by something like `my-object classifies-as my-class`, which is just a more readable way of saying `superset? my-object my-class` (personally I have trouble figuring out here whether it asks if the 1st is the superset of 2nd or vice versa). 
    10. Given the *same* spec block `make` must attribute the objects to the *same* class. This is not a requirement, but seems to me good for the programmer's sanity. We may even extend it to the strict equality of the spec block if we hash its contents and make a hashtable of such hash into class references.
    11. Default *classification* without a manual `classify` call:
        a) `make <class> <spec>` must produce an object of class `class` (as Nenad notes the problem with it is that the result must be of type `class!`, not `object!`)
        b) `make <object> <spec>` must produce an object of the same class as `object`
        c) For `make object! <spec>` I see two options:
        - initially I thought about it producing a new class, but respecting (10)
        - but a more explicit and straightforward behavior would be to make it the most of the basic `object!` class, and let `make class! <spec>` be an explicit way to create a new class
    
    Note that `function!` shares a lot with this: function's own description, description of each of its words, typeset for each word, just no equality or value checks, and currently no runtime assignment checks (though there was a request for that). Meaning that the `red-context!` can probably become the *class*.

--------------------------------------------------------------------------------

On 2025-06-15T18:37:46Z, greggirwin, commented:
<https://github.com/red/REP/issues/102#issuecomment-2974540273>

    Great outline @hiiamboris. 

--------------------------------------------------------------------------------

On 2025-06-22T05:45:37Z, hiiamboris, commented:
<https://github.com/red/REP/issues/102#issuecomment-2993953634>

    What would happen to the [above proposal](https://github.com/red/REP/issues/102#issuecomment-2973535145) if we decided not to make class a first-class citizen (and avoid having an extra datatype)?
    
    We remove the current `class-of` from the language. Class info will be attached to objects (often shared), but on Red level an object is the only reference to that class info. There's no explicit control over it, but there must be documented ways to share, copy and extend it. The model resembles that of the Red series: object is similar to series, and class info is similar to the hidden referenced series buffer. Internally it still may be a `red-context!` node, and Redbin should be able to detect class sharing.
    
    `as obj1 obj2` or `to obj1 obj2` can still be used to force an object's class, using an object reference to it. But latter is currently equivalent to `to type? obj1 obj2`, so we may still want separate `classify` routine. Similarly, `obj1 classifies-as obj2` could be used to compare object classes.
    
    A class can be considered destroyed as soon as there are no more references to objects of this class.
    
    If we create a class object `a` from a `spec` block, and then forget that object, and then create a new class object `b` from the same `spec` - are classes of `a` and `b` the same? We can't compare directly, because there's no reference to `a` anymore. But what if we saved `a` and loaded it again? Current Redbin implementation does not preserve sameness between the saved data and the running interpreter's data, but what if it will one day?
    
    Objects are modifiable, but class default values can still be stored in the class info. But then let's say we create an object `a: object [x: 0 #type [integer!]]` and then modify it: `a/x: 1`. What do we expect from `make a []`? `x = 1` (from `a`) or `x = 0` (from class default)? I expect `x = 1`, so storing class defaults makes no sense anymore, and values must be copied from the prototype object. `classify/force object [x: y: "z"] a` must produce an `object [x: 1 y: "z"]` then. 
    
    Internally we still have two operations: class creation and object creation. But we only have to expose: *object creation* and *class+object creation*, not *class creation* because the result of the latter we cannot reference.
    
    The most common operation - making an object of an existing class - can be just `make proto spec`, where `proto` object's class gets assigned to the resulting object. For that to work, `spec` must not contain any *class syntax* (type/value checks, docstrings, etc) but it can contain new words (then we accept that class info might be missing for some words, i.e. class info size <= object size). If it does contain that info, resulting object has to be of a new class to hold the additional class info.
    
    Alternative ways (but why?):
    - a separate from `make` native that does not accept any class syntax 
    - don't let `make` accept class syntax, but designate a separate native (e.g. `declare`) that accepts it
    
    We lose `form <class>` and `mold <class>`, so we need a separate routine to read and format the class info. `spec-of <object>` is still an okay fit to get the spec as Red data, but what facility is there to format it as text? There could be a dedicated formatting function that `source <object>` would call with a given spec. Also, `spec-of` returning a block will be reducing the class info *table* into a linear array, which suffers in both usability, by-word lookup speed and any code working with it is easily broken by changes in the block format.
    
    On automatic combining of classes... Ideally whether class info is shared or not should be just an implementation detail, hidden from the Red developer, who should expect class equality if class info looks similar. But binding and series buffers as usual make it complicated.
    
    Consider:
    1. `a: make object! spec: [x: 1 #type [integer!]]` and `b: make object! spec` (same spec). Are they of the same class?
    2. `a: make object! [x: 1 #type [integer!]]` and `b: make object! [x: 1 #type [integer!]]`. Same prototype, spec isn't the same but values in it are the same, so all values in the class info compare by sameness. Are they of the same class?  
    3. `a: make object! [x: "x" #type [integer!]]` and `b: make object! [x: "x" #type [integer!]]`. Same prototype and equal spec but strings are not the same (but class info is still equal). Are they of the same class?  
    4. `a: make object! [x: 1 #type [integer!]]`, `b: make a []` and `c: make (object [x: 1 #type [integer!]]) []`. Are these all of the same class?
    
    If we do hash class info, do we hash the nodes of value checks and per-field on-change functions or their symbolic representation? And what changes if if we add values to the class info, to support class default values?
     

