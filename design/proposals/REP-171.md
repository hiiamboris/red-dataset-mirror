
#171: WISH: `apply` design to cover function extension cases
================================================================================
Issue is open, was reported by hiiamboris and has 6 comment(s).
<https://github.com/red/REP/issues/171>

It was originally one of the use cases: [here](https://github.com/greggirwin/red-hof/blob/master/apply.md#1-function-extension) and [here](https://github.com/red/red/wiki/%5Bdesign%5D-apply-function#extend) and [here](https://github.com/hiiamboris/red-mezz-warehouse-gitlab-mirror/blob/7b3e0c3cdca1b1e2d1cd3003a4d001cd340c176d/new-apply.red#L11-L12)

Currently still, general extension of other functions with `apply` is quite convoluted. Example - extend any function with a single print statement:
```
traced: function [f [word! path!]] [
	args: parse spec: spec-of get f [collect any [
		/local to end
	|	set w [word! | lit-word! | refinement!] keep (to get-word! w)
	|	set w get-word! keep (to paren! w)
	|	skip
	]]
	func spec compose/deep/only [
		print (rejoin ["in " f])
		apply/all quote (f) compose/only (args)
	]
]
```
In the above I have to parse and arrange an argument list, fill it with get-words to avoid double evaluation, then on every invocation `compose` it to prepare values for possible get-args.

Test:
```
>> probe': traced 'probe
>> probe' "abc"
in probe
"abc"
== "abc"
>> quote': traced 'quote 
>> quote' probe
in quote
== probe
```
This wish is to have an easy extension without the need for composition on each call.



Comments:
--------------------------------------------------------------------------------

On 2024-12-01T18:36:58Z, GiuseppeChillemi, commented:
<https://github.com/red/REP/issues/171#issuecomment-2510201090>

    Other than the need for a "passive mode" for the values block, the task of extending a function has another requirement:
    
    The new function could have more arguments as it supports new refinement and args. So, if you call the old function, you need to match 1 -1 the existing arguments in both sides. This could be accomplished in an easy way if you support either:
    
    - a context whose words are matched by name with the called function specs (and non existing ignored)
    
    In this way: a simple `apply :f <object-here>` would match the arguments too
    
    - a block of words which are matched by name with the called function specs and value taken  (and non existing ignored)
    
    With this technique: `apply/match :f [word1 word2]` would match the function arguments without convoluted solutions

--------------------------------------------------------------------------------

On 2024-12-01T18:47:32Z, hiiamboris, commented:
<https://github.com/red/REP/issues/171#issuecomment-2510204782>

    > The new function could have more arguments as it supports new refinement and args.
    
    Actually this was pretty much covered by the `apply 'my-func 'local` idea. Without any new objects spawned.

--------------------------------------------------------------------------------

On 2024-12-02T02:43:53Z, GiuseppeChillemi, commented:
<https://github.com/red/REP/issues/171#issuecomment-2510448905>

    > > The new function could have more arguments as it supports new refinement and args.
    > 
    > Actually this was pretty much covered by the `apply 'my-func 'local` idea. Without any new objects spawned.
    
    So you are proposing that if you pass a word, its context is used. If you support this, then supporting objects should be 1 line of code difference or less.
    Instead, supporting block of words, whose names should match, and passive mode, opens the door to function arguments coming from getting values from map keys too.
    
    

