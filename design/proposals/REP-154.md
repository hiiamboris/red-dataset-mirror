
#154: `rejoin` redesign
================================================================================
Issue is open, was reported by loziniak and has 24 comment(s).
<https://github.com/red/REP/issues/154>

I tried `rejoin` on some different combinations of values, and it gives some unexpected results for me, given a description, that it "joins a block of values":
```
>> rejoin [[2 3][4 5]]
== [2 3 [4 5]]
>> rejoin [<tag1> <tag2>]
== <tag1<tag2>>
>> rejoin [quote (2 3) quote (4 5)]
== (2 3 (4 5))
```
I'd expect it to work like that:
```
>> rejoin [[2 3][4 5]]
== [2 3 4 5]                    ; OK
>> rejoin [<tag1> <tag2>]
== <tag1tag2>                   ; OK
>> rejoin [quote (2 3) quote (4 5)]
== (2 3 4 5)                    ; OK
```
And there is also a strange behavior with paths:
```
>> p: rejoin [quote a/b quote c/d]
== a/b/c/d
>> a: [b [c [d 10]]]
== [b [c [d 10]]]
>> get p
== none                    ; p is unexpectedly broken
>> p2: to path! [a b c d]
== a/b/c/d
>> get p2
== 10                      ; ...and should work like p2
>> to block! p
== [a b c/d]               ; something is wrong
>> to block! p2
== [a b c d]
```


Comments:
--------------------------------------------------------------------------------

On 2023-11-06T19:29:22Z, hiiamboris, commented:
<https://github.com/red/REP/issues/154#issuecomment-1796151278>

    `tag1<tag2>>` is a problem of tags, not of `rejoin`. And in fairness the block/path issue can be fixed by rewriting the docstring of `rejoin`. So what are you proposing in the end?
    

--------------------------------------------------------------------------------

On 2023-11-06T20:11:35Z, loziniak, commented:
<https://github.com/red/REP/issues/154#issuecomment-1796341951>

    I see rejoin like this:
    ```
    rejoin: func [
        "Reduces and joins a block of values." 
        block [block!] "Values to reduce and join"
    ] [
        if empty? block: reduce block [return block]
        joined: either series? first block [copy first block] [to string! first block]
        while [not empty? block: next block] [
        	append joined first block
        ]
        joined
    ]
    ```
    And I'd get over the tags, as well as emails and urls.

--------------------------------------------------------------------------------

On 2023-11-06T20:39:10Z, loziniak, commented:
<https://github.com/red/REP/issues/154#issuecomment-1796397146>

    Good to keep an eye on #134 too.

--------------------------------------------------------------------------------

On 2023-11-06T21:19:58Z, hiiamboris, commented:
<https://github.com/red/REP/issues/154#issuecomment-1796507769>

    > I see rejoin like this:
    
    Given its importance, this won't cut, because:
    ```
    ;; minimal code
    >> clock/times [append form 1 [2 3 4 5 6 7 8 9 10]] 1e5
    2.52 μs	[append form 1 [2 3 4 5 6 7 8 9 10]]
    == "12345678910"
    
    ;; native rejoin, interpreted
    >> rejoin: func spec-of :rejoin body-of :rejoin
    >> clock/times [rejoin [1 2 3 4 5 6 7 8 9 10]] 1e5
    5.86 μs	[rejoin [1 2 3 4 5 6 7 8 9 10]]
    == "12345678910"
    
    ;; your one
    >> clock/times [rejoin [1 2 3 4 5 6 7 8 9 10]] 1e5
    16.1 μs	[rejoin [1 2 3 4 5 6 7 8 9 10]]
    == "12345678910"
    ```

--------------------------------------------------------------------------------

On 2024-01-03T19:03:18Z, loziniak, commented:
<https://github.com/red/REP/issues/154#issuecomment-1875830653>

    At least it's not an order of magnitude. Perhaps it could be optimized, I did not write it with speed in mind.

--------------------------------------------------------------------------------

On 2024-01-15T22:55:47Z, greggirwin, commented:
<https://github.com/red/REP/issues/154#issuecomment-1892848541>

    While I don't press for TDD most of the time, I do think that spec'ing expected results would be a good plan for this. So then we know what the edge cases and designed behavior are.

--------------------------------------------------------------------------------

On 2024-01-16T04:38:21Z, greggirwin, commented:
<https://github.com/red/REP/issues/154#issuecomment-1893059212>

    This would be slower than now, but faster than @loziniak's.
    ```
    rejoin-foreach: function [
        "Reduces and joins a block of values." 
        block [block!] "Values to reduce and join"
    ] [
        if empty? block: reduce block [return block]
        joined: either series? first block [copy first block] [to string! first block]
        foreach val next block [append joined val]
        joined
    ]
    ```
    But we have to consider breaking code as well. In this case I can't guess how much depends on the current behavior, and feel fairly safe if we decide to change it. But this also falls into design chat on `join/combine` in this space.

--------------------------------------------------------------------------------

On 2024-02-12T10:58:40Z, loziniak, commented:
<https://github.com/red/REP/issues/154#issuecomment-1938453724>

    > spec'ing expected results would be a good plan for this
    
    I'd start with examples from OP:
    ```
    >> rejoin [[2 3][4 5]]
    == [2 3 4 5]                    ; not: [2 3 [4 5]]
    >> rejoin [quote (2 3) quote (4 5)]
    == (2 3 4 5)                    ; not: (2 3 (4 5))
    >> p: rejoin [quote a/b quote c/d]
    == a/b/c/d
    >> a: [b [c [d 10]]]
    == [b [c [d 10]]]
    >> get p
    == 10                           ; not: none
    >> to block! p
    == [a b c d]                    ; not: [a b c/d]
    ```

--------------------------------------------------------------------------------

On 2024-02-12T11:08:21Z, hiiamboris, commented:
<https://github.com/red/REP/issues/154#issuecomment-1938468534>

    This seems nice and predictable but how would one make it output a string (primary use case)?

--------------------------------------------------------------------------------

On 2024-02-12T23:07:25Z, greggirwin, commented:
<https://github.com/red/REP/issues/154#issuecomment-1939757813>

    > a: [b [c [d 10]]]
    
    Same as now I suppose, by putting a string as the first value in the block. Or any non-block value for that matter.

--------------------------------------------------------------------------------

On 2024-02-12T23:15:35Z, greggirwin, commented:
<https://github.com/red/REP/issues/154#issuecomment-1939765981>

    But we should look at this vs `repend` as well. As Boris notes, building strings is the primary use case, but I imagine a lot of us have code that builds blocks with it as well. Also handy for building paths, given a root path.

--------------------------------------------------------------------------------

On 2024-02-12T23:19:11Z, greggirwin, commented:
<https://github.com/red/REP/issues/154#issuecomment-1939769441>

    Old `join/combine` idea: https://gist.github.com/greggirwin/24c022cb5dde5771531a8939309ccb43
    
    I have an updated version with `/only/case/exclude` thoughts.

