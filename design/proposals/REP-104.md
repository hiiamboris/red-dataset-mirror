
#104: WISH: some way to look for series using find/same
================================================================================
Issue is open, was reported by hiiamboris and has 8 comment(s).
<https://github.com/red/REP/issues/104>

We can **search** for blocks with `find series value` (and `find/case`) in **2 ways**:
```
>> find [1 2 3 [2 3]] [2 3]
== [2 3 [2 3]]
>> find/only [1 2 3 [2 3]] [2 3]
== [[2 3]]
```
1. for an index after which all items are equal to those *in the value*
2. for an index of item which *equals value*

(2) automatically applies equality to each item in the series if the length is equal, so **both ways recursively** apply equality to series content.

With `find/same` the picture is quite different:
1. `find/same series1 series2` applies sameness to each item, but it's a shallow application, not recursive
2. `find/same/only series1 series2` does not ask sameness from it's items, because of how `same?` works

Thus the following scenarios are **not covered**:
```
>> c: copy b: copy a: object [x: 1]
>> r: compose/deep [(in a 'x) (in b 'x) (in c 'x) [(in a 'x) (in c 'x)] [(in b 'x) (in a 'x)]]
== [x x x [x x] [x x]]
>> find/same r reduce [in b 'x in c 'x]
== [x x [x x] [x x]]        ;) this is possible (1)
>> find/same/only r reduce [in a 'x in c 'x]
== none                     ;) can't look for a similar block in which all items are "same"
>> find/same r compose/deep [(in c 'x) [(in a 'x) (in c 'x)]]
== none                     ;) can't look for blocks containing blocks of "same" items
```
In other words, we can't replace `same?` comparator for blocks (that only checks the block header) with a comparator that applies `same?` to the items of the block (up to a desired nesting level).

The **use case** for me is: having a bunch of paths e.g. `[grid/cell grid/cell grid/cell ...]` (each representing a UI item) I wanna look for a specific one (e.g. one focused - to switch focus to the next one).
Options I have roughly:
1. Traverse the whole block without R/S support, dumb and slow. Even to check if the path at the current index is the one I'm looking for, I would have to use `find/same/match` trick.
2. Flatten the block and use some delimiter instead of grouping by blocks (e.g. `|`). Then use `find/same`. And a little extra work to obtain the index into the original list.
3. Collect objects from all words, dump them into a hash. Then replace each word in the original list with the index in this hash, and use just `find`. Word->index mapping becomes my collision-free hash function, kind of.

What I would like is some kind of **out of the box solution**. Though tough question is - how would `find` support of these cases look like? Any better ideas?

P.S. logs above are from the https://github.com/red/red/pull/4857 branch. `master` is buggy, don't try this at home.



Comments:
--------------------------------------------------------------------------------

On 2021-04-10T21:37:00Z, greggirwin, commented:
<https://github.com/red/REP/issues/104#issuecomment-817205513>

    It's tricky, isn't it, because you're making a same-ish, but not really the "same" comparison. If you're doing a `same?` comparison, then it has to be the same series. Making this a special case seems like it could be confusing, especially as `find` already has a lot of refinements. I don't know if extending `find` is the best place for granular control, unless it's done with a comparator parameter. And then maybe it's better as a new func, at least to experiment. It's beyond what `parse` is meant to match as well. 
    
    I'm not clear on how your second example _should_ work. e.g. `b/x c/x` isn't in `r` at all, unless you want that to match the non-sub-block values, which means ignoring `/only` effectively.
    
    If you have something setting focus, while it's certainly more functional to compute the lookup each time, what about maintaining the index in a state? Either that, or keying the structure for lookups as an alternative to flattening and delimiting. That's just a spin on your third alternative though.

--------------------------------------------------------------------------------

On 2021-04-11T08:38:32Z, hiiamboris, commented:
<https://github.com/red/REP/issues/104#issuecomment-817271395>

    > I'm not clear on how your second example _should_ work. e.g. `b/x c/x` isn't in `r` at all
    
    My mistake. Changed it to `[in a 'x in c 'x]`.

--------------------------------------------------------------------------------

On 2021-04-11T08:57:16Z, hiiamboris, commented:
<https://github.com/red/REP/issues/104#issuecomment-817273645>

    Same issue will hit us with floats eventually.
    ```
    >> a: reduce [0 / 0.0]
    == [1.#NaN]
    >> b: copy a
    == [1.#NaN]
    >> a = b
    == false
    >> a == b
    == false
    >> a =? b
    == false
    ```
    Though I just copied `b` from `a`, I have no way to match them without `find/match/same` (but even that doesn't work for some reason, need to fix the PR).
    
    As such, the copied blocks become non-searchable:
    ```
    >> x: [1] y: [2.0] z: reduce [0 / 0.0]
    >> r: reduce [copy x copy y copy z]
    == [[1] [2.0] [1.#NaN]]
    >> find/only r z
    == none
    >> find/only/case r z
    == none
    >> find/only/same r z
    == none
    ```
    
    What *could* solve this case and the original one, is another comparison mode, e.g. `same-scalar?` that would check for type equality on series then apply `same?` only to scalar types. `find/only/same-scalar series value`. As `equal?` and `strict-equal?`, such mode would be [distributive](https://en.wikipedia.org/wiki/Distributive_property), while `same?` isn't.
    
    I'm still unsure this would be the best solution though. Need to think of ramifications of such an addition.

--------------------------------------------------------------------------------

On 2021-04-12T10:31:08Z, hiiamboris, commented:
<https://github.com/red/REP/issues/104#issuecomment-817695338>

    I've come to realize that for my need `same?` is too strict. It compares contexts the word belongs to, but I'm generating those contexts on the fly, so they're different. What only I care about is *sameness of values* the words point to:
    ```
    same-paths?: function [p1 [block! path!] p2 [block! path!]] [
    	to logic! all [
    		p1 == as p1 p2									;-- spelling & length match
    		find/match/same									;-- values match
    			reduce/into as [] p1 clear []
    			reduce/into as [] p2 clear []
    	]
    ]
    ```
    Which is yet another not available out of the box way to compare words :)

