
#108: WISH: make op! to ignore refinements
================================================================================
Issue is open, was reported by hiiamboris and has 2 comment(s).
<https://github.com/red/REP/issues/108>

Sometimes it's useful and fun to convert certain natives and functions into operators:
```
>> ++: make op! :append   ;) fails because append has refinements
>> "a" ++ "b"
== "ab"

>> +=: make op! :incr     ;) fails because incr has /by refinement
>> long-var-name: 10
>> long-var-name += 20    ;) instead of long-var-name: long-var-name + 20
== 30

>> =>: make op! :apply    ;) fails because apply has /verb[atim] refinement
>> find => [series: "haystack with a needle here" value: "needle"]
== "needle here"
```
(etcetera)

It is logical to expect this to work, so would be nice if Red made it possible.
Besides, such operators are interpreted twice faster than functions (because ops don't have to look ahead to see if there's another operator waiting, like is the case with `f: func [x][]  f 1 * 2 * 3`), so could provide a boost to interpreted code when it matters.

Right now the workaround is to define a `function!` wrapper, but it slows down these operators when used in performant code.



Comments:
--------------------------------------------------------------------------------

On 2021-10-26T09:03:00Z, hiiamboris, commented:
<https://github.com/red/REP/issues/108#issuecomment-951732605>

    An even more interesting idea: such operators could "fix" some of the refinements (if those are nullary), e.g.:
    ```
    >> has?: make op! :find/only     ;) fixes /only to true
    >> [[1] [2]] has? [1]
    == true
    ```
    
    Again, totally possible today, just harder and slower.

