
#129: Q: What can be done to marry GC and global registries?
================================================================================
Issue is open, was reported by hiiamboris and has 24 comment(s).
<https://github.com/red/REP/issues/129>

Take reactivity system as an example:
```
>> print [stats / 1e6 "MB used"]
5.160548 MB used

>> object [a: append/dup [] 'x 10'000'000]
>> print [stats / 1e6 "MB used"]
406.253108 MB used

>> recycle
>> print [stats / 1e6 "MB used"]
3.582024 MB used              ;) GC collected the unused object

>> reactor [a: append/dup [] 'x 10'000'000]       ;) performing same trick with a reactor
>> print [stats / 1e6 "MB used"]
406.241236 MB used

>> recycle
>> print [stats / 1e6 "MB used"]
272.022124 MB used            ;) GC cannot collect it

>> clear-reactions
>> recycle
>> print [stats / 1e6 "MB used"]
272.061656 MB used            ;) ??!
>> dump-reactions
-- no reactions --
```
The issue is that as long as some global registry (like that of reactors and relations) holds a reference to data used either in a relation or in a reactor, a catch-22 situation happens:
- GC detects a reference and doesn't free it
- reference holder has no knowledge that object is garbage so can't remove the reference either

As a result memory just keeps growing. There are plenty other uses for global registries, so the problem is not local to reactivity.

Actually, I've no idea what's happening in the above code:
- I expected 16*10'000'000 = 160MB used, not 400
- what are those 135MB that were freed by the GC?
- what are those 270MB that cannot be freed even after reactions were cleared?

So probably we are also observing some bugs on top of the design issue. Or maybe some function-local caches in reactivity having this effect? At a glance, I see nothing of the sort there.

What I've tried as a workaround is putting all object-related data into the object itself, to avoid building a global registry. But I certainly **don't** wanna see all that molded, so that means hiding this data inside `on-change*`'s body and modifying it by directly editing the body. Hackish way seems the only way, which I don't like. But obviously not all tasks can be solved like this, and the problem of global registries stays.
 
`face!` object solves it's reactivity leaks by clearing face's relations once face is removed from the pane. But it's an ad hoc solution obviously. What if I want to add/remove face to a pane multiple times and preserve relations? There will be trouble unless this is solved language-wide.

I believe common solution is using weak references, but I haven't thought how that will apply to Red. Maybe as some series-wrapper datatype that evaluates to the value if it still exists, or to `none` if it was collected.




Comments:
--------------------------------------------------------------------------------

On 2022-09-14T18:25:42Z, greggirwin, commented:
<https://github.com/red/REP/issues/129#issuecomment-1247146958>

    Thanks for the research on this @hiiamboris. :+1:

--------------------------------------------------------------------------------

On 2022-10-01T14:42:01Z, dockimbel, commented:
<https://github.com/red/REP/issues/129#issuecomment-1264384915>

    A reference to the big block node is held in the ownership internal hashtable and never released, that's the cause of the issue. The following code should be working, but it seems there's an internal bug:
    ```
    >> r: reactor [a: append/dup [] 'x 10'000'000] 
    == make object! [
        a: [x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x ...
    >> recycle stats
    == 271211180
    >> modify r/a 'owned none
    == [x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x ...
    >> r: none
    >> recycle stats
    == 271211692
    ```
    
    Once that fixed, other changes are needed:
    *  `reactor!` should avoid tagging sub-series and sub-objects for `deep-reactor!` needs...
    * `clear-reactions` should integrate a call to `modify` in order to explicitly remove those ownership entries (on deep reactors).
    
    A proper handling of reactor objects should include a destructor function to clean-up any remaining series/object owning (using `modify`). The user should then call such destructors where/when needed, though there's a `destruction` object event in my personal wish-list to consider once we get the objects design enhancements (though, not sure if it would be compatible with the GC).
    

--------------------------------------------------------------------------------

On 2022-10-01T15:26:29Z, hiiamboris, commented:
<https://github.com/red/REP/issues/129#issuecomment-1264398053>

    What will be the trigger for destruction though? that's the catch :)

--------------------------------------------------------------------------------

On 2022-10-01T15:31:01Z, dockimbel, commented:
<https://github.com/red/REP/issues/129#issuecomment-1264399216>

    > What will be the trigger for destruction though? that's the catch :)
    
    The user calls the destructor manually, when the reactor is about to be cut from being referenced by any other value.

--------------------------------------------------------------------------------

On 2022-10-03T08:14:57Z, hiiamboris, commented:
<https://github.com/red/REP/issues/129#issuecomment-1265090670>

    So imagine I import two independent modules. Both use my object in some of their internal registries. Neither module may know if the other one is still using my object, so they can't call the destructor. Now it's my personal burden, which is annoying, humans doing computer job.

--------------------------------------------------------------------------------

On 2024-01-31T18:16:57Z, hiiamboris, commented:
<https://github.com/red/REP/issues/129#issuecomment-1919662217>

    Apart from graphs (like reactivity), some use cases: 
    1. Caches (most often suffer from this issue), messaging/signaling systems (as long as inbox exists the receiver cannot be freed). It's often unfeasible to put them into the object, because:
       - the object structure may not be under my control
       - it's often too heavy to reserve a whole word e.g. in 1000 objects if only a few of them will send messages
    2. Tracking of changes of values over time (when those values are associated with an object, e.g. last focused widgets or last widgets under cursor). Of smaller importance as usually a short lived lockup, at least for my cases.
    
    Alternatives to weakref include aforementioned weak series, but also weak map. In fact, #1 use case I always have for maps is to use objects as keys, but alas maps don't support that :/

--------------------------------------------------------------------------------

On 2025-01-11T14:40:08Z, dockimbel, commented:
<https://github.com/red/REP/issues/129#issuecomment-2585289512>

    For the record, here is the result after the big work on the GC and related memory improvements:
    
    ```
    >> print [stats / 1e6 "MB used"]
    3.063536 MB used
    >> object [a: append/dup [] 'x 10'000'000]
    == make object! [
        a: [x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x ...
    >> print [stats / 1e6 "MB used"]
    405.6768 MB used
    >> recycle
    == 3017416
    >> print [stats / 1e6 "MB used"]
    3.024108 MB used
    >> reactor [a: append/dup [] 'x 10'000'000]  
    == make object! [
        a: [x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x ...
    >> print [stats / 1e6 "MB used"]
    405.68356 MB used
    >> recycle
    == 3018440
    >> print [stats / 1e6 "MB used"]
    3.034268 MB used
    >> clear-reactions
    == []
    >> recycle
    == 3018956
    >> print [stats / 1e6 "MB used"]
    3.035308 MB used
    ```
    
    No leaks anymore.

--------------------------------------------------------------------------------

On 2025-01-11T15:56:21Z, GiuseppeChillemi, commented:
<https://github.com/red/REP/issues/129#issuecomment-2585310719>

    Great work @dockimbel ! We have seen in the previous months how long and difficult it has been rebuild it but with steady and constant improvements. 
    
    Now we have a solid, fast and better Red!
    
    Congratulations to you and @qtxie and anyone else involved.

--------------------------------------------------------------------------------

On 2025-01-12T16:52:30Z, dockimbel, commented:
<https://github.com/red/REP/issues/129#issuecomment-2585832053>

    >I expected 16*10'000'000 = 160MB used, not 400
    
    What you're missing is that you provide an empty literal block as destination for `append/dup`. In such case, that block will be expanded several times by doubling its size each time, creating increasingly bigger temporary series. If you pre-allocate the destination block, your expectation will be realized:
    
    ```
    >> object [a: append/dup make block! 10'000'000 'x 10'000'000]
    == make object! [
        a: [x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x ...
    >> print [stats / 1e6 "MB used"]
    163.040556 MB used
    ```
    
    I'll have a look in `append/dup` implementation to see if the expansion could be smarter in case of `/dup` usage.
    
    EDIT: on first look, it seems `append/dup` implementation, both for `any-block!` and `any-string!` are sub-optimal, so it should be possible to avoid those intermediary expansions entirely!

--------------------------------------------------------------------------------

On 2025-01-12T16:56:54Z, hiiamboris, commented:
<https://github.com/red/REP/issues/129#issuecomment-2585833298>

    Overlooked that ðŸ˜…

--------------------------------------------------------------------------------

On 2025-01-12T17:00:14Z, dockimbel, commented:
<https://github.com/red/REP/issues/129#issuecomment-2585834200>

    > Overlooked that ðŸ˜…
    
    Welcome to my world! ;-)

--------------------------------------------------------------------------------

On 2025-01-12T22:47:26Z, dockimbel, commented:
<https://github.com/red/REP/issues/129#issuecomment-2585949538>

    After new commit https://github.com/red/red/commit/1b21e3318995ed702c2e3463c02fe8bd678c9f8d:
    
    ```
    >> print [stats / 1e6 "MB used"]
    3.061464 MB used
    >> object [a: append/dup [] 'x 10'000'000]
    == make object! [
        a: [x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x ...
    >> print [stats / 1e6 "MB used"]
    163.022244 MB used
    >> recycle
    == 3016136
    >> print [stats / 1e6 "MB used"]
    3.022784 MB used
    ```
    :rocket::rocket:

