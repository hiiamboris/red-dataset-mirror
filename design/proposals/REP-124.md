
#124: How can we improve the design of rich-text?
================================================================================
Issue is open, was reported by hiiamboris and has 2 comment(s).
<https://github.com/red/REP/issues/124>

I have been using `rich-text` for a while, and am ready to discuss shortcomings and propose improvements.

I suppose reason for the current design is the flexibility it gives us: styling each letter separately with it's own font. However, I think for the majority of use cases font and style can be assumed constant for the whole paragraph.

The main issue of current design is a requirement of a face object. In more detail:

1. For each paragraph drawn, a *separate* rich-text face has to be created.

   Done naively (`code: [r: rtd-layout [""] r/text: "abc" r/size: 50x50 r/data: [] r/font: none]`) initialization of a single face takes ~250us. On a 20x500 table (10000 texts) it adds up to 2.5 seconds. Nobody wants to wait that much, plus some machines are much slower.

   I've fought this design a lot: pre-created my own variant of rich-text face, with hackishly "disabled" `on-change` & `on-deep-change` handlers, used `set-quiet` to set it's facets, and that dramatically improved the performance of such face creation (however now I have to call `size-text` after setting `/text` and before calling any `offset-to-caret` or `caret-to-offset` or they will not work - seems there's an internal cache updated by `size-text` only). But it's still dead weight and has to be fought against by everyone who is going to apply it to similar task.
   
   I have also created a per-space map to hold the cache of rich-text faces: one face per desired width. To avoid extra face objects.
   
   This just goes against the goal of Draw: it should be as fast as possible.
   
   I propose extending `text` Draw command with an optional wrap width, so inlined strings can be wrapped too.

2. Face conflicts with Draw commands.

   - `font` command is currently ignored when rich-text face is given, only `/font` facet from the face is used. In Spaces I have separated styles from widget logic, but this forces me to have a font object in each text space (it's logic part), while it really belongs to the style. 
   - `font` object has it's style (bold/italic, no underline or strikethrough), which can be applied from both `font` command and `/font` facet, while rich-text face also has positional overrides in `/data` (bold/italic/underline, no strikethrough); total mess!
   - GTK backend ignores `pen` currently: https://github.com/red/red/issues/4901 which is a natural consequence of so many levers controlling the same property
   - we have now: `pen`, `font/color` of `font` command, and `face/font/color` of the face (go figure now without strict rules!)
   - `fill-pen` is completely ignored (should it work? how does it play together with rich-text `face/color`? `face/color` takes priority when given?)
   - maybe `fill-pen` should control the filling of letters, and `pen` - the outline, `line-width` - thickness of the outline, like for shapes? graphic editors support this, but not sure if low-level rich-text implementation does

   `text` command extended with wrap width could leverage `pen`, `fill-pen`, `font/style`, which is the way Draw was designed to work. Moreover, pattern/bitmap pen is applicable to text as well, which is much more powerful than just `face/font/color`.

3. Unlike "inlined text" this rich-text face is prone to change from under you:

   Try:
   - create a draw block with rich-text face in it
   - change the rich-text face
   - force a redraw of the *same* block (e.g. by a deep *unrelated* change in the draw block if it's owned by a face) and the result will change
   - changes to the rich-text face itself cannot be detected by the owner of draw block in the current ownership design
   
   This limits the cacheability of such faces. E.g. I can't have a global cache of them, have to have single cache per space. 
   
   Obviously such unexpected changes lead to surprise bugs. Been there.

   Plus Draw's designed to have no external state, for reproducibility, and this breaks the design. `font` is an object too, but it can be assumed constant, while `rich-text`'s text, data and size are one-off properties.

4. Face creation is currently the only way to *measure* paragraph's extent.

   Imagine a word processor. Let's have a single paragraph big enough to fill half of the screen, e.g. 3k chars. Imagine we insert an image (maybe a raster emoji, or anything that's not supported by rich-text alone) into every line of such paragraph, e.g. we have 20 lines and 20 images. To illustrate:
   
   ![](https://i.gyazo.com/4858b549bc72dd6e12a4b9510d604815.png)
    
   How do we render this paragraph now? How do we wrap lines?
   
   Best idea I could come up with is this:
   - split it on images, resulting in slices that will cross the line boundary
   - place each slice on a canvas with width extending from the right corner of the image up to the wrap margin
   - use `offset-to-caret` on top right corner of the canvas to find out at which index the wrapping occurred
   - split the slice at the obtained index
   - render only the part that fits within the line
   - continue this until whole paragraph is rendered
   
   Clearly, not the most straighforward way. Could there be a function that takes string and width (as integer) and returns same string *offset by* the number of chars that fit into given width? I can do that with the idea described above, but this should be in the language. Officially.

   Could `size-text` be enhanced to measure text without faces or other intermediate objects?\
   This is the biggest issue I'm seeing with command-based approach. If text inherits Draw state, how can we export that state to measure the text? Or if we measure the text with Draw's default state, we'll need to insert state reset (pen, font) before Draw's `text` command, to sync what was measured with what is about to be rendered.

5. Draw requires rich-text face as an `object!`, which requires `compose` or (usually) `compose/deep`.

   Would be nice to have `:get-words` in Draw for this.

6. I can imagine Draw's `text` also accepting the `data` block of rich-text for full control over each letter. Then it will even be superior to the face.

7. As I was contemplating the list of rich-text face facets: `type offset size text image color menu data enabled? visible? selected flags options parent pane state rate edge para font actors extra draw tabs line-spacing handles` I noticed that only a few are relevant: `size text (color?) flags (para?) font tabs line-spacing handles`. While most of these facets have no meaning in the rich-text surface context.



Comments:
--------------------------------------------------------------------------------

On 2025-03-02T16:47:31Z, hiiamboris, commented:
<https://github.com/red/REP/issues/124#issuecomment-2692811691>

    In addition to the design rant above, here's an outline of some additional *functionality* that I would like to have for rich text out of the box:
    
    1. Measurement of the text size (see https://github.com/red/red/issues/4841):
       - without considering trailing spaces of any kind (as it works today)
       - considering trailing spaces on the last line (e.g. we want to draw a frame around a text fragment where spaces are significant - this is used a lot in Spaces)
       - considering trailing spaces on all of the lines (e.g. user inserts a space char after one of the lines and caret must advance with every added space, and we want the whole text's size to include all the trailing spaces and the caret)
                                                                                               
    2. Measurement of the longest word width (see REP #126)
    
       Currently it requires replacing all word separators in the text with a newline and sizing the whole text in that state.
       
       Such width is useful to know when we don't want to break words apart in the text, so we set the minimum width of the text widget to this value.
       
       Alternatively, a flag to enable word wrapping but not character wrapping could work. Or both.
    
    3. Measurement of each line's width
    
       Currently only line's height is easy to get. Line's width requires finding the last char on that line and getting its bounding box.
    
    4. Ellipsized *display* (see REP #174)
       - of every line that's wider than the layout (e.g. when there's no wrapping or only word wrapping is enabled) 
       - of the last line when text is taller than the layout (regardless of the wrapping mode)
       
    5. Attributes overlaps (see REP #137)
    
       This may make high level dialect more suitable for use editors
       
       

