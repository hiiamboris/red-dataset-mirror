
#109: WISH: a way for `copy` to turn off the smarts
================================================================================
Issue is open, was reported by hiiamboris and has 0 comment(s).
<https://github.com/red/REP/issues/109>

This code took some hours to debug (this is simplified version ofc):
```
c: context [
	x: "abc"
	f: does [?? self print ["x:" mold :self/x]]
	data: context [g: :f]

	do2: function [code][
		saved: copy data
		; set saved data
		do code
		data/g
		set data saved
	]
	do2 [do2 []]
]
```
Output is:
```
self: make object! [
    x: "abc"
    f: func [][?? self print ["x:" mold :self/x]]
    data: make object! [
        g: func [][?? self print ["x:" mold :self/x]]
    ]
    do2: func [code /local saved][
		saved: copy data	;) backup old data
		; set saved data
		do code
		data/g
		set data saved		;) restore data
    ]
]
x: "abc"
self: make object! [
    g: func [][?? self print ["x:" mold :self/x]]
]
x: unset
```
Why `x` is unset? What could go wrong?

Turned out `copy` rebound the function body after copy, and later `set` simply carried the rebound version into the old object.

A workaround is to take an extra step after `copy`:
```
saved: copy data
set saved data
```
But does it look sane? To me it reads like I just copied something, and then I'm copying it *again*, like one time wasn't enough.

I don't think we have a way to produce *just a copy* of the object. `copy/raw` or something would be nice here, though it need to be weighed inside the big scheme of things.



