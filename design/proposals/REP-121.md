
#121: Paths checking with Exists? 
================================================================================
Issue is closed, was reported by GiuseppeChillemi and has 22 comment(s).
[Wish:Rejected]
<https://github.com/red/REP/issues/121>

Using `get/safe` needs further code in this situation, as you can't distinguish between `none!` returned as an error or as a value:

```
>> s: make object! [b: none]
== make object! [
    b: none
]

>> type? get 's/b
== none!
>> 

>> type? get/safe 's/c
== none!
```

In this special case, instead of writing longer checks, it would help to test if a path exists, implementing path controls in `exists?`  

So:

`exists? 's/c` -> `false`




Comments:
--------------------------------------------------------------------------------

On 2022-05-27T16:51:35Z, dockimbel, commented:
<https://github.com/red/REP/issues/121#issuecomment-1139794399>

    ```
    >> attempt [s/c]
    == none
    >> s: [c 1]
    == [c 1]
    >> attempt [s/c]
    == 1
    ```

--------------------------------------------------------------------------------

On 2022-05-27T17:14:40Z, hiiamboris, commented:
<https://github.com/red/REP/issues/121#issuecomment-1139822353>

    Reason for this wish was that `attempt` is too slow to be used in place of it, and that `attempt` does not distinguish `none` value from `none` as access error.
    
    In Red it's often the case that there's a very high-level functionality, but no middle-level primitives which could be used to refit it to another purpose (efficiently anyway).
    
    I think both `get/safe 'path` and `exists? 'path` could coexist and cover slightly different use cases, sharing the same R/S calls.
    
    In my experience, `exists?` is a much rarer need than `get/safe` (and can be formulated as `all [get/safe 'path none <> get/any 'path]`). But objectively, why not?

--------------------------------------------------------------------------------

On 2022-05-29T09:42:58Z, dockimbel, commented:
<https://github.com/red/REP/issues/121#issuecomment-1140413303>

    > Reason for this wish was that attempt is too slow to be used in place of it, and that attempt does not distinguish none value from none as access error.
    
    Here's a better alternative then:
    ```
    >> error? try [s/c]
    == true
    ```
    I don't agree with the statement that this is "too slow", as checking if the path is valid implies evaluating the path completely, which is what `try [s/c]` does, with the little extra overhead of error generation and catching.

--------------------------------------------------------------------------------

On 2022-05-29T10:06:50Z, hiiamboris, commented:
<https://github.com/red/REP/issues/121#issuecomment-1140416656>

    > the little extra overhead
    
    ```
    >> a: none b: [x 1]
    >> clock/times [b/x] 10000000
    0.11 μs	[b/x]
    == 1
    >> clock/times [try [a/x]] 1000000
    1.49 μs	[try [a/x]]
    ```
    That's 14x slower. Add the check that `s/c` is not actually an error object.

--------------------------------------------------------------------------------

On 2022-05-29T16:16:34Z, greggirwin, commented:
<https://github.com/red/REP/issues/121#issuecomment-1140480464>

    ```
    o: object [a: 1]
    m: #(a: 1)
    zzz: none
    
    n: 100'000
    
    Time         | Time (Per)   | Memory      | Code
    0:00:00.009  | 0:00:00.009  | 440         | [loop n [o/a]]
    0:00:00.013  | 0:00:00.013  | 284         | [loop n [m/a]]
    0:00:00.025  | 0:00:00.025  | 284         | [loop n [try [o/a]]]
    0:00:00.027  | 0:00:00.027  | 284         | [loop n [try [m/b]]]
    0:00:00.03   | 0:00:00.03   | 284         | [loop n [try [m/a]]]
    0:00:00.043  | 0:00:00.043  | 284         | [loop n [error? try [o/a]]]
    0:00:00.045  | 0:00:00.045  | 284         | [loop n [error? try [m/b]]]
    0:00:00.048  | 0:00:00.048  | 284         | [loop n [error? try [m/a]]]
    0:00:00.05   | 0:00:00.05   | 440         | [loop n [if not none? zzz [try [zzz/a]]]]
    0:00:00.112  | 0:00:00.112  | 72000284    | [loop n [try [zzz/a]]]
    0:00:00.116  | 0:00:00.116  | 72000284    | [loop n [try [o/b]]]
    0:00:00.134  | 0:00:00.134  | 72000284    | [loop n [error? try [zzz/a]]]
    0:00:00.147  | 0:00:00.147  | 72000284    | [loop n [error? try [o/b]]]
    ```
    It's a lot slower, yes. But we also have to ask if the big hit has a practical effect. My first pass didn't include a map for comparison, but I added it for my own edification. Clearly, the hit occurs when there's an error to handle. If maps can be used, or it's entirely a `none` reference, performance doesn't suffer.
    
    As a core optimization, it makes sense. The question then is why we *shouldn't* do it. I believe this is coming from real and practical use cases @hiiamboris has hit in working on `spaces`. But it's also an interesting question of why we're accessing object elements that may not exist. This fundamentally comes down to Red being data, and objects being sort of a dangling appendix in that regard. They are not strictly "code" as in other OOP langs. 
    
    > attempt does not distinguish none value from none as access error.
    
    This is probably the more important issue it addresses. `exists? <path> | get/safe` don't address *where* in a path something fails to exist, but that's probably more of a high level feature that isn't performance sensitive. e.g. a flexible system browser likely won't have a million items to deal with at a high rate, or will be able to do so incrementally.
    
    

--------------------------------------------------------------------------------

On 2022-05-29T16:46:23Z, hiiamboris, commented:
<https://github.com/red/REP/issues/121#issuecomment-1140485228>

    > I believe this is coming from real and practical use cases @hiiamboris has hit in working on spaces
    
    To be precise, my use case is mostly https://github.com/red/REP/issues/113 . At some point I started [marking it](https://github.com/hiiamboris/red-spaces-gitlab-mirror/search?q=113)
    <img src=https://i.gyazo.com/f9e3de9fa95da522b9a5cd5ab483abdc.png width=250></img>

--------------------------------------------------------------------------------

On 2022-05-29T21:25:17Z, dockimbel, commented:
<https://github.com/red/REP/issues/121#issuecomment-1140527246>

    > clock/times [b/x] 10000000
    
    If you want to do a fair comparison, you should include the cost of the interpreter processing an additional native call to `exists?` or `get/safe`.
    
    A way to speed up my proposal would be to let `try` accept a `lit-path!` directly and either return its value or an error! object (to avoid the cost of a wrapping block).

--------------------------------------------------------------------------------

On 2022-05-29T21:33:57Z, hiiamboris, commented:
<https://github.com/red/REP/issues/121#issuecomment-1140528578>

    Sorry, you're correct here, though the only existing thing that would be close is `get/any` I presume (still a get, single refinement):
    ```
    >> clock/times [get/any 'b/x] 10000000
    0.29 μs	[get/any 'b/x]
    >> clock/times [try [get/any 'a/x]] 1000000
    2.11 μs	[try [get/any 'a/x]]
    >> 211 / 29
    == 7.275862068965517
    ```
    
    > A way to speed up my proposal would be to let try accept a lit-path! directly and either return its value or an error! object (to avoid the cost of a wrapping block).
    
    Could it be though that the error object creation is the main source of slowdown? Could `fire` create a "promise" of an error object that is not created until accessed?

--------------------------------------------------------------------------------

On 2022-05-29T21:42:32Z, dockimbel, commented:
<https://github.com/red/REP/issues/121#issuecomment-1140529899>

    For a fully fair comparison: `get/any 'b/x` vs `error! = try [b/x]`.
    
    > Could it be though that the error object creation is the main source of slowdown?
    
    I'm not sure if the error! creation code itself is the cause, it could be the error! memory allocations that might trigger GC pass(es) during the benchmark.
    
    > Could fire create a "promise" of an error object that is not created until accessed?
    
    That would hardly fit the Red semantics. `try` has to return an error! value on the stack, being it processed immediately or by another parent call earlier in the call stack. The only consistent way would be to introduce another datatype specifically for that usage.

--------------------------------------------------------------------------------

On 2022-05-30T22:25:26Z, GiuseppeChillemi, commented:
<https://github.com/red/REP/issues/121#issuecomment-1141516065>

    @dockimbel I like all of your proposals and at the same time I keep `exists?`
    
    `try` accepting `lit-path!` should avoid the cost of double path decoding you have when you express as:
     
    ```
    if  none? x: get-safe 'my/lit/path [if exists? 'my/lit/path [code]]  
    ```
    
    Also, the idea of a new datatype to distinguish when `none` is returned because no element has been found and when `none` has been returned is a good idea too (If I have understood correctly your proposal)
    
     It is good to me any of the above and ALSO adding path checking to `exists?` because it already manages files path and seems  a natural prosecution. Also, it makes readable sentences: `if exists?  'my/lit/path [do code]` is very clean.
     
     

--------------------------------------------------------------------------------

On 2022-08-09T22:20:12Z, GiuseppeChillemi, commented:
<https://github.com/red/REP/issues/121#issuecomment-1209949006>

    Some additional notes on this topic here: https://gitter.im/red/help?at=62f22942443b7927a7338656

